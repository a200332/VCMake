<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#CREATING-A-CLASS">CREATING A CLASS</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DateTime::Format::Builder::Tutorial - Quick class on using Builder</p>

<h1 id="VERSION">VERSION</h1>

<p>version 0.81</p>

<h1 id="CREATING-A-CLASS">CREATING A CLASS</h1>

<p>As most people who are writing modules know, you start a package with a package declaration and some indication of module version:</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">DateTime::Format::ICal</span><span class="operator">;</span>
    <span class="keyword">our</span> <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="string">'0.04'</span><span class="operator">;</span>
</code></pre>

<p>After that, you call Builder with some options. There are only a few (detailed later). Right now, we&#39;re only interested in <i>parsers</i>.</p>

<pre><code>    <span class="keyword">use</span> <span class="variable">DateTime::Format::Builder</span>
    <span class="operator">(</span>
        <span class="string">parsers</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
        <span class="operator">...</span>
        <span class="operator">}</span>
    <span class="operator">);</span>
</code></pre>

<p>The <i>parsers</i> option takes a reference to a hash of method names and specifications:</p>

<pre><code>        <span class="string">parsers</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
            <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">,</span>
            <span class="string">parse_datetime_with_timezone</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">,</span>
            <span class="operator">...</span>
        <span class="operator">}</span>
</code></pre>

<p>Builder will create methods in your class, each method being a parser that follows the given specifications. It is <b>strongly</b> recommended that one method is called <i>parse_datetime</i>, be it a Builder created method or one of your own.</p>

<p>In addition to creating any of the parser methods it also creates a <code>new()</code> method that can instantiate (or clone) objects of this class. This behaviour can be modified with the <i>constructor</i> option, but we don&#39;t need to know that yet.</p>

<p>Each value corresponding to a method name in the parsers list is either a single specification, or a list of specifications. We&#39;ll start with the simple case.</p>

<pre><code>        <span class="string">parse_briefdate</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
</code></pre>

<p>This will result in a method named <i>parse_briefdate</i> which will take strings in the form <code>20040716</code> and return DateTime objects representing that date. A user of the class might write:</p>

<pre><code>    <span class="keyword">use</span> <span class="variable">DateTime::Format::ICal</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$date</span> <span class="operator">=</span> <span class="string">"19790716"</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$dt</span> <span class="operator">=</span> <span class="variable">DateTime::Format::ICal</span><span class="operator">-&gt;</span><span class="variable">parse_briefdate</span><span class="operator">(</span> <span class="variable">$date</span> <span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"My birth month is "</span><span class="operator">,</span> <span class="variable">$dt</span><span class="operator">-&gt;</span><span class="variable">month_name</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></pre>

<p>The <code>regex</code> is applied to the input string, and if it matches, then <code>$1</code>, <code>$2</code>, ... are mapped to the <i>params</i> given and handed to <code>DateTime-&gt;new()</code>. Essentially:</p>

<pre><code>    <span class="keyword">my</span> <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">DateTime</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">year</span> <span class="operator">=&gt;</span> <span class="variable">$1</span><span class="operator">,</span> <span class="string">month</span> <span class="operator">=&gt;</span> <span class="variable">$2</span><span class="operator">,</span> <span class="string">day</span> <span class="operator">=&gt;</span> <span class="variable">$3</span> <span class="operator">);</span>
</code></pre>

<p>There are more complicated things one can do within a single specification, but we&#39;ll cover those later.</p>

<p>Often, you&#39;ll want a method to be able to take one string, and run it against multiple parser specifications. It would be very irritating if the user had to work out what format the datetime string was in and then which method was most appropriate.</p>

<p>So, Builder lets you specify multiple specifications:</p>

<pre><code>    <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute second )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
    <span class="operator">]</span><span class="operator">,</span>
</code></pre>

<p>It&#39;s an arrayref of specifications. A parser will be created that will try each of these specifications sequentially, in the order you specified.</p>

<p>There&#39;s a flaw with this though. In this example, we&#39;re building a parser for ICal datetimes. One can place a timezone id at the start of an ICal datetime. You might extract such an id with the following code:</p>

<pre><code>    <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/^TZID=([^:]+)://</span> <span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">$time_zone</span> <span class="operator">=</span> <span class="variable">$1</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="comment"># Z at end means UTC</span>
    <span class="keyword">elsif</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/Z$//</span> <span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">$time_zone</span> <span class="operator">=</span> <span class="string">'UTC'</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">else</span>
    <span class="operator">{</span>
        <span class="variable">$time_zone</span> <span class="operator">=</span> <span class="string">'floating'</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></pre>

<p><code>$date</code> would end up without the id, and <code>$time_zone</code> would contain something appropriate to give to DateTime&#39;s <i>set_time_zone</i> method, or <i>time_zone</i> argument.</p>

<p>But how to get this scrap of code into your parser? You might be tempted to call the parser something else and build a small wrapper. There&#39;s no need though because an option is provided for preprocesing dates:</p>

<pre><code>    <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">preprocess</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">_parse_tz</span> <span class="operator">]</span><span class="operator">,</span> <span class="comment"># Only changed line!</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute second )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
    <span class="operator">]</span><span class="operator">,</span>
</code></pre>

<p>It will necessitate <i>_parse_tz</i> to be written, and that routine looks like this:</p>

<pre><code>    <span class="keyword">sub</span><span class="variable"> _parse_tz
    </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">%args</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$date</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@args</span><span class="operator">{</span><span class="string">qw( input parsed )</span><span class="operator">}</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/^TZID=([^:]+)://</span> <span class="operator">)</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$1</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="comment"># Z at end means UTC</span>
        <span class="keyword">elsif</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/Z$//</span> <span class="operator">)</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'UTC'</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">else</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'floating'</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">$date</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></pre>

<p>On input it is given a hash containing two items: the input date and a hashref that will be used in the parsing. The return value from the routine is what the parser specifications will run against, and anything in the <i>parsed</i> hash (<code>$p</code> in the example) will be put in the call to <code>DateTime-&gt;new(...)</code>.</p>

<p>So, we now have a happily working ICal parser. It parses the assorted formats, and can also handle timezones. Is there anything else it needs to do? No. But we can make it work more efficiently.</p>

<p>At present, the specifications are tested sequentially. However, each one applies to strings of particular lengths. Thus we could be efficient and have the parser only test the given strings against a parser that handles that string length. Again, Builder makes it easy:</p>

<pre><code>    <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
        <span class="operator">[</span> <span class="string">preprocess</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">_parse_tz</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">15</span><span class="operator">,</span> <span class="comment"># We handle strings of exactly 15 chars</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute second )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">13</span><span class="operator">,</span> <span class="comment"># exactly 13 chars...</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">11</span><span class="operator">,</span> <span class="comment"># 11..</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">{</span>
            <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">8</span><span class="operator">,</span> <span class="comment"># yes.</span>
            <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day )</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">]</span><span class="operator">,</span>
</code></pre>

<p>Now the created parser will create a parser that only runs specifications against appropriate strings.</p>

<p>So our complete code looks like:</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">DateTime::Format::ICal</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
    <span class="keyword">our</span> <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="string">'0.04'</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">DateTime::Format::Builder</span>
    <span class="operator">(</span>
        <span class="string">parsers</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
            <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
            <span class="operator">[</span> <span class="string">preprocess</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">_parse_tz</span> <span class="operator">]</span><span class="operator">,</span>
            <span class="operator">{</span>
                <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">15</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute second )</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span>
                <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">13</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour minute )</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)(\d\d)$/</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span>
                <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">11</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day hour )</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)T(\d\d)$/</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span>
                <span class="string">length</span> <span class="operator">=&gt;</span> <span class="number">8</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="string">qw( year month day )</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
    <span class="operator">);</span>
    
    <span class="keyword">sub</span><span class="variable"> _parse_tz
    </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">%args</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$date</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@args</span><span class="operator">{</span><span class="string">qw( input parsed )</span><span class="operator">}</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/^TZID=([^:]+)://</span> <span class="operator">)</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$1</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="comment"># Z at end means UTC</span>
        <span class="keyword">elsif</span> <span class="operator">(</span> <span class="variable">$date</span> <span class="operator">=~</span> <span class="regex">s/Z$//</span> <span class="operator">)</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'UTC'</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">else</span>
        <span class="operator">{</span>
            <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">time_zone</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'floating'</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">$date</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="number">1</span><span class="operator">;</span>
</code></pre>

<p>And that&#39;s an ICal parser. The actual <a>DateTime::Format::ICal</a> module also includes formatting methods and parsing for durations, but Builder doesn&#39;t support those yet. A drop in replacement (at the time of writing the replacement) can be found in the <i>examples</i> directory of the Builder distribution, along with similar variants of other common modules.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>Any errors you see in this document, please log them with CPAN RT system via the web or email:</p>

<pre><code>    http://perl.dellah.org/rt/dtbuilder
    bug-datetime-format-builder@rt.cpan.org</code></pre>

<p>This makes it much easier for me to track things and thus means your problem is less likely to be neglected.</p>

<h1 id="LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</h1>

<p>Copyright &copy; Iain Truskett, 2003. All rights reserved.</p>

<p>You can redistribute this document and/or modify it under the same terms as Perl itself.</p>

<p>The full text of the licenses can be found in the <i>Artistic</i> and <i>COPYING</i> files included with this document.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><code>datetime@perl.org</code> mailing list.</p>

<p>http://datetime.perl.org/</p>

<p><a href="../../../../lib/pods/perl.html">perl</a>, <a href="../../../../lib/DateTime.html">DateTime</a>, <a href="../../../../lib/DateTime/Format/Builder.html">DateTime::Format::Builder</a></p>

<h1 id="AUTHORS">AUTHORS</h1>

<ul>

<li><p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</li>
<li><p>Iain Truskett</p>

</li>
</ul>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>This software is Copyright (c) 2013 by Dave Rolsky.</p>

<p>This is free software, licensed under:</p>

<pre><code>  The Artistic License 2.0 (GPL Compatible)</code></pre>


</body>

</html>


