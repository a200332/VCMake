<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#TUTORIAL">TUTORIAL</a></li>
  <li><a href="#ERROR-HANDLING-AND-BAD-PARSES">ERROR HANDLING AND BAD PARSES</a></li>
  <li><a href="#SINGLE-SPECIFICATIONS">SINGLE SPECIFICATIONS</a>
    <ul>
      <li><a href="#Subroutines-coderefs-as-specifications">Subroutines / coderefs as specifications.</a></li>
      <li><a href="#Callbacks">Callbacks</a></li>
    </ul>
  </li>
  <li><a href="#MULTIPLE-SPECIFICATIONS">MULTIPLE SPECIFICATIONS</a></li>
  <li><a href="#EXECUTION-FLOW">EXECUTION FLOW</a>
    <ul>
      <li><a href="#For-Single-Specifications">For Single Specifications</a></li>
      <li><a href="#For-Multiple-Specifications">For Multiple Specifications</a></li>
    </ul>
  </li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#import">import</a></li>
      <li><a href="#create_class">create_class</a></li>
    </ul>
  </li>
  <li><a href="#SUBCLASSING">SUBCLASSING</a>
    <ul>
      <li><a href="#create_method">create_method</a></li>
      <li><a href="#on_fail">on_fail</a></li>
    </ul>
  </li>
  <li><a href="#USING-BUILDER-OBJECTS-aka-USERS-USING-BUILDER">USING BUILDER OBJECTS aka USERS USING BUILDER</a>
    <ul>
      <li><a href="#new">new</a></li>
      <li><a href="#clone">clone</a></li>
      <li><a href="#parser">parser</a></li>
      <li><a href="#set_parser">set_parser</a></li>
      <li><a href="#get_parser">get_parser</a></li>
      <li><a href="#parse_datetime">parse_datetime</a></li>
      <li><a href="#format_datetime">format_datetime</a></li>
    </ul>
  </li>
  <li><a href="#LONGER-EXAMPLES">LONGER EXAMPLES</a></li>
  <li><a href="#THANKS">THANKS</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DateTime::Format::Builder - Create DateTime parser classes and objects.</p>

<h1 id="VERSION">VERSION</h1>

<p>version 0.81</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    <span class="keyword">package</span> <span class="variable">DateTime::Format::Brief</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">DateTime::Format::Builder</span>
    <span class="operator">(</span>
        <span class="string">parsers</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
            <span class="string">parse_datetime</span> <span class="operator">=&gt;</span> <span class="operator">[</span>
            <span class="operator">{</span>
                <span class="string">regex</span> <span class="operator">=&gt;</span> <span class="string">qr/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw( year month day hour minute second )</span><span class="operator">]</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span>
                <span class="string">regex</span> <span class="operator">=&gt;</span> <span class="string">qr/^(\d{4})(\d\d)(\d\d)$/</span><span class="operator">,</span>
                <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw( year month day )</span><span class="operator">]</span><span class="operator">,</span>
            <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">}</span>
    <span class="operator">);</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>DateTime::Format::Builder creates DateTime parsers. Many string formats of dates and times are simple and just require a basic regular expression to extract the relevant information. Builder provides a simple way to do this without writing reams of structural code.</p>

<p>Builder provides a number of methods, most of which you&#39;ll never need, or at least rarely need. They&#39;re provided more for exposing of the module&#39;s innards to any subclasses, or for when you need to do something slightly beyond what I expected.</p>

<p>This creates the end methods. Coderefs die on bad parses, return <code>DateTime</code> objects on good parse.</p>

<h1 id="TUTORIAL">TUTORIAL</h1>

<p>See <a href="../../../lib/DateTime/Format/Builder/Tutorial.html">DateTime::Format::Builder::Tutorial</a>.</p>

<h1 id="ERROR-HANDLING-AND-BAD-PARSES">ERROR HANDLING AND BAD PARSES</h1>

<p>Often, I will speak of <code>undef</code> being returned, however that&#39;s not strictly true.</p>

<p>When a simple single specification is given for a method, the method isn&#39;t given a single parser directly. It&#39;s given a wrapper that will call <code>on_fail()</code> if the single parser returns <code>undef</code>. The single parser must return <code>undef</code> so that a multiple parser can work nicely and actual errors can be thrown from any of the callbacks.</p>

<p>Similarly, any multiple parsers will only call <code>on_fail()</code> right at the end when it&#39;s tried all it could.</p>

<p><code>on_fail()</code> (see <a href="#on_fail">later</a>) is defined, by default, to throw an error.</p>

<p>Multiple parser specifications can also specify <code>on_fail</code> with a coderef as an argument in the options block. This will take precedence over the inheritable and over-ridable method.</p>

<p>That said, don&#39;t throw real errors from callbacks in multiple parser specifications unless you really want parsing to stop right there and not try any other parsers.</p>

<p>In summary: calling a <b>method</b> will result in either a <code>DateTime</code> object being returned or an error being thrown (unless you&#39;ve overridden <code>on_fail()</code> or <code>create_method()</code>, or you&#39;ve specified a <code>on_fail</code> key to a multiple parser specification).</p>

<p>Individual <b>parsers</b> (be they multiple parsers or single parsers) will return either the <code>DateTime</code> object or <code>undef</code>.</p>

<h1 id="SINGLE-SPECIFICATIONS">SINGLE SPECIFICATIONS</h1>

<p>A single specification is a hash ref of instructions on how to create a parser.</p>

<p>The precise set of keys and values varies according to parser type. There are some common ones though:</p>

<ul>

<li><p><b>length</b> is an optional parameter that can be used to specify that this particular <i>regex</i> is only applicable to strings of a certain fixed length. This can be used to make parsers more efficient. It&#39;s strongly recommended that any parser that can use this parameter does.</p>

<p>You may happily specify the same length twice. The parsers will be tried in order of specification.</p>

<p>You can also specify multiple lengths by giving it an arrayref of numbers rather than just a single scalar. If doing so, please keep the number of lengths to a minimum.</p>

<p>If any specifications without <i>length</i>s are given and the particular <i>length</i> parser fails, then the non-<i>length</i> parsers are tried.</p>

<p>This parameter is ignored unless the specification is part of a multiple parser specification.</p>

</li>
<li><p><b>label</b> provides a name for the specification and is passed to some of the callbacks about to mentioned.</p>

</li>
<li><p><b>on_match</b> and <b>on_fail</b> are callbacks. Both routines will be called with parameters of:</p>

<ul>

<li><p><b>input</b>, being the input to the parser (after any preprocessing callbacks).</p>

</li>
<li><p><b>label</b>, being the label of the parser, if there is one.</p>

</li>
<li><p><b>self</b>, being the object on which the method has been invoked (which may just be a class name). Naturally, you can then invoke your own methods on it do get information you want.</p>

</li>
<li><p><b>args</b>, being an arrayref of any passed arguments, if any. If there were no arguments, then this parameter is not given.</p>

</li>
</ul>

<p>These routines will be called depending on whether the <b>regex</b> match succeeded or failed.</p>

</li>
<li><p><b>preprocess</b> is a callback provided for cleaning up input prior to parsing. It&#39;s given a hash as arguments with the following keys:</p>

<ul>

<li><p><b>input</b> being the datetime string the parser was given (if using multiple specifications and an overall <i>preprocess</i> then this is the date after it&#39;s been through that preprocessor).</p>

</li>
<li><p><b>parsed</b> being the state of parsing so far. Usually empty at this point unless an overall <i>preprocess</i> was given. Items may be placed in it and will be given to any <b>postprocess</b>or and <code>DateTime-&gt;new</code> (unless the postprocessor deletes it).</p>

</li>
<li><p><b>self</b>, <b>args</b>, <b>label</b> as per <i>on_match</i> and <i>on_fail</i>.</p>

</li>
</ul>

<p>The return value from the routine is what is given to the <i>regex</i>. Note that this is last code stop before the match.</p>

<p><b>Note</b>: mixing <i>length</i> and a <i>preprocess</i> that modifies the length of the input string is probably not what you meant to do. You probably meant to use the <i>multiple parser</i> variant of <i>preprocess</i> which is done <b>before</b> any length calculations. This <code>single parser</code> variant of <i>preprocess</i> is performed <b>after</b> any length calculations.</p>

</li>
<li><p><b>postprocess</b> is the last code stop before <code>DateTime-&gt;new()</code> is called. It&#39;s given the same arguments as <i>preprocess</i>. This allows it to modify the parsed parameters after the parse and before the creation of the object. For example, you might use:</p>

<pre><code>    <span class="operator">{</span>
        <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^(\d\d) (\d\d) (\d\d)$/</span><span class="operator">,</span>
        <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw( year  month  day   )</span><span class="operator">]</span><span class="operator">,</span>
        <span class="string">postprocess</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">_fix_year</span><span class="operator">,</span>
    <span class="operator">}</span>
</code></pre>

<p>where <code>_fix_year</code> is defined as:</p>

<pre><code>    <span class="keyword">sub</span><span class="variable"> _fix_year
    </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">%args</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$date</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@args</span><span class="operator">{</span><span class="string">qw( input parsed )</span><span class="operator">}</span><span class="operator">;</span>
        <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">year</span><span class="operator">}</span> <span class="operator">+=</span> <span class="variable">$p</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">year</span><span class="operator">}</span> <span class="operator">&gt;</span> <span class="number">69</span> <span class="operator">?</span> <span class="number">1900</span> <span class="operator">:</span> <span class="number">2000</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></pre>

<p>This will cause the two digit years to be corrected according to the cut off. If the year was &#39;69&#39; or lower, then it is made into 2069 (or 2045, or whatever the year was parsed as). Otherwise it is assumed to be 19xx. The <a href="../../../lib/DateTime/Format/Mail.html">DateTime::Format::Mail</a> module uses code similar to this (only it allows the cut off to be configured and it doesn&#39;t use Builder).</p>

<p><b>Note</b>: It is <b>very important</b> to return an explicit value from the <i>postprocess</i> callback. If the return value is false then the parse is taken to have failed. If the return value is true, then the parse is taken to have succeeded and <code>DateTime-&gt;new()</code> is called.</p>

</li>
</ul>

<p>See the documentation for the individual parsers for their valid keys.</p>

<p>Parsers at the time of writing are:</p>

<ul>

<li><p><a href="../../../lib/DateTime/Format/Builder/Parser/Regex.html">DateTime::Format::Builder::Parser::Regex</a> - provides regular expression based parsing.</p>

</li>
<li><p><a href="../../../lib/DateTime/Format/Builder/Parser/Strptime.html">DateTime::Format::Builder::Parser::Strptime</a> - provides strptime based parsing.</p>

</li>
</ul>

<h2 id="Subroutines-coderefs-as-specifications">Subroutines / coderefs as specifications.</h2>

<p>A single parser specification can be a coderef. This was added mostly because it could be and because I knew someone, somewhere, would want to use it.</p>

<p>If the specification is a reference to a piece of code, be it a subroutine, anonymous, or whatever, then it&#39;s passed more or less straight through. The code should return <code>undef</code> in event of failure (or any false value, but <code>undef</code> is strongly preferred), or a true value in the event of success (ideally a <code>DateTime</code> object or some object that has the same interface).</p>

<p>This all said, I generally wouldn&#39;t recommend using this feature unless you have to.</p>

<h2 id="Callbacks">Callbacks</h2>

<p>I mention a number of callbacks in this document.</p>

<p>Any time you see a callback being mentioned, you can, if you like, substitute an arrayref of coderefs rather than having the straight coderef.</p>

<h1 id="MULTIPLE-SPECIFICATIONS">MULTIPLE SPECIFICATIONS</h1>

<p>These are very easily described as an array of single specifications.</p>

<p>Note that if the first element of the array is an arrayref, then you&#39;re specifying options.</p>

<ul>

<li><p><b>preprocess</b> lets you specify a preprocessor that is called before any of the parsers are tried. This lets you do things like strip off timezones or any unnecessary data. The most common use people have for it at present is to get the input date to a particular length so that the <i>length</i> is usable (<a>DateTime::Format::ICal</a> would use it to strip off the variable length timezone).</p>

<p>Arguments are as for the <i>single parser</i> <i>preprocess</i> variant with the exception that <i>label</i> is never given.</p>

</li>
<li><p><b>on_fail</b> should be a reference to a subroutine that is called if the parser fails. If this is not provided, the default action is to call <code>DateTime::Format::Builder::on_fail</code>, or the <code>on_fail</code> method of the subclass of DTFB that was used to create the parser.</p>

</li>
</ul>

<h1 id="EXECUTION-FLOW">EXECUTION FLOW</h1>

<p>Builder allows you to plug in a fair few callbacks, which can make following how a parse failed (or succeeded unexpectedly) somewhat tricky.</p>

<h2 id="For-Single-Specifications">For Single Specifications</h2>

<p>A single specification will do the following:</p>

<p>User calls parser:</p>

<pre><code>       <span class="keyword">my</span> <span class="variable">$dt</span> <span class="operator">=</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">parse_datetime</span><span class="operator">(</span> <span class="variable">$string</span> <span class="operator">);</span>
</code></pre>

<ol>

<li><p><i>preprocess</i> is called. It&#39;s given <code>$string</code> and a reference to the parsing workspace hash, which we&#39;ll call <code>$p</code>. At this point, <code>$p</code> is empty. The return value is used as <code>$date</code> for the rest of this single parser. Anything put in <code>$p</code> is also used for the rest of this single parser.</p>

</li>
<li><p><i>regex</i> is applied.</p>

</li>
<li><p>If <i>regex</i> <b>did not</b> match, then <i>on_fail</i> is called (and is given <code>$date</code> and also <i>label</i> if it was defined). Any return value is ignored and the next thing is for the single parser to return <code>undef</code>.</p>

<p>If <i>regex</i> <b>did</b> match, then <i>on_match</i> is called with the same arguments as would be given to <i>on_fail</i>. The return value is similarly ignored, but we then move to step 4 rather than exiting the parser.</p>

</li>
<li><p><i>postprocess</i> is called with <code>$date</code> and a filled out <code>$p</code>. The return value is taken as a indication of whether the parse was a success or not. If it wasn&#39;t a success then the single parser will exit at this point, returning undef.</p>

</li>
<li><p><code>DateTime-&gt;new()</code> is called and the user is given the resultant <code>DateTime</code> object.</p>

</li>
</ol>

<p>See the section on <a href="#ERROR-HANDLING-AND-BAD-PARSES">error handling</a> regarding the <code>undef</code>s mentioned above.</p>

<h2 id="For-Multiple-Specifications">For Multiple Specifications</h2>

<p>With multiple specifications:</p>

<p>User calls parser:</p>

<pre><code>      <span class="keyword">my</span> <span class="variable">$dt</span> <span class="operator">=</span> <span class="variable">$class</span><span class="operator">-&gt;</span><span class="variable">complex_parse</span><span class="operator">(</span> <span class="variable">$string</span> <span class="operator">);</span>
</code></pre>

<ol>

<li><p>The overall <i>preprocess</i>or is called and is given <code>$string</code> and the hashref <code>$p</code> (identically to the per parser <i>preprocess</i> mentioned in the previous flow).</p>

<p>If the callback modifies <code>$p</code> then a <b>copy</b> of <code>$p</code> is given to each of the individual parsers. This is so parsers won&#39;t accidentally pollute each other&#39;s workspace.</p>

</li>
<li><p>If an appropriate length specific parser is found, then it is called and the single parser flow (see the previous section) is followed, and the parser is given a copy of <code>$p</code> and the return value of the overall <i>preprocess</i>or as <code>$date</code>.</p>

<p>If a <code>DateTime</code> object was returned so we go straight back to the user.</p>

<p>If no appropriate parser was found, or the parser returned <code>undef</code>, then we progress to step 3!</p>

</li>
<li><p>Any non-<i>length</i> based parsers are tried in the order they were specified.</p>

<p>For each of those the single specification flow above is performed, and is given a copy of the output from the overall preprocessor.</p>

<p>If a real <code>DateTime</code> object is returned then we exit back to the user.</p>

<p>If no parser could parse, then an error is thrown.</p>

</li>
</ol>

<p>See the section on <a href="#ERROR-HANDLING-AND-BAD-PARSES">error handling</a> regarding the <code>undef</code>s mentioned above.</p>

<h1 id="METHODS">METHODS</h1>

<p>In the general course of things you won&#39;t need any of the methods. Life often throws unexpected things at us so the methods are all available for use.</p>

<h2 id="import">import</h2>

<p><code>import()</code> is a wrapper for <code>create_class()</code>. If you specify the <i>class</i> option (see documentation for <code>create_class()</code>) it will be ignored.</p>

<h2 id="create_class">create_class</h2>

<p>This method can be used as the runtime equivalent of <code>import()</code>. That is, it takes the exact same parameters as when one does:</p>

<pre><code>   use DateTime::Format::Builder ( blah blah blah )</code></pre>

<p>That can be (almost) equivalently written as:</p>

<pre><code>   <span class="keyword">use</span> <span class="variable">DateTime::Format::Builder</span><span class="operator">;</span>
   <span class="variable">DateTime::Format::Builder</span><span class="operator">-&gt;</span><span class="variable">create_class</span><span class="operator">(</span> <span class="variable">blah</span> <span class="variable">blah</span> <span class="variable">blah</span> <span class="operator">);</span>
</code></pre>

<p>The difference being that the first is done at compile time while the second is done at run time.</p>

<p>In the tutorial I said there were only two parameters at present. I lied. There are actually three of them.</p>

<ul>

<li><p><b>parsers</b> takes a hashref of methods and their parser specifications. See the <a href="../../../lib/DateTime/Format/Builder/Tutorial.html">DateTime::Format::Builder::Tutorial</a> for details.</p>

<p>Note that if you define a subroutine of the same name as one of the methods you define here, an error will be thrown.</p>

</li>
<li><p><b>constructor</b> determines whether and how to create a <code>new()</code> function in the new class. If given a true value, a constructor is created. If given a false value, one isn&#39;t.</p>

<p>If given an anonymous sub or a reference to a sub then that is used as <code>new()</code>.</p>

<p>The default is <code>1</code> (that is, create a constructor using our default code which simply creates a hashref and blesses it).</p>

<p>If your class defines its own <code>new()</code> method it will not be overwritten. If you define your own <code>new()</code> and <b>also</b> tell Builder to define one an error will be thrown.</p>

</li>
<li><p><b>verbose</b> takes a value. If the value is undef, then logging is disabled. If the value is a filehandle then that&#39;s where logging will go. If it&#39;s a true value, then output will go to <code>STDERR</code>.</p>

<p>Alternatively, call <code>$DateTime::Format::Builder::verbose()</code> with the relevant value. Whichever value is given more recently is adhered to.</p>

<p>Be aware that verbosity is a global wide setting.</p>

</li>
<li><p><b>class</b> is optional and specifies the name of the class in which to create the specified methods.</p>

<p>If using this method in the guise of <code>import()</code> then this field will cause an error so it is only of use when calling as <code>create_class()</code>.</p>

</li>
<li><p><b>version</b> is also optional and specifies the value to give <code>$VERSION</code> in the class. It&#39;s generally not recommended unless you&#39;re combining with the <i>class</i> option. A <code>ExtUtils::MakeMaker</code> / <code>CPAN</code> compliant version specification is much better.</p>

</li>
</ul>

<p>In addition to creating any of the methods it also creates a <code>new()</code> method that can instantiate (or clone) objects.</p>

<h1 id="SUBCLASSING">SUBCLASSING</h1>

<p>In the rest of the documentation I&#39;ve often lied in order to get some of the ideas across more easily. The thing is, this module&#39;s very flexible. You can get markedly different behaviour from simply subclassing it and overriding some methods.</p>

<h2 id="create_method">create_method</h2>

<p>Given a parser coderef, returns a coderef that is suitable to be a method.</p>

<p>The default action is to call <code>on_fail()</code> in the event of a non-parse, but you can make it do whatever you want.</p>

<h2 id="on_fail">on_fail</h2>

<p>This is called in the event of a non-parse (unless you&#39;ve overridden <code>create_method()</code> to do something else.</p>

<p>The single argument is the input string. The default action is to call <code>croak()</code>. Above, where I&#39;ve said parsers or methods throw errors, this is the method that is doing the error throwing.</p>

<p>You could conceivably override this method to, say, return <code>undef</code>.</p>

<h1 id="USING-BUILDER-OBJECTS-aka-USERS-USING-BUILDER">USING BUILDER OBJECTS aka USERS USING BUILDER</h1>

<p>The methods listed in the <a>METHODS</a> section are all you generally need when creating your own class. Sometimes you may not want a full blown class to parse something just for this one program. Some methods are provided to make that task easier.</p>

<h2 id="new">new</h2>

<p>The basic constructor. It takes no arguments, merely returns a new <code>DateTime::Format::Builder</code> object.</p>

<pre><code>    <span class="keyword">my</span> <span class="variable">$parser</span> <span class="operator">=</span> <span class="variable">DateTime::Format::Builder</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
</code></pre>

<p>If called as a method on an object (rather than as a class method), then it clones the object.</p>

<pre><code>    <span class="keyword">my</span> <span class="variable">$clone</span> <span class="operator">=</span> <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
</code></pre>

<h2 id="clone">clone</h2>

<p>Provided for those who prefer an explicit <code>clone()</code> method rather than using <code>new()</code> as an object method.</p>

<pre><code>    <span class="keyword">my</span> <span class="variable">$clone_of_clone</span> <span class="operator">=</span> <span class="variable">$clone</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">();</span>
</code></pre>

<h2 id="parser">parser</h2>

<p>Given either a single or multiple parser specification, sets the object to have a parser based on that specification.</p>

<pre><code>    <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">parser</span><span class="operator">(</span>
        <span class="string">regex</span>  <span class="operator">=&gt;</span> <span class="string">qr/^ (\d{4}) (\d\d) (\d\d) $/x</span><span class="operator">;</span>
        <span class="string">params</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw( year    month  day    )</span><span class="operator">]</span><span class="operator">,</span>
    <span class="operator">);</span>
</code></pre>

<p>The arguments given to <code>parser()</code> are handed directly to <code>create_parser()</code>. The resultant parser is passed to <code>set_parser()</code>.</p>

<p>If called as an object method, it returns the object.</p>

<p>If called as a class method, it creates a new object, sets its parser and returns that object.</p>

<h2 id="set_parser">set_parser</h2>

<p>Sets the parser of the object to the given parser.</p>

<pre><code>   <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">set_parser</span><span class="operator">(</span> <span class="variable">$coderef</span> <span class="operator">);</span>
</code></pre>

<p>Note: this method does not take specifications. It also does not take anything except coderefs. Luckily, coderefs are what most of the other methods produce.</p>

<p>The method return value is the object itself.</p>

<h2 id="get_parser">get_parser</h2>

<p>Returns the parser the object is using.</p>

<pre><code>   <span class="keyword">my</span> <span class="variable">$code</span> <span class="operator">=</span> <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">get_parser</span><span class="operator">();</span>
</code></pre>

<h2 id="parse_datetime">parse_datetime</h2>

<p>Given a string, it calls the parser and returns the <code>DateTime</code> object that results.</p>

<pre><code>   <span class="keyword">my</span> <span class="variable">$dt</span> <span class="operator">=</span> <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">parse_datetime</span><span class="operator">(</span> <span class="string">"1979 07 16"</span> <span class="operator">);</span>
</code></pre>

<p>The return value, if not a <code>DateTime</code> object, is whatever the parser wants to return. Generally this means that if the parse failed an error will be thrown.</p>

<h2 id="format_datetime">format_datetime</h2>

<p>If you call this function, it will throw an errror.</p>

<h1 id="LONGER-EXAMPLES">LONGER EXAMPLES</h1>

<p>Some longer examples are provided in the distribution. These implement some of the common parsing DateTime modules using Builder. Each of them are, or were, drop in replacements for the modules at the time of writing them.</p>

<h1 id="THANKS">THANKS</h1>

<p>Dave Rolsky (DROLSKY) for kickstarting the DateTime project, writing <a>DateTime::Format::ICal</a> and <a href="../../../lib/DateTime/Format/MySQL.html">DateTime::Format::MySQL</a>, and some much needed review.</p>

<p>Joshua Hoblitt (JHOBLITT) for the concept, some of the API, impetus for writing the multilength code (both one length with multiple parsers and single parser with multiple lengths), blame for the Regex custom constructor code, spotting a bug in Dispatch, and more much needed review.</p>

<p>Kellan Elliott-McCrea (KELLAN) for even more review, suggestions, <a href="../../../lib/DateTime/Format/W3CDTF.html">DateTime::Format::W3CDTF</a> and the encouragement to rewrite these docs almost 100%!</p>

<p>Claus F&auml;rber (CFAERBER) for having me get around to fixing the auto-constructor writing, providing the &#39;args&#39;/&#39;self&#39; patch, and suggesting the multi-callbacks.</p>

<p>Rick Measham (RICKM) for <a href="../../../lib/DateTime/Format/Strptime.html">DateTime::Format::Strptime</a> which Builder now supports.</p>

<p>Matthew McGillis for pointing out that <code>on_fail</code> overriding should be simpler.</p>

<p>Simon Cozens (SIMON) for saying it was cool.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>Support for this module is provided via the datetime@perl.org email list. See http://lists.perl.org/ for more details.</p>

<p>Alternatively, log them via the CPAN RT system via the web or email:</p>

<pre><code>    http://rt.cpan.org/NoAuth/ReportBug.html?Queue=DateTime%3A%3AFormat%3A%3ABuilder
    bug-datetime-format-builder@rt.cpan.org</code></pre>

<p>This makes it much easier for me to track things and thus means your problem is less likely to be neglected.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><code>datetime@perl.org</code> mailing list.</p>

<p>http://datetime.perl.org/</p>

<p><a href="../../../lib/pods/perl.html">perl</a>, <a href="../../../lib/DateTime.html">DateTime</a>, <a href="../../../lib/DateTime/Format/Builder/Tutorial.html">DateTime::Format::Builder::Tutorial</a>, <a href="../../../lib/DateTime/Format/Builder/Parser.html">DateTime::Format::Builder::Parser</a></p>

<h1 id="AUTHORS">AUTHORS</h1>

<ul>

<li><p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</li>
<li><p>Iain Truskett</p>

</li>
</ul>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>This software is Copyright (c) 2013 by Dave Rolsky.</p>

<p>This is free software, licensed under:</p>

<pre><code>  The Artistic License 2.0 (GPL Compatible)</code></pre>


</body>

</html>


