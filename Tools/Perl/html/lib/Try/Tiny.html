<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#EXPORTS">EXPORTS</a></li>
  <li><a href="#BACKGROUND">BACKGROUND</a>
    <ul>
      <li><a href="#Clobbering">Clobbering $@</a></li>
      <li><a href="#Localizing-silently-masks-errors">Localizing $@ silently masks errors</a></li>
      <li><a href="#might-not-be-a-true-value">$@ might not be a true value</a></li>
    </ul>
  </li>
  <li><a href="#SHINY-SYNTAX">SHINY SYNTAX</a></li>
  <li><a href="#CAVEATS">CAVEATS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#LIGHTNING-TALK">LIGHTNING TALK</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#CONTRIBUTORS">CONTRIBUTORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENCE">COPYRIGHT AND LICENCE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Try::Tiny - Minimal try/catch with proper preservation of $@</p>

<h1 id="VERSION">VERSION</h1>

<p>version 0.28</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>You can use Try::Tiny&#39;s <code>try</code> and <code>catch</code> to expect and handle exceptional conditions, avoiding quirks in Perl and common mistakes:</p>

<pre><code>  <span class="comment"># handle errors with a catch handler</span>
  <span class="variable">try</span> <span class="operator">{</span>
    <span class="keyword">die</span> <span class="string">"foo"</span><span class="operator">;</span>
  <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
    <span class="keyword">warn</span> <span class="string">"caught error: </span><span class="variable">$_</span><span class="string">"</span><span class="operator">;</span> <span class="comment"># not $@</span>
  <span class="operator">};</span>
</code></pre>

<p>You can also use it like a standalone <code>eval</code> to catch and ignore any error conditions. Obviously, this is an extreme measure not to be undertaken lightly:</p>

<pre><code>  <span class="comment"># just silence errors</span>
  <span class="variable">try</span> <span class="operator">{</span>
    <span class="keyword">die</span> <span class="string">"foo"</span><span class="operator">;</span>
  <span class="operator">};</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides bare bones <code>try</code>/<code>catch</code>/<code>finally</code> statements that are designed to minimize common mistakes with eval blocks, and NOTHING else.</p>

<p>This is unlike <a>TryCatch</a> which provides a nice syntax and avoids adding another call stack layer, and supports calling <code>return</code> from the <code>try</code> block to return from the parent subroutine. These extra features come at a cost of a few dependencies, namely <a>Devel::Declare</a> and <a>Scope::Upper</a> which are occasionally problematic, and the additional catch filtering uses <a href="../../lib/Moose.html">Moose</a> type constraints which may not be desirable either.</p>

<p>The main focus of this module is to provide simple and reliable error handling for those having a hard time installing <a>TryCatch</a>, but who still want to write correct <code>eval</code> blocks without 5 lines of boilerplate each time.</p>

<p>It&#39;s designed to work as correctly as possible in light of the various pathological edge cases (see <a href="#BACKGROUND">&quot;BACKGROUND&quot;</a>) and to be compatible with any style of error values (simple strings, references, objects, overloaded objects, etc).</p>

<p>If the <code>try</code> block dies, it returns the value of the last statement executed in the <code>catch</code> block, if there is one. Otherwise, it returns <code>undef</code> in scalar context or the empty list in list context. The following examples all assign <code>&quot;bar&quot;</code> to <code>$x</code>:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">try</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"foo"</span> <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span> <span class="string">"bar"</span> <span class="operator">};</span>
  <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">try</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"foo"</span> <span class="operator">}</span> <span class="operator">||</span> <span class="string">"bar"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">try</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"foo"</span> <span class="operator">})</span> <span class="operator">//</span> <span class="string">"bar"</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"foo"</span> <span class="operator">}</span> <span class="operator">||</span> <span class="string">"bar"</span><span class="operator">;</span>
</code></pre>

<p>You can add <code>finally</code> blocks, yielding the following:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$x</span><span class="operator">;</span>
  <span class="variable">try</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">'foo'</span> <span class="operator">}</span> <span class="variable">finally</span> <span class="operator">{</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="string">'bar'</span> <span class="operator">};</span>
  <span class="variable">try</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">'foo'</span> <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span> <span class="keyword">warn</span> <span class="string">"Got a die: </span><span class="variable">$_</span><span class="string">"</span> <span class="operator">}</span> <span class="variable">finally</span> <span class="operator">{</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="string">'bar'</span> <span class="operator">};</span>
</code></pre>

<p><code>finally</code> blocks are always executed making them suitable for cleanup code which cannot be handled using local. You can add as many <code>finally</code> blocks to a given <code>try</code> block as you like.</p>

<p>Note that adding a <code>finally</code> block without a preceding <code>catch</code> block suppresses any errors. This behaviour is consistent with using a standalone <code>eval</code>, but it is not consistent with <code>try</code>/<code>finally</code> patterns found in other programming languages, such as Java, Python, Javascript or C#. If you learnt the <code>try</code>/<code>finally</code> pattern from one of these languages, watch out for this.</p>

<h1 id="EXPORTS">EXPORTS</h1>

<p>All functions are exported by default using <a href="../../lib/Exporter.html">Exporter</a>.</p>

<p>If you need to rename the <code>try</code>, <code>catch</code> or <code>finally</code> keyword consider using <a>Sub::Import</a> to get <a href="../../lib/Sub/Exporter.html">Sub::Exporter</a>&#39;s flexibility.</p>

<dl>

<dt id="try">try (&amp;;@)</dt>
<dd>

<p>Takes one mandatory <code>try</code> subroutine, an optional <code>catch</code> subroutine and <code>finally</code> subroutine.</p>

<p>The mandatory subroutine is evaluated in the context of an <code>eval</code> block.</p>

<p>If no error occurred the value from the first block is returned, preserving list/scalar context.</p>

<p>If there was an error and the second subroutine was given it will be invoked with the error in <code>$_</code> (localized) and as that block&#39;s first and only argument.</p>

<p><code>$@</code> does <b>not</b> contain the error. Inside the <code>catch</code> block it has the same value it had before the <code>try</code> block was executed.</p>

<p>Note that the error may be false, but if that happens the <code>catch</code> block will still be invoked.</p>

<p>Once all execution is finished then the <code>finally</code> block, if given, will execute.</p>

</dd>
<dt id="catch">catch (&amp;;@)</dt>
<dd>

<p>Intended to be used in the second argument position of <code>try</code>.</p>

<p>Returns a reference to the subroutine it was given but blessed as <code>Try::Tiny::Catch</code> which allows try to decode correctly what to do with this code reference.</p>

<pre><code>  <span class="variable">catch</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</code></pre>

<p>Inside the <code>catch</code> block the caught error is stored in <code>$_</code>, while previous value of <code>$@</code> is still available for use. This value may or may not be meaningful depending on what happened before the <code>try</code>, but it might be a good idea to preserve it in an error stack.</p>

<p>For code that captures <code>$@</code> when throwing new errors (i.e. <a>Class::Throwable</a>), you&#39;ll need to do:</p>

<pre><code>  <span class="keyword">local</span> <span class="variable">$@</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">;</span>
</code></pre>

</dd>
<dt id="finally">finally (&amp;;@)</dt>
<dd>

<pre><code>  <span class="variable">try</span>     <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="variable">catch</span>   <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="variable">finally</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">};</span>
</code></pre>

<p>Or</p>

<pre><code>  <span class="variable">try</span>     <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="variable">finally</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">};</span>
</code></pre>

<p>Or even</p>

<pre><code>  <span class="variable">try</span>     <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="variable">finally</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="variable">catch</span>   <span class="operator">{</span> <span class="operator">...</span> <span class="operator">};</span>
</code></pre>

<p>Intended to be the second or third element of <code>try</code>. <code>finally</code> blocks are always executed in the event of a successful <code>try</code> or if <code>catch</code> is run. This allows you to locate cleanup code which cannot be done via <code>local()</code> e.g. closing a file handle.</p>

<p>When invoked, the <code>finally</code> block is passed the error that was caught. If no error was caught, it is passed nothing. (Note that the <code>finally</code> block does not localize <code>$_</code> with the error, since unlike in a <code>catch</code> block, there is no way to know if <code>$_ == undef</code> implies that there were no errors.) In other words, the following code does just what you would expect:</p>

<pre><code>  <span class="variable">try</span> <span class="operator">{</span>
    <span class="variable">die_sometimes</span><span class="operator">();</span>
  <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
    <span class="comment"># ...code run in case of error</span>
  <span class="operator">}</span> <span class="variable">finally</span> <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"The try block died with: </span><span class="variable">@_</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"The try block ran without error.\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">};</span>
</code></pre>

<p><b>You must always do your own error handling in the <code>finally</code> block</b>. <code>Try::Tiny</code> will not do anything about handling possible errors coming from code located in these blocks.</p>

<p>Furthermore <b>exceptions in <code>finally</code> blocks are not trappable and are unable to influence the execution of your program</b>. This is due to limitation of <code>DESTROY</code>-based scope guards, which <code>finally</code> is implemented on top of. This may change in a future version of Try::Tiny.</p>

<p>In the same way <code>catch()</code> blesses the code reference this subroutine does the same except it bless them as <code>Try::Tiny::Finally</code>.</p>

</dd>
</dl>

<h1 id="BACKGROUND">BACKGROUND</h1>

<p>There are a number of issues with <code>eval</code>.</p>

<h2 id="Clobbering">Clobbering $@</h2>

<p>When you run an <code>eval</code> block and it succeeds, <code>$@</code> will be cleared, potentially clobbering an error that is currently being caught.</p>

<p>This causes action at a distance, clearing previous errors your caller may have not yet handled.</p>

<p><code>$@</code> must be properly localized before invoking <code>eval</code> in order to avoid this issue.</p>

<p>More specifically, <code>$@</code> is clobbered at the beginning of the <code>eval</code>, which also makes it impossible to capture the previous error before you die (for instance when making exception objects with error stacks).</p>

<p>For this reason <code>try</code> will actually set <code>$@</code> to its previous value (the one available before entering the <code>try</code> block) in the beginning of the <code>eval</code> block.</p>

<h2 id="Localizing-silently-masks-errors">Localizing $@ silently masks errors</h2>

<p>Inside an <code>eval</code> block, <code>die</code> behaves sort of like:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> die </span><span class="operator">{</span>
    <span class="variable">$@</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="variable">return_undef_from_eval</span><span class="operator">();</span>
  <span class="operator">}</span>
</code></pre>

<p>This means that if you were polite and localized <code>$@</code> you can&#39;t die in that scope, or your error will be discarded (printing &quot;Something&#39;s wrong&quot; instead).</p>

<p>The workaround is very ugly:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$error</span> <span class="operator">=</span> <span class="keyword">do</span> <span class="operator">{</span>
    <span class="keyword">local</span> <span class="variable">$@</span><span class="operator">;</span>
    <span class="keyword">eval</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">};</span>
    <span class="variable">$@</span><span class="operator">;</span>
  <span class="operator">};</span>
  
  <span class="operator">...</span>
  <span class="keyword">die</span> <span class="variable">$error</span><span class="operator">;</span>
</code></pre>

<h2 id="might-not-be-a-true-value">$@ might not be a true value</h2>

<p>This code is wrong:</p>

<pre><code>  <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$@</span> <span class="operator">)</span> <span class="operator">{</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
</code></pre>

<p>because due to the previous caveats it may have been unset.</p>

<p><code>$@</code> could also be an overloaded error object that evaluates to false, but that&#39;s asking for trouble anyway.</p>

<p>The classic failure mode is:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> Object::DESTROY </span><span class="operator">{</span>
    <span class="keyword">eval</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
  <span class="operator">}</span>
  
  <span class="keyword">eval</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$obj</span> <span class="operator">=</span> <span class="variable">Object</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
    <span class="keyword">die</span> <span class="string">"foo"</span><span class="operator">;</span>
  <span class="operator">};</span>
  
  <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$@</span> <span class="operator">)</span> <span class="operator">{</span>
  
  <span class="operator">}</span>
</code></pre>

<p>In this case since <code>Object::DESTROY</code> is not localizing <code>$@</code> but still uses <code>eval</code>, it will set <code>$@</code> to <code>&quot;&quot;</code>.</p>

<p>The destructor is called when the stack is unwound, after <code>die</code> sets <code>$@</code> to <code>&quot;foo at Foo.pm line 42\n&quot;</code>, so by the time <code>if ( $@ )</code> is evaluated it has been cleared by <code>eval</code> in the destructor.</p>

<p>The workaround for this is even uglier than the previous ones. Even though we can&#39;t save the value of <code>$@</code> from code that doesn&#39;t localize, we can at least be sure the <code>eval</code> was aborted due to an error:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$failed</span> <span class="operator">=</span> <span class="keyword">not</span> <span class="keyword">eval</span> <span class="operator">{</span>
    <span class="operator">...</span>
  
    <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">};</span>
</code></pre>

<p>This is because an <code>eval</code> that caught a <code>die</code> will always return a false value.</p>

<h1 id="SHINY-SYNTAX">SHINY SYNTAX</h1>

<p>Using Perl 5.10 you can use <a href="../../lib/pods/perlsyn.html#Switch-statements">&quot;Switch statements&quot; in perlsyn</a>.</p>

<p>The <code>catch</code> block is invoked in a topicalizer context (like a <code>given</code> block), but note that you can&#39;t return a useful value from <code>catch</code> using the <code>when</code> blocks without an explicit <code>return</code>.</p>

<p>This is somewhat similar to Perl 6&#39;s <code>CATCH</code> blocks. You can use it to concisely match errors:</p>

<pre><code>  <span class="variable">try</span> <span class="operator">{</span>
    <span class="keyword">require</span> <span class="variable">Foo</span><span class="operator">;</span>
  <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
    <span class="keyword">when</span> <span class="operator">(</span><span class="regex">/^Can't locate .*?\.pm in \@INC/</span><span class="operator">)</span> <span class="operator">{</span> <span class="operator">}</span> <span class="comment"># ignore</span>
    <span class="keyword">default</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="variable">$_</span> <span class="operator">}</span>
  <span class="operator">};</span>
</code></pre>

<h1 id="CAVEATS">CAVEATS</h1>

<ul>

<li><p><code>@_</code> is not available within the <code>try</code> block, so you need to copy your argument list. In case you want to work with argument values directly via <code>@_</code> aliasing (i.e. allow <code>$_[1] = &quot;foo&quot;</code>), you need to pass <code>@_</code> by reference:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> foo </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">@args</span> <span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="variable">try</span> <span class="operator">{</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">bar</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">)</span> <span class="operator">}</span>
  <span class="operator">}</span>
</code></pre>

<p>or</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> bar_in_place </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$args</span> <span class="operator">=</span> <span class="operator">\</span><span class="variable">@_</span><span class="operator">;</span>
    <span class="variable">try</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">bar</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="variable">@$args</span> <span class="operator">}</span>
  <span class="operator">}</span>
</code></pre>

</li>
<li><p><code>return</code> returns from the <code>try</code> block, not from the parent sub (note that this is also how <code>eval</code> works, but not how <a>TryCatch</a> works):</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> parent_sub </span><span class="operator">{</span>
    <span class="variable">try</span> <span class="operator">{</span>
      <span class="keyword">die</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">catch</span> <span class="operator">{</span>
      <span class="keyword">return</span><span class="operator">;</span>
    <span class="operator">};</span>
  
    <span class="keyword">say</span> <span class="string">"this text WILL be displayed, even though an exception is thrown"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></pre>

<p>Instead, you should capture the return value:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> parent_sub </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">try</span> <span class="operator">{</span>
      <span class="keyword">die</span><span class="operator">;</span>
      <span class="number">1</span><span class="operator">;</span>
    <span class="operator">};</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> <span class="variable">$success</span><span class="operator">;</span>
  
    <span class="keyword">say</span> <span class="string">"This text WILL NEVER appear!"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="comment"># OR</span>
  <span class="keyword">sub</span><span class="variable"> parent_sub_with_catch </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$success</span> <span class="operator">=</span> <span class="variable">try</span> <span class="operator">{</span>
      <span class="keyword">die</span><span class="operator">;</span>
      <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">catch</span> <span class="operator">{</span>
      <span class="comment"># do something with $_</span>
      <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span> <span class="comment">#see note</span>
    <span class="operator">};</span>
    <span class="keyword">return</span> <span class="keyword">unless</span> <span class="variable">$success</span><span class="operator">;</span>
  
    <span class="keyword">say</span> <span class="string">"This text WILL NEVER appear!"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></pre>

<p>Note that if you have a <code>catch</code> block, it must return <code>undef</code> for this to work, since if a <code>catch</code> block exists, its return value is returned in place of <code>undef</code> when an exception is thrown.</p>

</li>
<li><p><code>try</code> introduces another caller stack frame. <a href="../../lib/Sub/Uplevel.html">Sub::Uplevel</a> is not used. <a href="../../lib/Carp.html">Carp</a> will not report this when using full stack traces, though, because <code>%Carp::Internal</code> is used. This lack of magic is considered a feature.</p>

</li>
<li><p>The value of <code>$_</code> in the <code>catch</code> block is not guaranteed to be the value of the exception thrown (<code>$@</code>) in the <code>try</code> block. There is no safe way to ensure this, since <code>eval</code> may be used unhygienically in destructors. The only guarantee is that the <code>catch</code> will be called if an exception is thrown.</p>

</li>
<li><p>The return value of the <code>catch</code> block is not ignored, so if testing the result of the expression for truth on success, be sure to return a false value from the <code>catch</code> block:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$obj</span> <span class="operator">=</span> <span class="variable">try</span> <span class="operator">{</span>
    <span class="variable">MightFail</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
    <span class="operator">...</span>
  
    <span class="keyword">return</span><span class="operator">;</span> <span class="comment"># avoid returning a true value;</span>
  <span class="operator">};</span>
  
  <span class="keyword">return</span> <span class="keyword">unless</span> <span class="variable">$obj</span><span class="operator">;</span>
</code></pre>

</li>
<li><p><code><span class="variable">$SIG</span><span class="operator">{</span><span class="string">__DIE__</span><span class="operator">}</span>
</code> is still in effect.</p>

<p>Though it can be argued that <code><span class="variable">$SIG</span><span class="operator">{</span><span class="string">__DIE__</span><span class="operator">}</span>
</code> should be disabled inside of <code>eval</code> blocks, since it isn&#39;t people have grown to rely on it. Therefore in the interests of compatibility, <code>try</code> does not disable <code><span class="variable">$SIG</span><span class="operator">{</span><span class="string">__DIE__</span><span class="operator">}</span>
</code> for the scope of the error throwing code.</p>

</li>
<li><p>Lexical <code>$_</code> may override the one set by <code>catch</code>.</p>

<p>For example Perl 5.10&#39;s <code>given</code> form uses a lexical <code>$_</code>, creating some confusing behavior:</p>

<pre><code>  <span class="keyword">given</span> <span class="operator">(</span><span class="variable">$foo</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">when</span> <span class="operator">(...)</span> <span class="operator">{</span>
      <span class="variable">try</span> <span class="operator">{</span>
        <span class="operator">...</span>
      <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
        <span class="keyword">warn</span> <span class="variable">$_</span><span class="operator">;</span> <span class="comment"># will print $foo, not the error</span>
        <span class="keyword">warn</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span> <span class="comment"># instead, get the error like this</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</code></pre>

<p>Note that this behavior was changed once again in <a href="https://metacpan.org/module/perldelta#given-now-aliases-the-global-_">Perl5 version 18 </a>. However, since the entirety of lexical <code>$_</code> is now <a href="https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental">considered experimental </a>, it is unclear whether the new version 18 behavior is final.</p>

</li>
</ul>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<dl>

<dt id="TryCatch"><a>TryCatch</a></dt>
<dd>

<p>Much more feature complete, more convenient semantics, but at the cost of implementation complexity.</p>

</dd>
<dt id="autodie"><a href="../../lib/autodie.html">autodie</a></dt>
<dd>

<p>Automatic error throwing for builtin functions and more. Also designed to work well with <code>given</code>/<code>when</code>.</p>

</dd>
<dt id="Throwable"><a>Throwable</a></dt>
<dd>

<p>A lightweight role for rolling your own exception classes.</p>

</dd>
<dt id="Error"><a href="../../lib/GD/Graph/Error.html">Error</a></dt>
<dd>

<p>Exception object implementation with a <code>try</code> statement. Does not localize <code>$@</code>.</p>

</dd>
<dt id="Exception::Class::TryCatch"><a>Exception::Class::TryCatch</a></dt>
<dd>

<p>Provides a <code>catch</code> statement, but properly calling <code>eval</code> is your responsibility.</p>

<p>The <code>try</code> keyword pushes <code>$@</code> onto an error stack, avoiding some of the issues with <code>$@</code>, but you still need to localize to prevent clobbering.</p>

</dd>
</dl>

<h1 id="LIGHTNING-TALK">LIGHTNING TALK</h1>

<p>I gave a lightning talk about this module, you can see the slides (Firefox only):</p>

<p><a href="http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul">http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul</a></p>

<p>Or read the source:</p>

<p><a href="http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml">http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml</a></p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>Bugs may be submitted through <a href="https://rt.cpan.org/Public/Dist/Display.html?Name=Try-Tiny">the RT bug tracker</a> (or <a href="mailto:bug-Try-Tiny@rt.cpan.org">bug-Try-Tiny@rt.cpan.org</a>).</p>

<h1 id="AUTHORS">AUTHORS</h1>

<ul>

<li><p>&#x5D9;&#x5D5;&#x5D1;&#x5DC; &#x5E7;&#x5D5;&#x5D2;&#39;&#x5DE;&#x5DF; (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</p>

</li>
<li><p>Jesse Luehrs &lt;doy@tozt.net&gt;</p>

</li>
</ul>

<h1 id="CONTRIBUTORS">CONTRIBUTORS</h1>

<ul>

<li><p>Karen Etheridge &lt;ether@cpan.org&gt;</p>

</li>
<li><p>Peter Rabbitson &lt;ribasushi@cpan.org&gt;</p>

</li>
<li><p>Ricardo Signes &lt;rjbs@cpan.org&gt;</p>

</li>
<li><p>Mark Fowler &lt;mark@twoshortplanks.com&gt;</p>

</li>
<li><p>Graham Knop &lt;haarg@haarg.org&gt;</p>

</li>
<li><p>Lukas Mai &lt;l.mai@web.de&gt;</p>

</li>
<li><p>Dagfinn Ilmari Manns&aring;ker &lt;ilmari@ilmari.org&gt;</p>

</li>
<li><p>Paul Howarth &lt;paul@city-fan.org&gt;</p>

</li>
<li><p>Rudolf Leermakers &lt;rudolf@hatsuseno.org&gt;</p>

</li>
<li><p>anaxagoras &lt;walkeraj@gmail.com&gt;</p>

</li>
<li><p>awalker &lt;awalker@sourcefire.com&gt;</p>

</li>
<li><p>chromatic &lt;chromatic@wgz.org&gt;</p>

</li>
<li><p>Alex &lt;alex@koban.(none)&gt;</p>

</li>
<li><p>cm-perl &lt;cm-perl@users.noreply.github.com&gt;</p>

</li>
<li><p>Andrew Yates &lt;ayates@haddock.local&gt;</p>

</li>
<li><p>David Lowe &lt;davidl@lokku.com&gt;</p>

</li>
<li><p>Glenn Fowler &lt;cebjyre@cpan.org&gt;</p>

</li>
<li><p>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</p>

</li>
<li><p>Jonathan Yu &lt;JAWNSY@cpan.org&gt;</p>

</li>
<li><p>Marc Mims &lt;marc@questright.com&gt;</p>

</li>
<li><p>Mark Stosberg &lt;mark@stosberg.com&gt;</p>

</li>
<li><p>Pali &lt;pali@cpan.org&gt;</p>

</li>
</ul>

<h1 id="COPYRIGHT-AND-LICENCE">COPYRIGHT AND LICENCE</h1>

<p>This software is Copyright (c) 2009 by &#x5D9;&#x5D5;&#x5D1;&#x5DC; &#x5E7;&#x5D5;&#x5D2;&#39;&#x5DE;&#x5DF; (Yuval Kogman).</p>

<p>This is free software, licensed under:</p>

<pre><code>  The MIT (X11) License</code></pre>


</body>

</html>


