<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#is_prob_prime">is_prob_prime</a></li>
      <li><a href="#is_prime">is_prime</a></li>
      <li><a href="#is_provable_prime">is_provable_prime</a></li>
      <li><a href="#is_provable_prime_with_cert">is_provable_prime_with_cert</a></li>
      <li><a href="#is_pseudoprime">is_pseudoprime</a></li>
      <li><a href="#is_euler_pseudoprime">is_euler_pseudoprime</a></li>
      <li><a href="#is_strong_pseudoprime">is_strong_pseudoprime</a></li>
      <li><a href="#miller_rabin_random">miller_rabin_random</a></li>
      <li><a href="#is_lucas_pseudoprime">is_lucas_pseudoprime</a></li>
      <li><a href="#is_strong_lucas_pseudoprime">is_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_extra_strong_lucas_pseudoprime">is_extra_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_almost_extra_strong_lucas_pseudoprime">is_almost_extra_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_euler_plumb_pseudoprime">is_euler_plumb_pseudoprime</a></li>
      <li><a href="#is_perrin_pseudoprime">is_perrin_pseudoprime</a></li>
      <li><a href="#is_frobenius_pseudoprime">is_frobenius_pseudoprime</a></li>
      <li><a href="#is_frobenius_underwood_pseudoprime">is_frobenius_underwood_pseudoprime</a></li>
      <li><a href="#is_frobenius_khashin_pseudoprime">is_frobenius_khashin_pseudoprime</a></li>
      <li><a href="#is_bpsw_prime">is_bpsw_prime</a></li>
      <li><a href="#is_aks_prime">is_aks_prime</a></li>
      <li><a href="#is_mersenne_prime">is_mersenne_prime</a></li>
      <li><a href="#is_llr_prime">is_llr_prime</a></li>
      <li><a href="#is_proth_prime">is_proth_prime</a></li>
      <li><a href="#is_miller_prime">is_miller_prime</a></li>
      <li><a href="#is_nminus1_prime">is_nminus1_prime</a></li>
      <li><a href="#is_nplus1_prime">is_nplus1_prime</a></li>
      <li><a href="#is_bls75_prime">is_bls75_prime</a></li>
      <li><a href="#is_ecpp_prime">is_ecpp_prime</a></li>
      <li><a href="#primes">primes</a></li>
      <li><a href="#sieve_primes">sieve_primes</a></li>
      <li><a href="#sieve_range">sieve_range</a></li>
      <li><a href="#sieve_twin_primes">sieve_twin_primes</a></li>
      <li><a href="#sieve_prime_cluster">sieve_prime_cluster</a></li>
      <li><a href="#next_prime">next_prime</a></li>
      <li><a href="#prev_prime">prev_prime</a></li>
      <li><a href="#surround_primes">surround_primes</a></li>
      <li><a href="#random_nbit_prime">random_nbit_prime</a></li>
      <li><a href="#random_strong_prime">random_strong_prime</a></li>
      <li><a href="#random_ndigit_prime">random_ndigit_prime</a></li>
      <li><a href="#random_prime">random_prime</a></li>
      <li><a href="#random_maurer_prime">random_maurer_prime</a></li>
      <li><a href="#random_shawe_taylor_prime">random_shawe_taylor_prime</a></li>
      <li><a href="#random_maurer_prime_with_cert">random_maurer_prime_with_cert</a></li>
      <li><a href="#random_shawe_taylor_prime_with_cert">random_shawe_taylor_prime_with_cert</a></li>
      <li><a href="#lucasu">lucasu</a></li>
      <li><a href="#lucasv">lucasv</a></li>
      <li><a href="#lucas_sequence">lucas_sequence</a></li>
      <li><a href="#primorial">primorial</a></li>
      <li><a href="#pn_primorial">pn_primorial</a></li>
      <li><a href="#factorial">factorial</a></li>
      <li><a href="#factorialmod">factorialmod</a></li>
      <li><a href="#gcd">gcd</a></li>
      <li><a href="#lcm">lcm</a></li>
      <li><a href="#gcdext">gcdext</a></li>
      <li><a href="#chinese">chinese</a></li>
      <li><a href="#vecsum">vecsum</a></li>
      <li><a href="#vecprod">vecprod</a></li>
      <li><a href="#kronecker">kronecker</a></li>
      <li><a href="#binomial">binomial</a></li>
      <li><a href="#bernfrac">bernfrac</a></li>
      <li><a href="#bernreal">bernreal</a></li>
      <li><a href="#harmfrac">harmfrac</a></li>
      <li><a href="#harmreal">harmreal</a></li>
      <li><a href="#stirling">stirling</a></li>
      <li><a href="#zeta">zeta</a></li>
      <li><a href="#riemannr">riemannr</a></li>
      <li><a href="#lambertw">lambertw</a></li>
      <li><a href="#znorder">znorder</a></li>
      <li><a href="#znprimroot">znprimroot</a></li>
      <li><a href="#is_primitive_root">is_primitive_root</a></li>
      <li><a href="#is_semiprime">is_semiprime</a></li>
      <li><a href="#is_carmichael">is_carmichael</a></li>
      <li><a href="#is_fundamental">is_fundamental</a></li>
      <li><a href="#is_totient">is_totient</a></li>
      <li><a href="#is_polygonal">is_polygonal</a></li>
      <li><a href="#polygonal_nth">polygonal_nth</a></li>
      <li><a href="#sigma">sigma</a></li>
      <li><a href="#ramanujan_tau">ramanujan_tau</a></li>
      <li><a href="#valuation">valuation</a></li>
      <li><a href="#hammingweight">hammingweight</a></li>
      <li><a href="#moebius">moebius</a></li>
      <li><a href="#invmod">invmod</a></li>
      <li><a href="#sqrtmod">sqrtmod</a></li>
      <li><a href="#addmod">addmod</a></li>
      <li><a href="#mulmod">mulmod</a></li>
      <li><a href="#powmod">powmod</a></li>
      <li><a href="#divmod">divmod</a></li>
      <li><a href="#consecutive_integer_lcm">consecutive_integer_lcm</a></li>
      <li><a href="#partitions">partitions</a></li>
      <li><a href="#numtoperm">numtoperm</a></li>
      <li><a href="#permtonum">permtonum</a></li>
      <li><a href="#Pi">Pi</a></li>
      <li><a href="#exp_mangoldt">exp_mangoldt</a></li>
      <li><a href="#totient">totient</a></li>
      <li><a href="#jordan_totient">jordan_totient</a></li>
      <li><a href="#carmichael_lambda">carmichael_lambda</a></li>
      <li><a href="#liouville">liouville</a></li>
      <li><a href="#is_power">is_power</a></li>
      <li><a href="#is_square">is_square</a></li>
      <li><a href="#is_prime_power">is_prime_power</a></li>
      <li><a href="#sqrtint">sqrtint</a></li>
      <li><a href="#rootint">rootint</a></li>
      <li><a href="#logint">logint</a></li>
      <li><a href="#factor">factor</a></li>
      <li><a href="#divisors">divisors</a></li>
      <li><a href="#trial_factor">trial_factor</a></li>
      <li><a href="#prho_factor">prho_factor</a></li>
      <li><a href="#pbrent_factor">pbrent_factor</a></li>
      <li><a href="#pminus1_factor">pminus1_factor</a></li>
      <li><a href="#pplus1_factor">pplus1_factor</a></li>
      <li><a href="#holf_factor">holf_factor</a></li>
      <li><a href="#squfof_factor">squfof_factor</a></li>
      <li><a href="#ecm_factor">ecm_factor</a></li>
      <li><a href="#qs_factor">qs_factor</a></li>
      <li><a href="#todigits">todigits</a></li>
      <li><a href="#seed_csprng">seed_csprng</a></li>
      <li><a href="#is_csprng_well_seeded">is_csprng_well_seeded</a></li>
      <li><a href="#urandomb">urandomb</a></li>
      <li><a href="#urandomm">urandomm</a></li>
      <li><a href="#urandomr">urandomr</a></li>
      <li><a href="#irand">irand</a></li>
      <li><a href="#irand64">irand64</a></li>
      <li><a href="#drand">drand</a></li>
      <li><a href="#random_bytes">random_bytes</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#REFERENCES">REFERENCES</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Math::Prime::Util::GMP - Utilities related to prime numbers and factoring, using GMP</p>

<h1 id="VERSION">VERSION</h1>

<p>Version 0.48</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util::GMP</span> <span class="string">':all'</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="string">"115792089237316195423570985008687907853269984665640564039457584007913129639937"</span><span class="operator">;</span>
  
  <span class="comment"># This doesn't impact the operation of the module at all, but does let you</span>
  <span class="comment"># enter big number arguments directly as well as enter (e.g.): 2**2048 + 1.</span>
  <span class="keyword">use</span> <span class="variable">bigint</span><span class="operator">;</span>
  
  <span class="comment"># These return 0 for composite, 2 for prime, and 1 for probably prime</span>
  <span class="comment"># Numbers under 2^64 will return 0 or 2.</span>
  <span class="comment"># is_prob_prime does a BPSW primality test for numbers &gt; 2^64</span>
  <span class="comment"># is_prime adds some MR tests and a quick test to try to prove the result</span>
  <span class="comment"># is_provable_prime will spend a lot of effort on proving primality</span>
  
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is probably prime"</span>    <span class="keyword">if</span> <span class="variable">is_prob_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is "</span><span class="operator">,</span> <span class="string">qw(composite prob_prime def_prime)</span><span class="operator">[</span><span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span><span class="operator">]</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span>  <span class="keyword">if</span> <span class="variable">is_provable_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">2</span><span class="operator">;</span>
  
  <span class="comment"># Miller-Rabin and strong Lucas-Selfridge pseudoprime tests</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or spsp-2/7/61"</span> <span class="keyword">if</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">61</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or slpsp"</span>       <span class="keyword">if</span> <span class="variable">is_strong_lucas_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or eslpsp"</span>      <span class="keyword">if</span> <span class="variable">is_extra_strong_lucas_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  <span class="comment"># Return array reference to primes in a range.</span>
  <span class="keyword">my</span> <span class="variable">$aref</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">10</span> <span class="operator">**</span> <span class="number">200</span><span class="operator">,</span> <span class="number">10</span> <span class="operator">**</span> <span class="number">200</span> <span class="operator">+</span> <span class="number">10000</span> <span class="operator">);</span>
  
  <span class="variable">$next</span> <span class="operator">=</span> <span class="variable">next_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>    <span class="comment"># next prime &gt; n</span>
  <span class="variable">$prev</span> <span class="operator">=</span> <span class="variable">prev_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>    <span class="comment"># previous prime &lt; n</span>
  
  <span class="comment"># Primorials and lcm</span>
  <span class="keyword">say</span> <span class="string">"23# is "</span><span class="operator">,</span> <span class="variable">primorial</span><span class="operator">(</span><span class="number">23</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"The product of the first 47 primes is "</span><span class="operator">,</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="number">47</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"lcm(1..1000) is "</span><span class="operator">,</span> <span class="variable">consecutive_integer_lcm</span><span class="operator">(</span><span class="number">1000</span><span class="operator">);</span>
  
  
  <span class="comment"># Find prime factors of big numbers</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">factor</span><span class="operator">(</span><span class="number">5465610891074107968111136514192945634873647594456118359804135903459867604844945580205745718497</span><span class="operator">);</span>
  
  <span class="comment"># Finer control over factoring.</span>
  <span class="comment"># These stop after finding one factor or exceeding their limit.</span>
  <span class="comment">#                               # optional arguments o1, o2, ...</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">trial_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>    <span class="comment"># test up to o1</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">prho_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>     <span class="comment"># no more than o1 rounds</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pbrent_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>   <span class="comment"># no more than o1 rounds</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">holf_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>     <span class="comment"># no more than o1 rounds</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">squfof_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>   <span class="comment"># no more than o1 rounds</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>  <span class="comment"># o1 = smoothness limit, o2 = stage 2 limit</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>      <span class="comment"># o1 = B1, o2 = # of curves</span>
  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">qs_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>       <span class="comment"># (no arguments)</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>A module for number theory in Perl using GMP. This includes primality tests, getting primes in a range, factoring, and more.</p>

<p>While it certainly can be used directly, the main purpose of this module is for <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a>. That module will automatically load this one if it is installed, greatly speeding up many of its operations on big numbers.</p>

<p>Inputs and outputs for big numbers are via strings, so you do not need to use a bigint package in your program. However if you do use bigints, inputs will be converted internally so there is no need to convert before a call. Output results are returned as either Perl scalars (for native-size) or strings (for bigints). <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> tries to reconvert all strings back into the callers bigint type if possible, which makes it more convenient for calculations.</p>

<p>The various <code>is_*_pseudoprime</code> tests are more appropriately called <code>is_*_probable_prime</code> or <code>is_*_prp</code>. They return 1 if the input is a probable prime based on their test. The naming convention is historical and follows Pari, <a>Math::Primality</a>, and some other math packages. The modern definition of pseudoprime is a <i>composite</i> that passes the test, rather than any number.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="is_prob_prime">is_prob_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$prob_prime</span> <span class="operator">=</span> <span class="variable">is_prob_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="comment"># Returns 0 (composite), 2 (prime), or 1 (probably prime)</span>
</code></pre>

<p>Takes a positive number as input and returns back either 0 (composite), 2 (definitely prime), or 1 (probably prime).</p>

<p>For inputs below <code>2^64</code> the test is deterministic, so the possible return values are 0 (composite) or 2 (definitely prime).</p>

<p>For inputs above <code>2^64</code>, a probabilistic test is performed. Only 0 (composite) and 1 (probably prime) are returned. The current implementation uses the Baillie-PSW (BPSW) test. There is a possibility that composites may be returned marked prime, but since the test was published in 1980, not a single BPSW pseudoprime has been found, so it is extremely likely to be prime. While we believe (Pomerance 1984) that an infinite number of counterexamples exist, there is a weak conjecture (Martin) that none exist under 10000 digits.</p>

<p>In more detail, we are using the extra-strong Lucas test (Grantham 2000) using the Baillie parameter selection method (see OEIS A217719). Previous versions of this module used the strong Lucas test with Selfridge parameters, but the extra-strong version produces fewer pseudoprimes while running 1.2 - 1.5x faster. It is slightly stronger than the test used in <a href="http://pari.math.u-bordeaux.fr/faq.html#primetest">Pari</a>.</p>

<h2 id="is_prime">is_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is prime!"</span> <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number as input and returns back either 0 (composite), 2 (definitely prime), or 1 (probably prime). Composites will act exactly like <code>is_prob_prime</code>, as will numbers less than <code>2^64</code>. For numbers larger than <code>2^64</code>, some additional tests are performed on probable primes to see if they can be proven by another means.</p>

<p>This call walks the line between the performance of <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> and the certainty of <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a>. Those calls may be more appropriate in some cases. What this function does is give most of the performance of the former, while adding more certainty. For finer tuning of this tradeoff, you may instead use <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> followed by additional probable prime tests such as <a href="#miller_rabin_random">&quot;miller_rabin_random&quot;</a> and/or <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a>.</p>

<p>As with <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a>, a BPSW test is first performed. This is deterministic for all 64-bit numbers. Next, if the number is a Proth or LLR form, then a proof is constructed. If the result is still &quot;probably prime&quot; and the input is smaller than the Sorenson/Webster (2015) deterministic Miller-Rabin limit (approximately 82 bits) then the 11 or 12 Miller-Rabin tests are performed and the result is confirmed. For larger inputs that are still &quot;probably prime&quot; but under 200 bits, a quick BLS75 <code>n-1</code> primality proof is attempted. This is tuned to give up if the result cannot be quickly determined, and results in success rates of ~80% at 80 bits, ~30% at 128 bits, and ~13% at 160 bits. Lastly, for results still &quot;probably prime&quot;, an additional random-base Miller-Rabin test is performed.</p>

<p>The result is that many numbers will return 2 (definitely prime), and the numbers that return 1 (probably prime) have gone through more tests than <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> while not taking too long.</p>

<p>For cryptographic key generation, you may want even more testing for probable primes (NIST recommends a few more additional M-R tests than we perform). The function <a href="#miller_rabin_random">&quot;miller_rabin_random&quot;</a> is made for this. Alternately, a different test such as <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a> can be used. Even better, use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> which should be reasonably fast for sizes under 2048 bits. Typically for key generation one wants random primes, and there are many functions for that.</p>

<h2 id="is_provable_prime">is_provable_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime!"</span> <span class="keyword">if</span> <span class="variable">is_provable_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">2</span><span class="operator">;</span>
</code></pre>

<p>Takes a positive number as input and returns back either 0 (composite), 2 (definitely prime), or 1 (probably prime). A great deal of effort is taken to return either 0 or 2 for all numbers.</p>

<p>The current method first uses BPSW to find composites and provide a deterministic answer for tiny numbers (under <code>2^64</code>). If no certificate is required, LLR and Proth tests can be run, and small numbers (under approximately <code>2^82</code>) can be satisfied with a deterministic Miller-Rabin test. If the result is still not determined, a quick BLS75 <code>n-1</code> test is attempted, followed by ECPP.</p>

<p>The time required for primes of different input sizes on a circa-2009 workstation averages about <code>3ms</code> for 30-digits, <code>5ms</code> for 40-digit, <code>20ms</code> for 60-digit, <code>50ms</code> for 80-digit, <code>100ms</code> for 100-digit, <code>2s</code> for 200-digit, and 400-digit inputs about a minute. Expect a lot of time variation for larger inputs. You can see progress indication if verbose is turned on (some at level 1, and a lot at level 2).</p>

<p>A certificate can be obtained along with the result using the <a href="#is_provable_prime_with_cert">&quot;is_provable_prime_with_cert&quot;</a> method. There is no appreciable extra performance cost for returning a certificate.</p>

<h2 id="is_provable_prime_with_cert">is_provable_prime_with_cert</h2>

<p>Takes a positive number as input and returns back an array with two elements. The result will be one of:</p>

<pre><code>  (0, &#39;&#39;)      The input is composite.

  (1, &#39;&#39;)      The input is probably prime but we could not prove it.
               This is a failure in our ability to factor some necessary
               element in a reasonable time, not a significant proof
               failure (in other words, it remains a probable prime).

  (2, &#39;...&#39;)   The input is prime, and the certificate contains all the
               information necessary to verify this.</code></pre>

<p>The certificate is a text representation containing all the necessary information to verify the primality of the input in a reasonable time. The result can be used with <a href="../../../../lib/Math/Prime/Util.html#verify_prime">&quot;verify_prime&quot; in Math::Prime::Util</a> for verification. Proof types used include:</p>

<pre><code>  ECPP
  BLS3
  BLS15
  BLS5
  Small</code></pre>

<h2 id="is_pseudoprime">is_pseudoprime</h2>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is a probable prime to each base, <code>0</code> if not. This is the simple Fermat primality test. Removing primes, given base 2 this produces the sequence <a href="http://oeis.org/A001567">OEIS A001567</a>.</p>

<h2 id="is_euler_pseudoprime">is_euler_pseudoprime</h2>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is an Euler probable prime to each base, <code>0</code> if not. This is the Euler test, sometimes called the Euler-Jacobi test. Removing primes, given base 2 this produces the sequence <a href="http://oeis.org/A047713">OEIS A047713</a>.</p>

<h2 id="is_strong_pseudoprime">is_strong_pseudoprime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$maybe_prime</span> <span class="operator">=</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$probably_prime</span> <span class="operator">=</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">11</span><span class="operator">,</span> <span class="number">13</span><span class="operator">,</span> <span class="number">17</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is a strong probable prime to each base, <code>0</code> if not. This is often called the Miller-Rabin test.</p>

<p>If 0 is returned, then the number really is a composite. If 1 is returned, then it is either a prime or a strong pseudoprime to all the given bases. Given enough distinct bases, the chances become very strong that the number is actually prime.</p>

<p>Both the input number and the bases may be big integers. If base modulo n &lt;= 1 or base modulo n = n-1, then the result will be 1. This allows the bases to be larger than n if desired, while still returning meaningful results. For example,</p>

<pre><code>  is_strong_pseudoprime(367, 1101)</code></pre>

<p>would incorrectly return 0 if this was not done properly. A 0 result should be returned only if n is composite, regardless of the base.</p>

<p>This is usually used in combination with other tests to make either stronger tests (e.g. the strong BPSW test) or deterministic results for numbers less than some verified limit (e.g. Jaeschke showed in 1993 that no more than three selected bases are required to give correct primality test results for any 32-bit number). Given the small chances of passing multiple bases, there are some math packages that just use multiple MR tests for primality testing, though in the early 1990s almost all serious software switched to the BPSW test.</p>

<p>Even numbers other than 2 will always return 0 (composite). While the algorithm works with even input, most sources define it only on odd input. Returning composite for all non-2 even input makes the function match most other implementations including <a>Math::Primality</a>&#39;s <code>is_strong_pseudoprime</code> function.</p>

<h2 id="miller_rabin_random">miller_rabin_random</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$maybe_prime</span> <span class="operator">=</span> <span class="variable">miller_rabin_random</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">10</span><span class="operator">);</span> <span class="comment"># 10 random bases</span>
</code></pre>

<p>Takes a positive number (<code>n</code>) as input and a positive number (<code>k</code>) of bases to use. Performs <code>k</code> Miller-Rabin tests using uniform random bases between 2 and <code>n-2</code>. This is the correct way to perform <code>k</code> Miller-Rabin tests, rather than the common but broken method of using the first <code>k</code> primes.</p>

<p>An optional third argument may be given, which is a seed to use. The seed should be a number either in decimal, binary with a leading <code>0b</code>, hex with a leading <code>0x</code>, or octal with a leading <code>0</code>. It will be converted to a GMP integer, so may be large. Typically this is not necessary, but cryptographic applications may prefer the ability to use this, and it allows repeatable test results.</p>

<p>There is no check for duplicate bases. Input sizes below 65 bits make little sense for this function since <a>is_prob_prime</a> is deterministic at that size. For numbers of 65+ bits, the chance of duplicate bases is quite small. The exponentiation approximation for the birthday problem gives a probability of less than 2e-16 for 100 random bases to have a duplicate with a 65-bit input, and less than 2e-35 with a 128-bit input.</p>

<h2 id="is_lucas_pseudoprime">is_lucas_pseudoprime</h2>

<h2 id="is_strong_lucas_pseudoprime">is_strong_lucas_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input is a standard or strong Lucas probable prime. The Selfridge method of choosing D, P, and Q are used (some sources call this a Lucas-Selfridge test). This is one half of the BPSW primality test (the Miller-Rabin strong probable prime test with base 2 being the other half). The canonical BPSW test (page 1401 of Baillie and Wagstaff (1980)) uses the strong Lucas test with Selfridge parameters, but in practice a variety of Lucas tests with different parameters are used by tests calling themselves BPSW.</p>

<p>The standard Lucas test implemented here corresponds to the Lucas test described in FIPS 186-4 section C.3.3, though uses a slightly more efficient calculation. Since the standard Lucas-Selfridge test is a subset of the strong Lucas-Selfridge test, I recommend using the strong test rather than the standard test for cryptographic purposes. It is often slightly faster, has over 4x fewer pseudoprimes, and is the method recommended by Baillie and Wagstaff in their 1980 paper.</p>

<h2 id="is_extra_strong_lucas_pseudoprime">is_extra_strong_lucas_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input is an extra-strong Lucas probable prime. This is defined in Grantham (2000), and is a slightly more stringent test than the strong Lucas test, though because different parameters are used the pseudoprimes are not a subset. As expected by the extra conditions, the number of pseudoprimes is less than 2/3 that of the strong Lucas-Selfridge test. Runtime performance is 1.2 to 1.5x faster than the strong Lucas test.</p>

<p>The parameters are selected using the Baillie-OEIS method:</p>

<pre><code>  <span class="variable">P</span> <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span>
  <span class="variable">Q</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="variable">jacobi</span><span class="operator">(</span> <span class="variable">P</span><span class="variable">*P</span><span class="operator">-</span><span class="number">4</span><span class="operator">,</span> <span class="variable">n</span> <span class="operator">)</span> <span class="operator">!=</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">)</span>
    <span class="variable">P</span> <span class="operator">+=</span> <span class="number">1</span><span class="operator">;</span>
</code></pre>

<h2 id="is_almost_extra_strong_lucas_pseudoprime">is_almost_extra_strong_lucas_pseudoprime</h2>

<p>Takes a positive number as input and returns 1 if the input is an &quot;almost&quot; extra-strong Lucas probable prime. This is the classic extra-strong Lucas test but without calculating the U sequence. This makes it very fast, although as the input increases in size the time converges to the conventional extra-strong implementation: at 30 digits this routine is about 15% faster, at 300 digits it is only 2% faster.</p>

<p>With the current implementations, there is little reason to prefer this unless trying to reproduce specific results. The extra-strong implementation has been optimized to use similar features, removing most of the performance advantage.</p>

<p>An optional second argument (must be between 1 and 256) indicates the increment amount for P parameter selection. The default value of one yields the method described in <a href="#is_extra_strong_lucas_pseudoprime">&quot;is_extra_strong_lucas_pseudoprime&quot;</a>. A value of 2 yields the method used in <a href="http://pari.math.u-bordeaux.fr/faq.html#primetest">Pari</a>.</p>

<p>Because the <code>U = 0</code> condition is ignored, this produces about 5% more pseudoprimes than the extra-strong Lucas test. However this is still only 66% of the number produced by the strong Lucas-Selfridge test. No BPSW counterexamples have been found with any of the Lucas tests described.</p>

<h2 id="is_euler_plumb_pseudoprime">is_euler_plumb_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input and returns 1 if <code>n</code> passes Colin Plumb&#39;s Euler Criterion primality test. Pseudoprimes to this test are a subset of the base 2 Fermat and Euler tests, but a superset of the base 2 strong pseudoprime (Miller-Rabin) test.</p>

<p>The main reason for this test is that is a bit more efficient than other probable prime tests.</p>

<h2 id="is_perrin_pseudoprime">is_perrin_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input and returns 1 if <code>n</code> divides <code>P(n)</code> where <code>P(n)</code> is the Perrin number of <code>n</code>. The Perrin sequence is defined by <code>P(n) = P(n-2) + P(n-3)</code> with <code>P(0) = 3, P(1) = 0, P(2) = 2</code>.</p>

<p>This is not a commonly used test, as it runs slower than most of the other probable prime tests and offers little benefit, especially over combined tests like <a href="#is_bpsw_prime">&quot;is_bpsw_prime&quot;</a>, <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a>, and <a href="#is_frobenius_khashin_pseudoprime">&quot;is_frobenius_khashin_pseudoprime&quot;</a>.</p>

<p>An optional second argument <code>r</code> indicates whether to run additional tests. With <code>r=1</code>, <code>P(-n) = -1 mod n</code> is also verified, creating the &quot;minimal restricted&quot; test. With <code>r=2</code>, the full signature is also tested using the Adams and Shanks (1982) rules (without the quadratic form test). With <code>r=3</code>, the full signature is tested using the Grantham (2000) test, which additionally does not allow pseudoprimes to be divisible by 2 or 23. The minimal restricted pseudoprime sequence is <a href="http://oeis.org/A018187">OEIS A018187</a>.</p>

<h2 id="is_frobenius_pseudoprime">is_frobenius_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input, and two optional parameters <code>a</code> and <code>b</code>, and returns 1 if the <code>n</code> is a Frobenius probable prime with respect to the polynomial <code>x^2 - ax + b</code>. Without the parameters, <code>b = 2</code> and <code>a</code> is the least positive odd number such that <code>(a^2-4b|n) = -1</code>. This selection has no pseudoprimes below <code>2^64</code> and none known. In any case, the discriminant <code>a^2-4b</code> must not be a perfect square.</p>

<h2 id="is_frobenius_underwood_pseudoprime">is_frobenius_underwood_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes the efficient Frobenius test of Paul Underwood. This selects a parameter <code>a</code> as the least non-negative integer such that <code>(a^2-4|n)=-1</code>, then verifies that <code>(x+2)^(n+1) = 2a + 5 mod (x^2-ax+1,n)</code>. This combines a Fermat and Lucas test at a computational cost of about 2.5x a strong pseudoprime test. This makes it similar to, but faster than, a standard Frobenius test.</p>

<p>This test is deterministic (no randomness is used). There are no known pseudoprimes to this test. This test also has no overlap with the BPSW test, making it a very effective method for adding additional certainty.</p>

<h2 id="is_frobenius_khashin_pseudoprime">is_frobenius_khashin_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes the Frobenius test of Sergey Khashin. This ensures <code>n</code> is not a perfect square, selects the parameter <code>c</code> as the smallest odd prime such that <code>(c|n)=-1</code>, then verifies that <code>(1+D)^n = (1-D) mod n</code> where <code>D = sqrt(c) mod n</code>.</p>

<p>This test is deterministic (no randomness is used). There are no known pseudoprimes to this test.</p>

<h2 id="is_bpsw_prime">is_bpsw_prime</h2>

<p>Given a positive number input, returns 0 (composite), 2 (definitely prime), or 1 (probably prime), using the BPSW primality test (extra-strong variant).</p>

<p>This function does the extra-strong BPSW test and nothing more. That is, it will skip all pretests and any extra work that the <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> test may add. This saves some time if the input has no small factors, such as testing results that have been sieved.</p>

<h2 id="is_aks_prime">is_aks_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_aks_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number as input, and returns 1 if the input passes the Agrawal-Kayal-Saxena (AKS) primality test. This is a deterministic unconditional primality test which runs in polynomial time for general input.</p>

<p>The particular method used is theorem 4.1 from Bernstein (2003). This is substantially faster than the original AKS publication, the later version with improvements by Lenstra (sometimes called the V6 paper), or the later improvements of Voloch and Bornemann. It is, by a large order, faster than any other known implementation as of early 2017.</p>

<p>For theoretical analysis of the primality task, AKS is extremely important. In practice, it is essentially useless. Estimated run time for a 150 digit input is over 2 days, making the case that while the algorithmic complexity <i>growth</i> is polynomial, the constants are extremely high. It will take years for for numbers that ECPP or APR-CL can prove in seconds.</p>

<p>With the <code>verbose</code> option set to 1, the chosen <code>r</code> and <code>s</code> values are printed before the test starts. With <code>verbose</code> set to 2 or higher, each of the <code>s</code> tests results in a <code>.</code> output as the test runs, allowing progress to be monitored.</p>

<p>Typically you should use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> and let it decide the method.</p>

<h2 id="is_mersenne_prime">is_mersenne_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"2^607-1 (M607) is a Mersenne prime"</span> <span class="keyword">if</span> <span class="variable">is_mersenne_prime</span><span class="operator">(</span><span class="number">607</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number <code>p</code> as input and returns 1 if <code>2^p-1</code> is prime. After some pre-testing, the Lucas-Lehmer test is performed. This is a deterministic unconditional test that runs very fast compared to other primality methods for numbers of comparable size, and vastly faster than any known general-form primality proof methods.</p>

<h2 id="is_llr_prime">is_llr_prime</h2>

<p>Takes a positive number <code>n</code> as input and returns one of: 0 (definitely composite), 2 (definitely prime), or -1 (test does not indicate anything). This implements the Lucas-Lehmer-Riesel test for fast deterministic primality testing on numbers of the form <code>k * 2^n - 1</code>. If the input is not of this form or if <code>k &gt;= 2^n</code> then <code>-1</code> will be returned as the test does not apply. If <code>k = 1</code> then this is a Mersenne number and the Lucas-Lehmer test is used. Otherwise, the LLR test is performed. While not as fast as the Lucas-Lehmer test for Mersenne numbers, it is almost as fast as a single strong pseudoprime test (i.e. Miller-Rabin test) while giving a certain answer.</p>

<h2 id="is_proth_prime">is_proth_prime</h2>

<p>Takes a positive number <code>n</code> as input and returns one of: 0 (definitely composite), 2 (definitely prime), or -1 (test does not indicate anything). This applies Proth&#39;s theorem for fast Las Vegas primality testing on numbers of the form <code>k * 2^n + 1</code>. If the input is not of this form or if <code>k &gt;= 2^n</code> then <code>-1</code> will be returned as the test does not apply. Otherwise, a search is performed to find a quadratic nonresidue modulo <code>n</code>. If none can be found after a brief search, <code>-1</code> is returned as no conclusion can be reached. Otherwise, Proth&#39;s theorem is checked which conclusively indicates primality. While not as fast as the Lucas-Lehmer test for Mersenne numbers, it is almost as fast as a single strong pseudoprime test (i.e. Miller-Rabin test) while giving a certain answer.</p>

<h2 id="is_miller_prime">is_miller_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_miller_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime assuming the GRH"</span> <span class="keyword">if</span> <span class="variable">is_miller_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number as input, and returns 1 if the input passes the deterministic Miller test. An optional second argument indicates whether the Generalized Riemann Hypothesis should be assumed, and defaults to 0. Setting the verbose flag to 2 or higher will show how many bases are used. The unconditional test is exponential time, while the conditional test (assuming the GRH) is polynomial time.</p>

<p>This is a very slow method in practice, and generally should not be used. The asymptotic complexity of the GRH version is good in theory, matching ECPP, but in practice it is much slower. The number of bases used by the unconditional test grows quite rapidly, impractically many past about 160 bits, and overflows a 64-bit integer at 456 bits -- sizes that are trivial for the unconditional APR-CL and ECPP tests.</p>

<h2 id="is_nminus1_prime">is_nminus1_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_nminus1_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number as input, and returns 1 if the input passes either theorem 5 or theorem 7 of the Brillhart-Lehmer-Selfridge primality test. This is a deterministic unconditional primality test which requires factoring <code>n-1</code> to a linear factor less than the cube root of the input. For small inputs (under 40 digits) this is typically very easy, and some numbers will naturally lead to this being very fast. As the input grows, this method slows down rapidly.</p>

<p>This method is most appropriate for numbers of the form <code>k+1</code> where <code>k</code> can be easily factored. Typically you should use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> and let it decide the method.</p>

<h2 id="is_nplus1_prime">is_nplus1_prime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes either theorem 17 or theorem 19 of the Brillhart-Lehmer-Selfridge primality test. This is a deterministic unconditional primality test which requires factoring <code>n+1</code> to a linear factor less than the cube root of the input. For small inputs (under 40 digits) this is typically very easy, and some numbers will naturally lead to this being very fast. As the input grows, this method slows down rapidly.</p>

<p>Disregarding factoring, this is slightly slower than the <code>n-1</code> methods. It is most appropriate for numbers of the form <code>k-1</code> where <code>k</code> can be easily factored.</p>

<h2 id="is_bls75_prime">is_bls75_prime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes one of the tests from the Brillhart-Lehmer-Selfridge (1975) paper. These use partial factoring of <code>n-1</code> and <code>n+1</code>. Currently the implementation will use one of:</p>

<pre><code>  N-1   Corollary 1, Theorem 5, Theorem 7
  N+1   Corollary 8, Theorem 17, Theorem 19
  Comb  Theorem 20</code></pre>

<p>This is appropriate for cases where either <code>n-1</code> or <code>n+1</code> can be easily factored, or when both of them have many small factors.</p>

<h2 id="is_ecpp_prime">is_ecpp_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_ecpp_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number as input, and returns 1 if the input passes the ECPP primality test. This is the Atkin-Morain Elliptic Curve Primality Proving algorithm. It is the fastest primality proving method in Math::Prime::Util.</p>

<p>This implementation uses a &quot;factor all strategy&quot; (FAS) with backtracking. A limited set of about 500 precalculated discriminants are used, which works well for inputs up to 300 digits, and for many inputs up to one thousand digits. Having a larger set will help with large numbers (a set of 2650 is available on github in the <code>xt/</code> directory). A future implementation may include code to generate class polynomials as needed.</p>

<p>Typically you should use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> and let it decide the method.</p>

<h2 id="primes">primes</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$aref1</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">1_000_000</span> <span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$aref2</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">2</span> <span class="operator">**</span> <span class="number">448</span><span class="operator">,</span> <span class="number">2</span> <span class="operator">**</span> <span class="number">448</span> <span class="operator">+</span> <span class="number">10000</span> <span class="operator">);</span>
  <span class="keyword">say</span> <span class="keyword">join</span> <span class="string">","</span><span class="operator">,</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">primes</span><span class="operator">(</span> <span class="number">2</span><span class="operator">**</span><span class="number">2048</span><span class="operator">,</span> <span class="number">2</span><span class="operator">**</span><span class="number">2048</span> <span class="operator">+</span> <span class="number">10000</span> <span class="operator">)</span><span class="operator">}</span><span class="operator">;</span>
</code></pre>

<p>Returns all the primes between the lower and upper limits (inclusive), with a lower limit of <code>2</code> if none is given.</p>

<p>An array reference is returned, matching the signature of the function of the same name in <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a>.</p>

<p>Values above 64-bit are extra-strong BPSW probable primes.</p>

<h2 id="sieve_primes">sieve_primes</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@primes</span> <span class="operator">=</span> <span class="variable">sieve_primes</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">100</span><span class="operator">,</span> <span class="number">2</span><span class="operator">**</span><span class="number">100</span> <span class="operator">+</span> <span class="number">10000</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@candidates</span> <span class="operator">=</span> <span class="variable">sieve_primes</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">1000</span><span class="operator">,</span> <span class="number">2</span><span class="operator">**</span><span class="number">1000</span> <span class="operator">+</span> <span class="number">10000</span><span class="operator">,</span> <span class="number">40000</span><span class="operator">);</span>
</code></pre>

<p>Given two arguments <code>low</code> and <code>high</code>, this returns the primes in the interval (inclusive) as a list. It operates similar to <a>primes</a>, though must always have an lower and upper bound and returns a list.</p>

<p>With three arguments <code>low</code>, <code>high</code>, and <code>limit</code>, this does a partial sieve over the inclusive range and returns the list that pass the sieve. If <code>limit</code> is less than <code>2</code> then it is identical to the two-argument version, in that a primality test will be performed after sieving. Otherwise, sieving is performed up to <code>limit</code>.</p>

<p>The two-argument version is typically only used internally and adds little functionality. The three-argument version is quite useful for applications that want to apply their own primality or other tests, and wish to have a list of values in the range with no small factors. This is quite common for applications involving prime gaps.</p>

<p>Also see <a href="#sieve_range">&quot;sieve_range&quot;</a>.</p>

<h2 id="sieve_range">sieve_range</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@candidates</span> <span class="operator">=</span> <span class="variable">sieve_range</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">1000</span><span class="operator">,</span> <span class="number">10000</span><span class="operator">,</span> <span class="number">40000</span><span class="operator">);</span>
</code></pre>

<p>Given a start value <code>n</code>, and native unsigned integers <code>width</code> and <code>depth</code>, a sieve of maximum depth <code>depth</code> is done for the <code>width</code> consecutive numbers beginning with <code>n</code>. An array of offsets from the start is returned.</p>

<p>The returned list contains those offsets in the range <code>n</code> to <code>n+width-1</code> where <code>n + offset</code> has no prime factors less than <code>depth</code>.</p>

<p>This function is very similar to the three argument form of <a href="#sieve_primes">&quot;sieve_primes&quot;</a>. The differences are using <code>(n,width)</code> instead of <code>(low,high)</code>, and most importantly returning small offsets from the start value rather than the values themselves. This can substantially reduce overhead for multi-thousand digit numbers.</p>

<h2 id="sieve_twin_primes">sieve_twin_primes</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@primes</span> <span class="operator">=</span> <span class="variable">sieve_twin_primes</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">1000</span><span class="operator">,</span> <span class="number">2</span><span class="operator">**</span><span class="number">1000</span> <span class="operator">+</span> <span class="number">500000</span><span class="operator">);</span>
</code></pre>

<p>Given two arguments <code>low</code> and <code>high</code>, this returns each lower twin prime in the interval (inclusive). The result is a list, not a reference.</p>

<p>This does a partial sieve of the range, removes any non-twin candidates, then checks that each pair are both BPSW probable primes. This is substantially more efficient than sieving for all primes followed by removing those that are not twin primes.</p>

<h2 id="sieve_prime_cluster">sieve_prime_cluster</h2>

<pre><code>  <span class="comment"># Find some prime septuplets</span>
  <span class="keyword">my</span> <span class="variable">@s</span> <span class="operator">=</span> <span class="variable">sieve_prime_cluster</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">100</span><span class="operator">,</span> <span class="number">2</span><span class="operator">**</span><span class="number">100</span><span class="operator">+</span><span class="number">1e12</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">12</span><span class="operator">,</span><span class="number">18</span><span class="operator">,</span><span class="number">20</span><span class="operator">);</span>
</code></pre>

<p>Efficiently finds prime clusters between the first two arguments <code>low</code> and <code>high</code> (inclusive). The remaining arguments describe the cluster. The cluster values must be even, less than 31 bits, and strictly increasing. Given a cluster set <code>C</code>, the returned values are all primes in the range where <code>p+c</code> is prime for all <code>c</code> in the cluster set <code>C</code>.</p>

<p>The cluster is described as offsets from 0, with the implicit prime at 0. Hence an empty list is asking for all primes (the cluster <code>p+0</code>). A list with the single value <code>2</code> will find all twin primes (the cluster where <code>p+0</code> and <code>p+2</code> are prime). The list <code>2,6,8</code> will find prime quadruplets. Note that there is no requirement that the list denote a constellation (a cluster with minimal distance) -- the list <code>42,92,606</code> is just fine.</p>

<p>For long clusters, e.g. <a href="http://oeis.org/A213601">OEIS series A213601</a> prime 12-tuplets, this will be immensely more efficient than filtering out the cluster from a list of primes. For that example, a range of <code>10^13</code> takes less than a second to search -- thousands of times faster than filtering results from primes or twin primes. Shorter clusters are not quite this efficient, and the overhead for returning large arrays should not be ignored.</p>

<h2 id="next_prime">next_prime</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">next_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns the prime following the input number (the smallest prime number that is greater than the input number). The function <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> is used to determine when a prime is found, hence the result is a probable prime (using BPSW).</p>

<p>For large inputs this function is quite a bit faster than GMP&#39;s <code>mpz_nextprime</code> or Pari&#39;s <code>nextprime</code>.</p>

<h2 id="prev_prime">prev_prime</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">prev_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns the prime preceding the input number (the largest prime number that is less than the input number). 0 is returned if the input is <code>2</code> or lower. The function <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> is used to determine when a prime is found, hence the result is a probable prime (using BPSW).</p>

<h2 id="surround_primes">surround_primes</h2>

<pre><code>  <span class="operator">(</span><span class="variable">$dprev</span><span class="operator">,</span> <span class="variable">$dnext</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">surround_primes</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns the distances to the previous and next primes of the input <code>n</code>. This is slightly more efficient than calling both <a href="#prev_prime">&quot;prev_prime&quot;</a> and <a href="#next_prime">&quot;next_prime&quot;</a>, and returning the distances as native integers is more efficient with large inputs.</p>

<p>If an optional second argument <code>d</code> is given, and the input <code>n</code> is larger than <code>2^64</code>, then if a SPSP-2 is found in the range <code>n-d</code> to <code>n+d</code> (inclusive) then it will be returned with the other argument set to <code>0</code>. Otherwise, the first SPSP-2 values found are returned. This feature is especially useful for prime gap searches as well as finding the nearest prime to a value.</p>

<p>Note that with a non-zero second argument, the values returned have not undergone a full BPSW test; just sieving and a SPSP-2 test.</p>

<h2 id="random_nbit_prime">random_nbit_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"random 512-bit prime: "</span><span class="operator">,</span> <span class="variable">random_nbit_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Returns a randomly selected prime of exactly <code>n</code> bits. <code>undef</code> is returned if <code>n</code> is less than <code>2</code>. The returned prime has passed the <code>is_prob_prime</code> (extra strong BPSW) test.</p>

<h2 id="random_strong_prime">random_strong_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"random 512-bit strong prime: "</span><span class="operator">,</span> <span class="variable">random_strong_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Returns a randomly selected strong prime of exactly <code>n</code> bits. <code>n</code> must be at least <code>256</code>. The returned prime has passed the <code>is_prob_prime</code> (extra strong BPSW) test.</p>

<p>Given the returned prime <code>p</code>, <code>p+1</code>, <code>q=p-1</code>, and <code>q-1</code> will all have a large factor. This makes using factoring methods such as p-1 and p+1 much harder. Gordon&#39;s algorithm is used. The value of using strong primes is questionable over proper random primes when the number of bits is at least 1024.</p>

<h2 id="random_ndigit_prime">random_ndigit_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"random 200-digit prime: "</span><span class="operator">,</span> <span class="variable">random_ndigit_prime</span><span class="operator">(</span><span class="number">200</span><span class="operator">);</span>
</code></pre>

<p>Returns a randomly selected prime of exactly <code>n</code> digits. <code>undef</code> is returned if <code>n</code> is less than <code>1</code>. The returned prime has passed the <code>is_prob_prime</code> (extra strong BPSW) test.</p>

<h2 id="random_prime">random_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="variable">random_prime</span><span class="operator">(</span><span class="number">1000</span><span class="operator">,</span> <span class="number">2000</span><span class="operator">);</span>  <span class="comment"># prime between 1000 and 2000 inclusive</span>
</code></pre>

<p>Returns a random prime in the interval <code>[a,b]</code> or <code>undef</code> if no prime is in the range. The returned prime has passed the <code>is_prob_prime</code> (extra strong BPSW) test.</p>

<p>The random prime functions use the internal CSPRNG for randomness. This is currently ISAAC-32 but will likely change to ChaCha20 in a later release.</p>

<p>This corresponds to Mathematica&#39;s <code><span class="variable">RandomPrime</span><span class="operator">[{</span><span class="variable">min</span><span class="operator">,</span><span class="variable">max</span><span class="operator">}]</span>
</code> function. This is a superset of Pari&#39;s <code>randomprime(n)</code> function, where our interval API is more convenient for cryptographic functions.</p>

<h2 id="random_maurer_prime">random_maurer_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"random 512-bit proven prime: "</span><span class="operator">,</span> <span class="variable">random_maurer_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Returns an n-bit proven prime using Ueli Maurer&#39;s FastPrime algorithm (1995). This results in uniform random selection of a proven prime, though not every n-bit prime can be generated with this algorithm.</p>

<p><code>undef</code> is returned if <code>n</code> is less than <code>2</code>. As a safety check, internally the extra strong BPSW test is additionally run on each intermediate and the final result.</p>

<h2 id="random_shawe_taylor_prime">random_shawe_taylor_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"random 512-bit proven prime: "</span><span class="operator">,</span> <span class="variable">random_shawe_taylor_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Returns an n-bit proven prime using the Shawe-Taylor algorithm (1986) from section C.6 of FIPS 186-4, although using our CSPRNG rather than SHA-256. This is a slightly simpler and older (1986) method than Maurer&#39;s algorithm. It is a bit faster than Maurer&#39;s method but has a smaller subset of returned primes.</p>

<p><code>undef</code> is returned if <code>n</code> is less than <code>2</code>. As a safety check, internally the extra strong BPSW test is additionally run on each intermediate and the final result.</p>

<h2 id="random_maurer_prime_with_cert">random_maurer_prime_with_cert</h2>

<p>Like <a href="#random_maurer_prime">&quot;random_maurer_prime&quot;</a> but also returns a string certificate.</p>

<h2 id="random_shawe_taylor_prime_with_cert">random_shawe_taylor_prime_with_cert</h2>

<p>Like <a href="#random_shawe_taylor_prime">&quot;random_shawe_taylor_prime&quot;</a> but also returns a string certificate.</p>

<h2 id="lucasu">lucasu</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Fibonacci(</span><span class="variable">$_</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">lucasu</span><span class="operator">(</span><span class="number">1</span><span class="operator">,-</span><span class="number">1</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">0</span><span class="operator">..</span><span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>P</code>, <code>Q</code>, and the non-negative integer <code>k</code>, computes <code>U_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>. These include the Fibonacci numbers (<code>1,-1</code>), the Pell numbers (<code>2,-1</code>), the Jacobsthal numbers (<code>1,-2</code>), the Mersenne numbers (<code>3,2</code>), and more.</p>

<p>This corresponds to OpenPFGW&#39;s <code>lucasU</code> function and gmpy2&#39;s <code>lucasu</code> function.</p>

<h2 id="lucasv">lucasv</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Lucas(</span><span class="variable">$_</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">lucasv</span><span class="operator">(</span><span class="number">1</span><span class="operator">,-</span><span class="number">1</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">0</span><span class="operator">..</span><span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>P</code>, <code>Q</code>, and the non-negative integer <code>k</code>, computes <code>V_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>. These include the Lucas numbers (<code>1,-1</code>).</p>

<p>This corresponds to OpenPFGW&#39;s <code>lucasV</code> function and gmpy2&#39;s <code>lucasv</code> function.</p>

<h2 id="lucas_sequence">lucas_sequence</h2>

<pre><code>  my($U, $V, $Qk) = lucas_sequence($n, $P, $Q, $k)</code></pre>

<p>Computes <code>U_k</code>, <code>V_k</code>, and <code>Q_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>, modulo <code>n</code>. The modular Lucas sequence is used in a number of primality tests and proofs.</p>

<p>The following conditions must hold: - <code>D = P*P - 4*Q != 0</code> - <code>P &gt; 0</code> - <code>P &lt; n</code> - <code>Q &lt; n</code> - <code>k &gt;= 0</code> - <code>n &gt;= 2</code></p>

<h2 id="primorial">primorial</h2>

<pre><code>  <span class="variable">$p</span> <span class="operator">=</span> <span class="variable">primorial</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Given an unsigned integer argument, returns the product of the prime numbers which are less than or equal to <code>n</code>. This definition of <code>n#</code> follows <a href="http://oeis.org/A034386">OEIS series A034386</a> and <a href="http://en.wikipedia.org/wiki/Primorial#Definition_for_natural_numbers">Wikipedia: Primorial definition for natural numbers</a>.</p>

<h2 id="pn_primorial">pn_primorial</h2>

<pre><code>  $p = pn_primorial($n)</code></pre>

<p>Given an unsigned integer argument, returns the product of the first <code>n</code> prime numbers. This definition of <code>p_n#</code> follows <a href="http://oeis.org/A002110">OEIS series A002110</a> and <a href="http://en.wikipedia.org/wiki/Primorial#Definition_for_prime_numbers">Wikipedia: Primorial definition for prime numbers</a>.</p>

<p>The two are related with the relationships:</p>

<pre><code>  pn_primorial($n)  ==   primorial( nth_prime($n) )
  primorial($n)     ==   pn_primorial( prime_count($n) )</code></pre>

<h2 id="factorial">factorial</h2>

<p>Given positive integer argument <code>n</code>, returns the factorial of <code>n</code>, defined as the product of the integers 1 to <code>n</code> with the special case of <code>factorial(0) = 1</code>. This corresponds to Pari&#39;s <code>factorial(n)</code> and Mathematica&#39;s <code>Factorial[n]</code> functions.</p>

<h2 id="factorialmod">factorialmod</h2>

<p>Given two positive integer arguments <code>n</code> and <code>m</code>, returns <code>n! mod m</code>. This is much faster than computing the large <code>factorial(n)</code> followed by a mod operation.</p>

<h2 id="gcd">gcd</h2>

<p>Given a list of integers, returns the greatest common divisor. This is often used to test for <a href="https://oeis.org/wiki/Coprimality">coprimality</a>.</p>

<h2 id="lcm">lcm</h2>

<p>Given a list of integers, returns the least common multiple.</p>

<h2 id="gcdext">gcdext</h2>

<p>Given two integers <code>x</code> and <code>y</code>, returns <code>u,v,d</code> such that <code>d = gcd(x,y)</code> and <code>u*x + v*y = d</code>. This uses the extended Euclidian algorithm to compute the values satisfying B&eacute;zout&#39;s Identity.</p>

<p>This corresponds to Pari&#39;s <code>gcdext</code> function, which was renamed from <code>bezout</code> in Pari 2.6. The results will hence match <a>&quot;bezout&quot; in Math::Pari</a>.</p>

<h2 id="chinese">chinese</h2>

<pre><code>  <span class="keyword">say</span> <span class="variable">chinese</span><span class="operator">(</span> <span class="operator">[</span><span class="number">14</span><span class="operator">,</span><span class="number">643</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="number">254</span><span class="operator">,</span><span class="number">419</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="number">87</span><span class="operator">,</span><span class="number">733</span><span class="operator">]</span> <span class="operator">);</span>  <span class="comment"># 87041638</span>
</code></pre>

<p>Solves a system of simultaneous congruences using the Chinese Remainder Theorem (with extension to non-coprime moduli). A list of <code>[a,n]</code> pairs are taken as input, each representing an equation <code>x &equiv; a mod n</code>. If no solution exists, <code>undef</code> is returned. If a solution is returned, the modulus is equal to the lcm of all the given moduli (see <a href="#lcm">&quot;lcm&quot;</a>. In the standard case where all values of <code>n</code> are coprime, this is just the product. The <code>n</code> values must be positive integers, while the <code>a</code> values are integers.</p>

<h2 id="vecsum">vecsum</h2>

<p>Returns the sum of all arguments, each of which must be an integer.</p>

<h2 id="vecprod">vecprod</h2>

<p>Returns the product of all arguments, each of which must be an integer.</p>

<h2 id="kronecker">kronecker</h2>

<p>Returns the Kronecker symbol <code>(a|n)</code> for two integers. The possible return values with their meanings for odd positive <code>n</code> are:</p>

<pre><code>   0   a = 0 mod n
   1   a is a quadratic residue modulo n (a = x^2 mod n for some x)
  -1   a is a quadratic non-residue modulo n</code></pre>

<p>The Kronecker symbol is an extension of the Jacobi symbol to all integer values of <code>n</code> from the latter&#39;s domain of positive odd values of <code>n</code>. The Jacobi symbol is itself an extension of the Legendre symbol, which is only defined for odd prime values of <code>n</code>. This corresponds to Pari&#39;s <code>kronecker(a,n)</code> function and Mathematica&#39;s <code>KroneckerSymbol[n,m]</code> function.</p>

<h2 id="binomial">binomial</h2>

<p>Given integer arguments <code>n</code> and <code>k</code>, returns the binomial coefficient <code>n*(n-1)*...*(n-k+1)/k!</code>, also known as the choose function. Negative arguments use the <a href="http://arxiv.org/abs/1105.3689/">Kronenburg extensions</a>. This corresponds to Mathematica&#39;s <code>Binomial[n,k]</code> function, Pari&#39;s <code>binomial(n,k)</code> function, and GMP&#39;s <code>mpz_bin_ui</code> function.</p>

<p>For negative arguments, this matches Mathematica. Pari does not implement the <code>n &lt; 0, k &lt;= n</code> extension and instead returns <code>0</code> for this case. GMP&#39;s API does not allow negative <code>k</code> but otherwise matches. <a href="../../../../lib/Math/BigInt.html">Math::BigInt</a> does not implement any extensions and the results for <code>n &lt; 0, k &gt; 0</code> are undefined.</p>

<h2 id="bernfrac">bernfrac</h2>

<p>Returns the Bernoulli number <code>B_n</code> for an integer argument <code>n</code>, as a rational number. Two values are returned, the numerator and denominator. B_1 = 1/2. This corresponds to Pari&#39;s <code>bernfrac(n)</code> and Mathematica&#39;s <code>BernoulliB</code> functions.</p>

<h2 id="bernreal">bernreal</h2>

<p>Returns the Bernoulli number <code>B_n</code> for an integer argument <code>n</code>, as a string floating point. An optional second argument indicates the number of significant digits to be used, with the result rounded. The default is 40 digits. This corresponds to Pari&#39;s <code>bernreal</code> function and.</p>

<h2 id="harmfrac">harmfrac</h2>

<p>Returns the Harmonic number <code>H_n</code> for an integer argument <code>n</code>, as a rational number. Two values are returned, the numerator and denominator. numbers are the sum of reciprocals of the first <code>n</code> natural numbers: <code>1 + 1/2 + 1/3 + ... + 1/n</code>. This corresponds to Mathematica&#39;s <code>HarmonicNumber</code> function.</p>

<h2 id="harmreal">harmreal</h2>

<p>Returns the Harmonic number <code>H_n</code> for an integer argument <code>n</code>, as a string floating point. An optional second argument indicates the number of digits to be preserved past the decimal place, with a default of 40.</p>

<h2 id="stirling">stirling</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"s(14,2) = "</span><span class="operator">,</span> <span class="variable">stirling</span><span class="operator">(</span><span class="number">14</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"S(14,2) = "</span><span class="operator">,</span> <span class="variable">stirling</span><span class="operator">(</span><span class="number">14</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
</code></pre>

<p>Returns the Stirling numbers of either the first kind (default), the second kind, or the third kind (the unsigned Lah numbers), with the kind selected as an optional third argument. It takes two non-negative integer arguments <code>n</code> and <code>k</code> plus the optional <code>type</code>. This corresponds to Pari&#39;s <code><span class="variable">stirling</span><span class="operator">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">k</span><span class="operator">,</span><span class="operator">{</span><span class="string">type</span><span class="operator">}</span><span class="operator">)</span>
</code> function and Mathematica&#39;s <code>StirlingS1</code> / <code>StirlingS2</code> functions.</p>

<p>Stirling numbers of the first kind are <code>-1^(n-k)</code> times the number of permutations of <code>n</code> symbols with exactly <code>k</code> cycles. Stirling numbers of the second kind are the number of ways to partition a set of <code>n</code> elements into <code>k</code> non-empty subsets. The Lah numbers are the number of ways to split a set of <code>n</code> elements into <code>k</code> non-empty lists.</p>

<h2 id="zeta">zeta</h2>

<p>Given a positive integer or float <code>n</code>, returns the real Riemann Zeta value as a string floating point. An optional second argument indicates the number of digits past the decimal point (default 40).</p>

<p>The implementation is algorithm 2 of Borwein (1991). Performance with integer inputs is good, but floating point arguments with high precision will be much slower than methods using MPFR. <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> will try to use <a>Math::MPFR</a> if possible.</p>

<h2 id="riemannr">riemannr</h2>

<p>Given a positive integer or float <code>n</code>, returns the real Riemann R function as a string floating point. An optional second argument indicates the number of significant digits (default 40) with the result rounded.</p>

<p>The implementation is the standard Gram series.</p>

<h2 id="lambertw">lambertw</h2>

<p>Given a float <code>x</code>, returns the principal branch of the Lambert W function. This solves for <code>W</code> in the equation <code>x = W*exp(W)</code>. The input must not be less than <code>-1/e</code>. This corresponds to Pari&#39;s <code>lambertw</code> function and Mathematica&#39;s <code>ProductLog</code> / <code>LambertW</code> function.</p>

<h2 id="znorder">znorder</h2>

<pre><code>  <span class="variable">$order</span> <span class="operator">=</span> <span class="variable">znorder</span><span class="operator">(</span><span class="number">17</span><span class="operator">,</span> <span class="string">"100000000000000000000000065"</span><span class="operator">);</span>
</code></pre>

<p>Given two positive integers <code>a</code> and <code>n</code>, returns the multiplicative order of <code>a</code> modulo <code>n</code>. This is the smallest positive integer <code>k</code> such that <code>a^k &equiv; 1 mod n</code>. Returns 1 if <code>a = 1</code>. Returns undef if <code>a = 0</code> or if <code>a</code> and <code>n</code> are not coprime, since no value will result in 1 mod n. This corresponds to Pari&#39;s <code>znorder(Mod(a,n))</code> function and Mathematica&#39;s <code>MultiplicativeOrder[a,n]</code> function.</p>

<h2 id="znprimroot">znprimroot</h2>

<p>Given a positive integer <code>n</code>, returns the smallest primitive root of <code>(Z/nZ)^*</code>, or <code>undef</code> if no root exists. A root exists when <code>euler_phi($n) == carmichael_lambda($n)</code>, which will be true for all prime <code>n</code> and some composites.</p>

<p><a href="http://oeis.org/A033948">OEIS A033948</a> is a sequence of integers where the primitive root exists, while <a href="http://oeis.org/A046145">OEIS A046145</a> is a list of the smallest primitive roots, which is what this function produces.</p>

<h2 id="is_primitive_root">is_primitive_root</h2>

<p>Given two non-negative numbers <code>a</code> and <code>n</code>, returns <code>1</code> if <code>a</code> is a primitive root modulo <code>n</code>, and <code>0</code> if not. If <code>a</code> is a primitive root, then <code>euler_phi(n)</code> is the smallest <code>e</code> for which <code>a^e = 1 mod n</code>.</p>

<h2 id="is_semiprime">is_semiprime</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a semiprime, 0 otherwise. A semiprime is the product of exactly two primes.</p>

<p>The boolean result is the same as <code>scalar(factor(n)) == 2</code>, but this function performs shortcuts that can greatly speed up the operation.</p>

<h2 id="is_carmichael">is_carmichael</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a Carmichael number, 0 otherwise. These are composites that satisfy <code>b^(n-1) &equiv; 1 mod n</code> for all <code>1 &lt; b &lt; n</code> relatively prime to <code>n</code>. Alternately Korselt&#39;s theorem says these are composites such that <code>n</code> is square-free and <code>p-1</code> divides <code>n-1</code> for all prime divisors <code>p</code> of <code>n</code>.</p>

<p>Inputs greater than 50 digits use a probabilistic test to avoid fully factoring the input.</p>

<h2 id="is_fundamental">is_fundamental</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a fundamental discriminant, 0 otherwise.</p>

<h2 id="is_totient">is_totient</h2>

<p>Given an integer <code>n</code>, returns 1 if there exists an integer <code>x</code> where <code>euler_phi(x) == n</code>.</p>

<h2 id="is_polygonal">is_polygonal</h2>

<p>Given integers <code>x</code> and <code>s</code>, return 1 if x is an s-gonal number, 0 otherwise. <code>s</code> must be greater than 2.</p>

<h2 id="polygonal_nth">polygonal_nth</h2>

<p>Given integers <code>x</code> and <code>s</code>, return N if <code>x</code> is the <code>N-th</code> s-gonal number, 0 otherwise.</p>

<h2 id="sigma">sigma</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Sum of divisors of </span><span class="variable">$n</span><span class="string">:"</span><span class="operator">,</span> <span class="variable">sigma</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"sigma_2(</span><span class="variable">$n</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">sigma</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"Number of divisors: sigma_0(</span><span class="variable">$n</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">sigma</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</code></pre>

<p>This function takes a positive integer as input and returns the sum of its divisors, including 1 and itself. An optional second argument <code>k</code> may be given, which will result in the sum of the <code>k-th</code> powers of the divisors to be returned.</p>

<p>This is known as the sigma function (see Hardy and Wright section 16.7, or OEIS A000203). The API is identical to Pari/GP&#39;s <code>sigma</code> function. This function is useful for calculating things like aliquot sums, abundant numbers, perfect numbers, etc.</p>

<h2 id="ramanujan_tau">ramanujan_tau</h2>

<p>Takes a positive integer as input and returns the value of Ramanujan&#39;s tau function. The result is a signed integer. This corresponds to Mathematica&#39;s <code>RamanujanTau</code> function and Pari&#39;s <code>ramanujantau</code> function.</p>

<h2 id="valuation">valuation</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is divisible by 2 "</span><span class="operator">,</span> <span class="variable">valuation</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span><span class="number">2</span><span class="operator">),</span> <span class="string">" times."</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>n</code> and <code>k</code>, returns the numbers of times <code>n</code> is divisible by <code>k</code>. This is a very limited version of the algebraic valuation meaning, just applied to integers. This corresponds to Pari&#39;s <code>valuation</code> function. <code>0</code> is returned if <code>n</code> or <code>k</code> is one of the values <code>-1</code>, <code>0</code>, or <code>1</code>.</p>

<h2 id="hammingweight">hammingweight</h2>

<p>Given an integer <code>n</code>, returns the binary Hamming weight of <code>abs(n)</code>. This is also called the population count, and is the number of 1s in the binary representation. This corresponds to Pari&#39;s <code>hammingweight</code> function for <code>t_INT</code> arguments.</p>

<h2 id="moebius">moebius</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is square free"</span> <span class="keyword">if</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">200</span><span class="operator">);</span> <span class="keyword">say</span> <span class="string">"Mertens(200) = </span><span class="variable">$sum</span><span class="string">"</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="string">"Mertens(2000) = "</span><span class="operator">,</span> <span class="variable">vecsum</span><span class="operator">(</span><span class="variable">moebius</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="number">2000</span><span class="operator">));</span>
</code></pre>

<p>Returns &mu;(n), the M&ouml;bius function (also known as the Moebius, Mobius, or MoebiusMu function) for an integer input. This function is 1 if <code>n = 1</code>, 0 if <code>n</code> is not square free (i.e. <code>n</code> has a repeated factor), and <code>-1^t</code> if <code>n</code> is a product of <code>t</code> distinct primes. This is an important function in prime number theory. Like SAGE, we define <code>moebius(0) = 0</code> for convenience.</p>

<p>If called with two arguments, they define a range <code>low</code> to <code>high</code>, and the function returns an array with the value of the M&ouml;bius function for every n from low to high inclusive.</p>

<h2 id="invmod">invmod</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The inverse of 42 mod 2017 = "</span><span class="operator">,</span> <span class="variable">invmod</span><span class="operator">(</span><span class="number">42</span><span class="operator">,</span><span class="number">2017</span><span class="operator">);</span>
</code></pre>

<p>Given two integers <code>a</code> and <code>n</code>, return the inverse of <code>a</code> modulo <code>n</code>. If not defined, undef is returned. If defined, then the return value multiplied by <code>a</code> equals <code>1</code> modulo <code>n</code>.</p>

<h2 id="sqrtmod">sqrtmod</h2>

<p>Given two integers <code>a</code> and <code>p</code>, return the square root of <code>a</code> mod <code>p</code>. If no square root exists, undef is returned. If defined, the return value <code>s</code> will always satisfy <code>mulmod(s,s,p) = a</code>.</p>

<p>If <code>p</code> is not a prime, it is possible no result will be returned even though a modular root exists.</p>

<p>Only one root is returned, even though there are at least two. In the case of <code>p</code> a prime and a return value <code>s</code>, then both <code>+s mod n</code> and <code>-s mod n</code> are roots. The least <code>s</code> will be returned. In the case of composites, many roots may exist, but only one will be returned.</p>

<h2 id="addmod">addmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>a</code> and <code>n</code> are unsigned, return <code>(a+b) mod n</code>. This is particularly useful when dealing with numbers that are larger than a half-word but still native size. No bigint package is needed and this can be 10-200x faster than using one.</p>

<h2 id="mulmod">mulmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>a</code> and <code>n</code> are unsigned, return <code>(a*b) mod n</code>. This is particularly useful when <code>n</code> fits in a native integer. No bigint package is needed and this can be 10-200x faster than using one.</p>

<h2 id="powmod">powmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>a</code> and <code>n</code> are unsigned, return <code>(a ** b) mod n</code>. Typically binary exponentiation is used, so the process is very efficient. With native size inputs, no bigint library is needed.</p>

<h2 id="divmod">divmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>a</code> and <code>n</code> are unsigned, return <code>(a/b) mod n</code>. This is done as <code>(a * (1/b mod n)) mod n</code>. If no inverse of <code>b</code> mod <code>n</code> exists then undef if returned.</p>

<h2 id="consecutive_integer_lcm">consecutive_integer_lcm</h2>

<pre><code>  <span class="variable">$lcm</span> <span class="operator">=</span> <span class="variable">consecutive_integer_lcm</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Given an unsigned integer argument, returns the least common multiple of all integers from 1 to <code>n</code>. This can be done by manipulation of the primes up to <code>n</code>, resulting in much faster and memory-friendly results than using factorials.</p>

<h2 id="partitions">partitions</h2>

<p>Calculates the partition function p(n) for a non-negative integer input. This is the number of ways of writing the integer n as a sum of positive integers, without restrictions. This corresponds to Pari&#39;s <code>numbpart</code> function and Mathematica&#39;s <code>PartitionsP</code> function. The values produced in order are <a href="http://oeis.org/A000041">OEIS series A000041</a>.</p>

<p>This uses a combinatorial calculation, which means it will not be very fast compared to Pari, Mathematica, or FLINT which use the Rademacher formula using multi-precision floating point. In 10 seconds, the pure Perl version can produce <code>partitions(10_000)</code> while with <a href="../../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> it can do <code>partitions(220_000)</code>. In contrast, in about 10 seconds Pari can solve <code>numbpart(22_000_000)</code>.</p>

<p>If you want the enumerated partitions, see <a href="../../../../lib/Math/Prime/Util.html#forpart">&quot;forpart&quot; in Math::Prime::Util</a> or <a>Integer::Partition</a>. These are fast and memory efficient iterators, but not practical for producing the partition <i>number</i> for values over 100 or so.</p>

<h2 id="numtoperm">numtoperm</h2>

<pre><code>  <span class="variable">@p</span> <span class="operator">=</span> <span class="variable">numtoperm</span><span class="operator">(</span><span class="number">10</span><span class="operator">,</span><span class="number">654321</span><span class="operator">);</span>  <span class="comment"># @p=(1,8,2,7,6,5,3,4,9,0)</span>
</code></pre>

<p>Given a non-negative integer <code>n</code> and integer <code>k</code>, return the rank <code>k</code> lexicographic permutation of <code>n</code> elements. <code>k</code> will be interpreted as mod <code>n!</code>.</p>

<h2 id="permtonum">permtonum</h2>

<pre><code>  <span class="variable">$k</span> <span class="operator">=</span> <span class="variable">permtonum</span><span class="operator">(</span><span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">7</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">,</span><span class="number">9</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span><span class="operator">);</span>  <span class="comment"># $k = 654321</span>
</code></pre>

<p>Given an array reference containing integers from <code>0</code> to <code>n</code>, returns the lexicographic permutation rank of the set. This is the inverse of the <a href="#numtoperm">&quot;numtoperm&quot;</a> function. All integers up to <code>n</code> must be present. The result will be between <code>0</code> and <code>n!-1</code>.</p>

<h2 id="Pi">Pi</h2>

<p>Takes a positive integer argument <code>n</code> and returns the constant Pi with that many digits (including the leading 3). Rounding is performed.</p>

<p>The implementation uses AGM and is only slightly slower than MPFR (which has tighter bounds on the intermediate bits and exit conditions).</p>

<h2 id="exp_mangoldt">exp_mangoldt</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"exp(lambda(</span><span class="variable">$_</span><span class="string">)) = "</span><span class="operator">,</span> <span class="variable">exp_mangoldt</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Returns EXP(&Lambda;(n)), the exponential of the Mangoldt function (also known as von Mangoldt&#39;s function) for an integer value. The Mangoldt function is equal to log p if n is prime or a power of a prime, and 0 otherwise. We return the exponential so all results are integers. Hence the return value for <code>exp_mangoldt</code> is:</p>

<pre><code>   p   if n = p^m for some prime p and integer m &gt;= 1
   1   otherwise.</code></pre>

<h2 id="totient">totient</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The Euler totient of </span><span class="variable">$n</span><span class="string"> is "</span><span class="operator">,</span> <span class="variable">totient</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns &phi;(n), the Euler totient function (also called Euler&#39;s phi or phi function) for an integer value. This is an arithmetic function which counts the number of positive integers less than or equal to <code>n</code> that are relatively prime to <code>n</code>. Given the definition used, <code>totient</code> will return 0 for all <code>n &lt; 1</code>. This follows the logic used by SAGE. Mathematica and Pari return <code>totient(-n)</code> for <code>n &lt; 0</code>. Mathematica returns 0 for <code>n = 0</code>, Pari pre-2.6.2 raises and exception, and Pari 2.6.2 and newer returns 2.</p>

<h2 id="jordan_totient">jordan_totient</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Jordan's totient J_</span><span class="variable">$k</span><span class="string">(</span><span class="variable">$n</span><span class="string">) is "</span><span class="operator">,</span> <span class="variable">jordan_totient</span><span class="operator">(</span><span class="variable">$k</span><span class="operator">,</span> <span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns Jordan&#39;s totient function for a given integer value. Jordan&#39;s totient is a generalization of Euler&#39;s totient, where <code>jordan_totient(1,$n) == euler_totient($n)</code> This counts the number of k-tuples less than or equal to n that form a coprime tuple with n. As with <code>totient</code>, 0 is returned for all <code>n &lt; 1</code>. This function can be used to generate some other useful functions, such as the Dedekind psi function, where <code>psi(n) = J(2,n) / J(1,n)</code>.</p>

<h2 id="carmichael_lambda">carmichael_lambda</h2>

<p>Returns the Carmichael function (also called the reduced totient function, or Carmichael &lambda;(n)) of a positive integer argument. It is the smallest positive integer <code>m</code> such that <code>a^m = 1 mod n</code> for every integer <code>a</code> coprime to <code>n</code>. This is <a href="http://oeis.org/A002322">OEIS series A002322</a>.</p>

<h2 id="liouville">liouville</h2>

<p>Returns &lambda;(n), the Liouville function for a non-negative integer input. This is -1 raised to &Omega;(n) (the total number of prime factors).</p>

<h2 id="is_power">is_power</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a perfect square"</span> <span class="keyword">if</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a perfect cube"</span> <span class="keyword">if</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a "</span><span class="operator">,</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">),</span> <span class="string">"-th power"</span><span class="operator">;</span>
</code></pre>

<p>Given a single positive integer input <code>n</code>, returns k if <code>n = p^k</code> for some integer <code>p &gt; 1, k &gt; 1</code>, and 0 otherwise. The k returned is the largest possible. This can be used in a boolean statement to determine if <code>n</code> is a perfect power.</p>

<p>If given two arguments <code>n</code> and <code>k</code>, returns 1 if <code>n</code> is a <code>k-th</code> power, and 0 otherwise. For example, if <code>k=2</code> then this detects perfect squares.</p>

<p>This corresponds to Pari/GP&#39;s <code>ispower</code> function, with the limitations of only integer arguments and no third argument may be given to return the root.</p>

<h2 id="is_square">is_square</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a perfect square, 0 otherwise. This is identical to <code>is_power(n,2)</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>issquare</code> function.</p>

<h2 id="is_prime_power">is_prime_power</h2>

<p>Given an integer input <code>n</code>, returns <code>k</code> if <code>n = p^k</code> for some prime p, and zero otherwise.</p>

<p>This corresponds to Pari/GP&#39;s <code>isprimepower</code> function.</p>

<h2 id="sqrtint">sqrtint</h2>

<p>Returns the truncated integer part of the square root of <code>n</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>sqrtint</code> function.</p>

<h2 id="rootint">rootint</h2>

<p>Given <code>n</code> and <code>k</code>, returns the truncated integer part of the <code>k-th</code> root of <code>n</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>sqrtnint</code> function.</p>

<h2 id="logint">logint</h2>

<p>Given <code>n</code> and <code>b</code>, returns the integer base-<code>b</code> logarithm of <code>n</code>. This is the largest integer <code>e</code> such that <code>b^e &lt;= n</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>logint</code> function.</p>

<h2 id="factor">factor</h2>

<pre><code>  <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">factor</span><span class="operator">(</span><span class="number">640552686568398413516426919223357728279912327120302109778516984973296910867431808451611740398561987580967216226094312377767778241368426651540749005659</span><span class="operator">);</span>
  <span class="comment"># Returns an array of 11 factors</span>
</code></pre>

<p>Returns a list of prime factors of a positive number, in numerical order. The special cases of <code>n = 0</code> and <code>n = 1</code> will return <code>n</code>.</p>

<p>Like most advanced factoring programs, a mix of methods is used. This includes trial division for small factors, perfect power detection, Pollard&#39;s Rho, Pollard&#39;s P-1 with various smoothness and stage settings, Hart&#39;s OLF (a Fermat variant), ECM (elliptic curve method), and QS (quadratic sieve). Certainly improvements could be designed for this algorithm (suggestions are welcome).</p>

<p>In practice, this factors 26-digit semiprimes in under <code>100ms</code>, 36-digit semiprimes in under one second. Arbitrary integers are factored faster. It is many orders of magnitude faster than any other factoring module on CPAN circa 2013. It is comparable in speed to Math::Pari&#39;s <code>factorint</code> for most inputs.</p>

<p>If you want better factoring in general, I recommend looking at the standalone programs <a href="http://sourceforge.net/projects/yafu/">yafu</a>, <a href="http://sourceforge.net/projects/msieve/">msieve</a>, <a href="http://ecm.gforge.inria.fr/">gmp-ecm</a>, and <a href="http://sourceforge.net/projects/ggnfs/">GGNFS</a>.</p>

<h2 id="divisors">divisors</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@divisors</span> <span class="operator">=</span> <span class="variable">divisors</span><span class="operator">(</span><span class="number">30</span><span class="operator">);</span>   <span class="comment"># returns (1, 2, 3, 5, 6, 10, 15, 30)</span>
</code></pre>

<p>Produces all the divisors of a positive number input, including 1 and the input number. The divisors are a power set of multiplications of the prime factors, returned as a sorted list with no duplications. The result is identical to that of Pari&#39;s <code>divisors</code> and Mathematica&#39;s <code>Divisors[n]</code> functions.</p>

<p>In scalar context this returns the sigma0 function (OEIS A000005), and is the same result as evaluating the returned array in scalar context (but much more efficient). The result then corresponds to Pari&#39;s <code>numdiv</code> and Mathematica&#39;s <code>DivisorSigma[0,n]</code> functions.</p>

<h2 id="trial_factor">trial_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">trial_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">trial_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using trial division. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional divisor limit may be given as the second parameter. Factoring will stop when the input is a prime, one factor is found, or the input has been tested for divisibility with all primes less than or equal to the limit. If no limit is given, then <code>2**31-1</code> will be used.</p>

<p>This is a good and fast initial test, and will be very fast for small numbers (e.g. under 1 million). For larger numbers, faster methods for complete factoring have been known since the 17th century.</p>

<p>For inputs larger than about 1000 digits, a dynamic product/remainder tree is used, which is faster than GMP&#39;s native methods. This helps when pruning composites or looking for very small factors.</p>

<h2 id="prho_factor">prho_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">prho_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">prho_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">100_000_000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Pollard&#39;s Rho method. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional number of rounds may be given as the second parameter. Factoring will stop when the input is a prime, one factor has been found, or the number of rounds has been exceeded.</p>

<p>This is the Pollard Rho method with <code>f = x^2 + 3</code> and default rounds 64M. It is very good at finding small factors. Typically <a href="#pbrent_factor">&quot;pbrent_factor&quot;</a> will be preferred as it behaves similarly but runs quite a bit faster. They use different parameters however, so are not completely identical.</p>

<h2 id="pbrent_factor">pbrent_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pbrent_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pbrent_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">100_000_000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Pollard&#39;s Rho method with Brent&#39;s algorithm. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional number of rounds may be given as the second parameter. Factoring will stop when the input is a prime, one factor has been found, or the number of rounds has been exceeded.</p>

<p>This is the Pollard Rho method using Brent&#39;s modified cycle detection, delayed <code>gcd</code> computations, and backtracking. It is essentially Algorithm P&#39;&#39;2 from Brent (1980). Parameters used are <code>f = x^2 + 3</code> and default rounds 64M. It is very good at finding small factors.</p>

<h2 id="pminus1_factor">pminus1_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  <span class="comment"># Set B1 smoothness to 10M, second stage automatically set.</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">10_000_000</span><span class="operator">);</span>
  
  <span class="comment"># Run p-1 with B1 = 10M, B2 = 100M.</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">10_000_000</span><span class="operator">,</span> <span class="number">100_000_000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Pollard&#39;s <code>p-1</code> method. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional first stage smoothness factor (B1) may be given as the second parameter. This will be the smoothness limit B1 for the first stage, and will use <code>10*B1</code> for the second stage limit B2. If a third parameter is given, it will be used as the second stage limit B2. Factoring will stop when the input is a prime, one factor has been found, or the algorithm fails to find a factor with the given smoothness.</p>

<p>This is Pollard&#39;s <code>p-1</code> method using a default smoothness of 5M and a second stage of <code>B2 = 10 * B1</code>. It can quickly find a factor <code>p</code> of the input <code>n</code> if the number <code>p-1</code> factors into small primes. For example <code>n = 22095311209999409685885162322219</code> has the factor <code>p = 3916587618943361</code>, where <code>p-1 = 2^7 * 5 * 47 * 59 * 3137 * 703499</code>, so this method will find a factor in the first stage if <code>B1 &gt;= 703499</code> or in the second stage if <code>B1 &gt;= 3137</code> and <code>B2 &gt;= 703499</code>.</p>

<p>The implementation is written from scratch using the basic algorithm including a second stage as described in Montgomery 1987. It is faster than most simple implementations I have seen (many of which are written assuming native precision inputs), but slower than Ben Buhrow&#39;s code used in earlier versions of <a href="http://sourceforge.net/projects/yafu/">yafu</a>, and nowhere close to the speed of the version included with modern GMP-ECM with large B values (it is actually quite a bit faster than GMP-ECM with small smoothness values).</p>

<h2 id="pplus1_factor">pplus1_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pplus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Williams&#39; <code>p+1</code> method. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional first stage smoothness factor (B1) may be given as the second parameter. This will be the smoothness limit B1 for the first stage. Factoring will stop when the input is a prime, one factor has been found, or the algorithm fails to find a factor with the given smoothness.</p>

<h2 id="holf_factor">holf_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">holf_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">holf_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">100_000_000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Hart&#39;s OLF method. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional number of rounds may be given as the second parameter. Factoring will stop when the input is a prime, one factor has been found, or the number of rounds has been exceeded.</p>

<p>This is Hart&#39;s One Line Factorization method, which is a variant of Fermat&#39;s algorithm. A premultiplier of 480 is used. It is very good at factoring numbers that are close to perfect squares, or small numbers. Very naive methods of picking RSA parameters sometimes yield numbers in this form, so it can be useful to run a few rounds to check. For example, the number:</p>

<pre><code>  18548676741817250104151622545580576823736636896432849057 \
  10984160646722888555430591384041316374473729421512365598 \
  29709849969346650897776687202384767704706338162219624578 \
  777915220190863619885201763980069247978050169295918863</code></pre>

<p>was proposed by someone as an RSA key. It is indeed composed of two distinct prime numbers of similar bit length. Most factoring methods will take a <b>very</b> long time to break this. However one factor is almost exactly 5x larger than the other, allowing HOLF to factor this 222-digit semiprime in only a few milliseconds.</p>

<h2 id="squfof_factor">squfof_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">squfof_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">squfof_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">100_000_000</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using Shanks&#39; square forms factorization method (usually known as SQUFOF). The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional number of rounds may be given as the second parameter. Factoring will stop when the input is a prime, one factor has been found, or the number of rounds has been exceeded.</p>

<p>This is Daniel Shanks&#39; SQUFOF (square forms factorization) algorithm. The particular implementation is a non-racing multiple-multiplier version, based on code ideas of Ben Buhrow and Jason Papadopoulos as well as many others. SQUFOF is often the preferred method for small numbers, and <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> as well as many other packages use it was the default method for native size (e.g. 32-bit or 64-bit) numbers after trial division. The GMP version used in this module will work for larger values, but my testing indicates it is generally slower than the <code>prho</code> and <code>pbrent</code> implementations.</p>

<h2 id="ecm_factor">ecm_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">12500</span><span class="operator">);</span>      <span class="comment"># B1 = 12500</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">12500</span><span class="operator">,</span> <span class="number">10</span><span class="operator">);</span>  <span class="comment"># B1 = 12500, curves = 10</span>
</code></pre>

<p>Given a positive number input, tries to discover a factor using ECM. The resulting array will contain either two factors (it succeeded) or the original number (no factor was found). In either case, multiplying @factors yields the original input. An optional maximum smoothness may be given as the second parameter, which relates to the size of factor to search for. An optional third parameter indicates the number of random curves to use at each smoothness value being searched.</p>

<p>This is an implementation of Hendrik Lenstra&#39;s elliptic curve factoring method, usually referred to as ECM. The implementation is reasonable, using projective coordinates, Montgomery&#39;s PRAC heuristic for EC multiplication, and two stages. It is much slower than the latest GMP-ECM, but still quite useful for factoring reasonably sized inputs.</p>

<h2 id="qs_factor">qs_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">qs_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Given a positive number input, tries to discover factors using QS (the quadratic sieve). The resulting array will contain one or more numbers such that multiplying @factors yields the original input. Typically multiple factors will be produced, unlike the other <code>..._factor</code> routines.</p>

<p>The current implementation is a modified version of SIMPQS, a predecessor to the QS in FLINT, and was written by William Hart in 2006. It will not operate on input less than 30 digits. The memory use for large inputs is more than desired, so other methods such as <a href="#pbrent_factor">&quot;pbrent_factor&quot;</a>, <a href="#pminus1_factor">&quot;pminus1_factor&quot;</a>, and <a href="#ecm_factor">&quot;ecm_factor&quot;</a> are recommended to begin with to filter out small factors. However, it is substantially faster than the other methods on large inputs having large factors, and is the method of choice for 35+ digit semiprimes.</p>

<h2 id="todigits">todigits</h2>

<p>Given an integer <code>n</code>, return an array of digits of <code>|n|</code>. An optional second integer argument specifies a base (default 10). For example, given a base of 2, this returns an array of binary digits of <code>n</code>. An optional third argument specifies a length for the returned array. The result will be either have upper digits truncated or have leading zeros added.</p>

<p><code>todigits(0)</code> returns an empty array. The base must be at least 2, and is limited to an int. Length must be at least zero and is limited to an int.</p>

<h2 id="seed_csprng">seed_csprng</h2>

<p>Takes a non-negative integer <code>nbytes</code> and a string <code>data</code> as input. These are used to seed the internal CSPRNG used for random functions, including the random prime functions. Ideally this is 16-256 bytes of good entropy.</p>

<p>Currently the CSPRNG is ISAAC-32, and the maximum number of seed bytes used is 1024. The CSPRNG will likely change to ChaCha20 in a later release.</p>

<h2 id="is_csprng_well_seeded">is_csprng_well_seeded</h2>

<p>Returns true if the CSPRNG has been seeded with 16 or more bytes (128 bits). There is no measurement of how &quot;good&quot; the input was.</p>

<p>On startup the module will attempt to seed the CSPRNG from <code>/dev/urandom</code>, so this function will return true if that was successful, but false otherwise.</p>

<h2 id="urandomb">urandomb</h2>

<pre><code>  <span class="variable">$n32</span> <span class="operator">=</span> <span class="variable">urandomb</span><span class="operator">(</span><span class="number">32</span><span class="operator">);</span>    <span class="comment"># Classic irand32, returns a UV</span>
  <span class="variable">$n</span>   <span class="operator">=</span> <span class="variable">urandomb</span><span class="operator">(</span><span class="number">1024</span><span class="operator">);</span>  <span class="comment"># Random integer less than 2^1024</span>
</code></pre>

<p>Given a number of bits <code>b</code>, returns a random unsigned integer less than <code>2^b</code>. The result will be uniformly distributed between <code>0</code> and <code>2^b-1</code> inclusive.</p>

<p>This is similar to the GMP function <code>mpz_urandomb</code>.</p>

<h2 id="urandomm">urandomm</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">urandomm</span><span class="operator">(</span><span class="number">100</span><span class="operator">);</span>    <span class="comment"># random integer in [0,99]</span>
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">urandomm</span><span class="operator">(</span><span class="number">1024</span><span class="operator">);</span>   <span class="comment"># random integer in [0,1023]</span>
</code></pre>

<p>Given a positive integer <code>n</code>, returns a random unsigned integer less than <code>n</code>. The results will be uniformly distributed between <code>0</code> and <code>n-1</code> inclusive.</p>

<p>This is similar to the GMP function <code>mpz_urandomm</code>.</p>

<h2 id="urandomr">urandomr</h2>

<pre><code>  <span class="variable">$n</span>  <span class="operator">=</span> <span class="variable">urandomr</span><span class="operator">(</span><span class="number">100</span><span class="operator">,</span> <span class="number">110</span><span class="operator">);</span>        <span class="comment"># Random number [100,110]</span>
  <span class="variable">$nb</span> <span class="operator">=</span> <span class="variable">urandomr</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">24</span><span class="operator">,</span><span class="number">2</span><span class="operator">**</span><span class="number">25</span><span class="operator">-</span><span class="number">1</span><span class="operator">);</span>   <span class="comment"># Random 25-bit number</span>
  <span class="variable">$nd</span> <span class="operator">=</span> <span class="variable">urandomr</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">24</span><span class="operator">,</span><span class="number">10</span><span class="operator">**</span><span class="number">25</span><span class="operator">-</span><span class="number">1</span><span class="operator">);</span> <span class="comment"># Random 25-digit number</span>
</code></pre>

<p>Given values <code>low</code> and <code>high</code>, returns a uniform random unsigned integer in the range <code>[low,high]</code>. Both inputs must be non-negative. If <code>low &gt; high</code> then function will return <code>undef</code>. Note that the range is inclusive, so <code>low</code>, <code>high</code>, and each integer between them have an equal probability of appearing.</p>

<h2 id="irand">irand</h2>

<pre><code>  <span class="variable">$n32</span> <span class="operator">=</span> <span class="variable">irand</span><span class="operator">;</span>     <span class="comment"># random 32-bit integer</span>
</code></pre>

<p>Returns a random 32-bit integer using the CSPRNG.</p>

<p>Performance is similar to <a>&quot;rand&quot; in Math::Random::MTwist</a> and <a>Math::Random::Xorshift</a>. It is somewhat faster than casting system <code>rand</code> to a 32-bit int. It is noticeably faster than <a>Math::Random::ISAAC</a>, <a>Math::Random::ISAAC::XS</a>, <a>Math::Random::MT</a>, <a>Math::Random::MT::Auto</a>, and <a>Crypt::PRNG</a>.</p>

<h2 id="irand64">irand64</h2>

<pre><code>  <span class="variable">$n64</span> <span class="operator">=</span> <span class="variable">irand64</span><span class="operator">;</span>   <span class="comment"># random 64-bit integer</span>
</code></pre>

<p>Returns a random 64-bit integer using the CSPRNG (on 64-bit Perl).</p>

<h2 id="drand">drand</h2>

<pre><code>  <span class="variable">$f</span> <span class="operator">=</span> <span class="variable">drand</span><span class="operator">;</span>       <span class="comment"># random floating point value in [0,1)</span>
  <span class="variable">$r</span> <span class="operator">=</span> <span class="variable">drand</span><span class="operator">(</span><span class="number">25</span><span class="operator">);</span>   <span class="comment"># random floating point value in [0,25)</span>
</code></pre>

<p>Returns a random NV (Perl&#39;s native floating point) using the CSPRNG.</p>

<p>The number of bits returned is equal to the mantissa bits of the NV type used for the Perl build, with a max of 64. By default Perl uses doubles and the returned values have 53 bits. If Perl is built with long double support and the long doubles have a larger mantissa, then more bits are used.</p>

<p>This gives <i>substantially</i> better quality random numbers than the default Perl <code>rand</code> function. Among other things, on modern Perl&#39;s, <code>rand</code> uses drand48, which gives 32 bits of decent random values and 16 more bits of known patterns (e.g. the 48th bit alternates, the 47th has a period of 4, etc.). There are much better choices for standard random number generators, such as the Mersenne Twister from <a>Math::Random::MTwist</a>.</p>

<p>Performance is similar to <a>&quot;rand&quot; in Math::Random::MTwist</a> and <a>Math::Random::Xorshift</a>. It is 1.5 - 2x slower than core <code>rand</code> (as are the other modules).</p>

<h2 id="random_bytes">random_bytes</h2>

<pre><code>  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">random_bytes</span><span class="operator">(</span><span class="number">32</span><span class="operator">);</span>     <span class="comment"># 32 random bytes</span>
</code></pre>

<p>Given an unsigned number <code>n</code> of bytes, returns a binary string filled with random data from the CSPRNG. Performance for getting 256 byte strings:</p>

<pre><code>    Module/Method                  Rate   Type
    -------------             ---------   ----------------------
    Data::Entropy::Algorithms    2027/s   CSPRNG - AES Counter
    Crypt::Random                6649/s   CSPRNG - /dev/urandom
    Bytes::Random                9217/s   drand48
    Bytes::Random::Secure       23043/s   CSPRNG - ISAAC
    Math::Random::ISAAC::XS     58377/s   CSPRNG - ISAAC
    rand+pack                   82977/s   drand48
    Crypt::PRNG                298567/s   CSPRNG - Fortuna
    Bytes::Random::XS          383354/s   drand48
    ntheory                    770364/s   CSPRNG - ChaCha20
    Math::Random::MTwist      1890151/s   Mersenne Twister
    Math::Prime::Util::GMP    2045715/s   CSPRNG - ISAAC</code></pre>

<p>Each of the CSPRNG modules should be high quality. There are no known flaws in any of ISAAC, AES CTR, ChaCha20, or Fortuna. The industry seems to be standardizing on ChaCha20 (e.g. BSD, Linux, TLS).</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<dl>

<dt id="Math::Prime::Util-Has-many-more-functions-lots-of-fast-code-for-dealing-with-native-precision-arguments-including-much-faster-primes-using-sieves-and-will-use-this-module-when-needed-for-big-numbers.-Using-Math::Prime::Util-rather-than-this-module-directly-is-recommended"><a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> Has many more functions, lots of fast code for dealing with native-precision arguments (including much faster primes using sieves), and will use this module when needed for big numbers. Using <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> rather than this module directly is recommended.</dt>
<dd>

</dd>
<dt id="Math::Primality-version-0.08-A-Perl-module-with-support-for-the-strong-Miller-Rabin-test-strong-Lucas-Selfridge-test-the-BPSW-probable-prime-test-next_prime-prev_prime-the-AKS-primality-test-and-prime_count.-It-uses-Math::GMPz-to-do-all-the-calculations-so-is-faster-than-pure-Perl-bignums-but-a-lot-slower-than-XS-GMP.-The-prime_count-function-is-only-usable-for-very-small-inputs-but-the-other-functions-are-quite-good-for-big-numbers.-Make-sure-to-use-version-0.05-or-newer"><a>Math::Primality</a> (version 0.08) A Perl module with support for the strong Miller-Rabin test, strong Lucas-Selfridge test, the BPSW probable prime test, next_prime / prev_prime, the AKS primality test, and prime_count. It uses <a>Math::GMPz</a> to do all the calculations, so is faster than pure Perl bignums, but a lot slower than XS+GMP. The prime_count function is only usable for very small inputs, but the other functions are quite good for big numbers. Make sure to use version 0.05 or newer.</dt>
<dd>

</dd>
<dt id="Math::Pari-Supports-quite-a-bit-of-the-same-functionality-and-much-more-.-See-SEE-ALSO-in-Math::Prime::Util-for-more-detailed-information-on-how-the-modules-compare"><a>Math::Pari</a> Supports quite a bit of the same functionality (and much more). See <a href="../../../../lib/Math/Prime/Util.html#SEE-ALSO">&quot;SEE ALSO&quot; in Math::Prime::Util</a> for more detailed information on how the modules compare.</dt>
<dd>

</dd>
<dt id="yafu-msieve-gmp-ecm-GGNFS-Good-general-purpose-factoring-utilities.-These-will-be-faster-than-this-module-and-much-better-as-the-factor-increases-in-size"><a href="http://sourceforge.net/projects/yafu/">yafu</a>, <a href="http://sourceforge.net/projects/msieve/">msieve</a>, <a href="http://ecm.gforge.inria.fr/">gmp-ecm</a>, <a href="http://sourceforge.net/projects/ggnfs/">GGNFS</a> Good general purpose factoring utilities. These will be faster than this module, and <b>much</b> better as the factor increases in size.</dt>
<dd>

</dd>
<dt id="Primo-is-the-state-of-the-art-in-freely-available-though-not-open-source-primality-proving-programs.-If-you-have-1000-digit-numbers-to-prove-you-want-to-use-this"><a href="http://www.ellipsa.eu/public/primo/primo.html">Primo</a> is the state of the art in freely available (though not open source!) primality proving programs. If you have 1000+ digit numbers to prove, you want to use this.</dt>
<dd>

</dd>
<dt id="mpz_aprcl-Open-source-APR-CL-primality-proof-implementation.-Fast-primality-proving-though-without-certificates"><a href="http://sourceforge.net/projects/mpzaprcl/">mpz_aprcl</a> Open source APR-CL primality proof implementation. Fast primality proving, though without certificates.</dt>
<dd>

</dd>
</dl>

<h1 id="REFERENCES">REFERENCES</h1>

<dl>

<dt id="Robert-Baillie-and-Samuel-S.-Wagstaff-Jr.-Lucas-Pseudoprimes-Mathematics-of-Computation-v35-n152-October-1980-pp-1391-1417.-http:-mpqs.free.fr-LucasPseudoprimes.pdf">Robert Baillie and Samuel S. Wagstaff, Jr., &quot;Lucas Pseudoprimes&quot;, Mathematics of Computation, v35 n152, October 1980, pp 1391-1417. <a href="http://mpqs.free.fr/LucasPseudoprimes.pdf">http://mpqs.free.fr/LucasPseudoprimes.pdf</a></dt>
<dd>

</dd>
<dt id="Daniel-J.-Bernstein-Proving-Primality-After-Agrawal-Kayal-Saxena-preprint-Jan-2003.-http:-cr.yp.to-papers-aks.pdf">Daniel J. Bernstein, &quot;Proving Primality After Agrawal-Kayal-Saxena&quot;, preprint, Jan 2003. <a href="http://cr.yp.to/papers/aks.pdf">http://cr.yp.to/papers/aks.pdf</a></dt>
<dd>

</dd>
<dt id="Jon-Grantham-Frobenius-Pseudoprimes-Mathematics-of-Computation-v70-n234-March-2000-pp-873-891.-http:-www.ams.org-journals-mcom-2001-70-234-S0025-5718-00-01197-2">Jon Grantham, &quot;Frobenius Pseudoprimes&quot;, Mathematics of Computation, v70 n234, March 2000, pp 873-891. <a href="http://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/">http://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/</a></dt>
<dd>

</dd>
<dt id="John-Brillhart-D.-H.-Lehmer-and-J.-L.-Selfridge-New-Primality-Criteria-and-Factorizations-of-2-m---1-Mathematics-of-Computation-v29-n130-Apr-1975-pp-620-647.-http:-www.ams.org-journals-mcom-1975-29-130-S0025-5718-1975-0384673-1-S0025-5718-1975-0384673-1.pdf">John Brillhart, D. H. Lehmer, and J. L. Selfridge, &quot;New Primality Criteria and Factorizations of 2^m +/- 1&quot;, Mathematics of Computation, v29, n130, Apr 1975, pp 620-647. <a href="http://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf">http://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf</a></dt>
<dd>

</dd>
<dt id="Richard-P.-Brent-An-improved-Monte-Carlo-factorization-algorithm-BIT-20-1980-pp.-176-184.-http:-www.cs.ox.ac.uk-people-richard.brent-pd-rpb051i.pdf">Richard P. Brent, &quot;An improved Monte Carlo factorization algorithm&quot;, BIT 20, 1980, pp. 176-184. <a href="http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb051i.pdf">http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb051i.pdf</a></dt>
<dd>

</dd>
<dt id="Peter-L.-Montgomery-Speeding-the-Pollard-and-Elliptic-Curve-Methods-of-Factorization-Mathematics-of-Computation-v48-n177-Jan-1987-pp-243-264.-http:-www.ams.org-journals-mcom-1987-48-177-S0025-5718-1987-0866113-7">Peter L. Montgomery, &quot;Speeding the Pollard and Elliptic Curve Methods of Factorization&quot;, Mathematics of Computation, v48, n177, Jan 1987, pp 243-264. <a href="http://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866113-7/">http://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866113-7/</a></dt>
<dd>

</dd>
<dt id="Richard-P.-Brent-Parallel-Algorithms-for-Integer-Factorisation-in-Number-Theory-and-Cryptography-Cambridge-University-Press-1990-pp-26-37.-http:-www.cs.ox.ac.uk-people-richard.brent-pd-rpb115.pdf">Richard P. Brent, &quot;Parallel Algorithms for Integer Factorisation&quot;, in Number Theory and Cryptography, Cambridge University Press, 1990, pp 26-37. <a href="http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb115.pdf">http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb115.pdf</a></dt>
<dd>

</dd>
<dt id="Richard-P.-Brent-Some-Parallel-Algorithms-for-Integer-Factorisation-in-Proc.-Third-Australian-Supercomputer-Conference-1999.-Note:-there-are-multiple-versions-of-this-paper-http:-www.cs.ox.ac.uk-people-richard.brent-pd-rpb193.pdf">Richard P. Brent, &quot;Some Parallel Algorithms for Integer Factorisation&quot;, in Proc. Third Australian Supercomputer Conference, 1999. (Note: there are multiple versions of this paper) <a href="http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb193.pdf">http://www.cs.ox.ac.uk/people/richard.brent/pd/rpb193.pdf</a></dt>
<dd>

</dd>
<dt id="William-B.-Hart-A-One-Line-Factoring-Algorithm-preprint.-http:-wstein.org-home-wstein-www-home-wbhart-onelinefactor.pdf">William B. Hart, &quot;A One Line Factoring Algorithm&quot;, preprint. <a href="http://wstein.org/home/wstein/www/home/wbhart/onelinefactor.pdf">http://wstein.org/home/wstein/www/home/wbhart/onelinefactor.pdf</a></dt>
<dd>

</dd>
<dt id="Daniel-Shanks-SQUFOF-notes-unpublished-notes-transcribed-by-Stephen-McMath.-http:-www.usna.edu-Users-math-wdj-mcmath-shanks_squfof.pdf">Daniel Shanks, &quot;SQUFOF notes&quot;, unpublished notes, transcribed by Stephen McMath. <a href="http://www.usna.edu/Users/math/wdj/mcmath/shanks_squfof.pdf">http://www.usna.edu/Users/math/wdj/mcmath/shanks_squfof.pdf</a></dt>
<dd>

</dd>
<dt id="Jason-E.-Gower-and-Samuel-S.-Wagstaff-Jr-Square-Form-Factorization-Mathematics-of-Computation-v77-2008-pages-551-588.-http:-homes.cerias.purdue.edu-ssw-squfof.pdf">Jason E. Gower and Samuel S. Wagstaff, Jr, &quot;Square Form Factorization&quot;, Mathematics of Computation, v77, 2008, pages 551-588. <a href="http://homes.cerias.purdue.edu/~ssw/squfof.pdf">http://homes.cerias.purdue.edu/~ssw/squfof.pdf</a></dt>
<dd>

</dd>
<dt id="A.O.L.-Atkin-and-F.-Morain-Elliptic-Curves-and-primality-proving-Mathematics-of-Computation-v61-1993-pages-29-68.-http:-www.ams.org-journals-mcom-1993-61-203-S0025-5718-1993-1199989-X">A.O.L. Atkin and F. Morain, &quot;Elliptic Curves and primality proving&quot;, Mathematics of Computation, v61, 1993, pages 29-68. <a href="http://www.ams.org/journals/mcom/1993-61-203/S0025-5718-1993-1199989-X/">http://www.ams.org/journals/mcom/1993-61-203/S0025-5718-1993-1199989-X/</a></dt>
<dd>

</dd>
<dt id="R.G.E.-Pinch-Some-Primality-Testing-Algorithms-June-1993.-Describes-the-primality-testing-methods-used-by-many-CAS-systems-and-how-most-were-compromised.-Gives-recommendations-for-primality-testing-APIs.-http:-citeseerx.ist.psu.edu-viewdoc-summary-doi-10.1.1.33.4409">R.G.E. Pinch, &quot;Some Primality Testing Algorithms&quot;, June 1993. Describes the primality testing methods used by many CAS systems and how most were compromised. Gives recommendations for primality testing APIs. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.4409">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.4409</a></dt>
<dd>

</dd>
</dl>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Dana Jacobsen &lt;dana@acm.org&gt;</p>

<p>William Hart wrote the SIMPQS code which is the basis for the QS code.</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>Obviously none of this would be possible without the mathematicians who created and published their work. Eratosthenes, Gauss, Euler, Riemann, Fermat, Lucas, Baillie, Pollard, Brent, Montgomery, Shanks, Hart, Wagstaff, Dixon, Pomerance, A.K. Lenstra, H. W. Lenstra Jr., Atkin, Knuth, etc.</p>

<p>The GNU GMP team, whose product allows me to concentrate on coding high-level algorithms and not worry about any of the details of how modular exponentiation and the like happen, and still get decent performance for my purposes.</p>

<p>Ben Buhrow and Jason Papadopoulos deserve special mention for their open source factoring tools, which are both readable and fast. In particular I am leveraging their SQUFOF work in the current implementation. They are a huge resource to the community.</p>

<p>Jonathan Leto and Bob Kuo, who wrote and distributed the <a>Math::Primality</a> module on CPAN. Their implementation of BPSW provided the motivation I needed to do it in this module and <a href="../../../../lib/Math/Prime/Util.html">Math::Prime::Util</a>. I also used their module quite a bit for testing against.</p>

<p>Paul Zimmermann&#39;s papers and GMP-ECM code were of great value for my projective ECM implementation, as well as the papers by Brent and Montgomery.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2011-2017 by Dana Jacobsen &lt;dana@acm.org&gt;</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>SIMPQS Copyright 2006, William Hart. SIMPQS is distributed under GPL v2+.</p>


</body>

</html>


