<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#BIGNUM-SUPPORT">BIGNUM SUPPORT</a></li>
  <li><a href="#PRIMALITY-TESTING">PRIMALITY TESTING</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#is_prime">is_prime</a></li>
      <li><a href="#primes">primes</a></li>
      <li><a href="#next_prime">next_prime</a></li>
      <li><a href="#prev_prime">prev_prime</a></li>
      <li><a href="#forprimes">forprimes</a></li>
      <li><a href="#forcomposites">forcomposites</a></li>
      <li><a href="#foroddcomposites">foroddcomposites</a></li>
      <li><a href="#fordivisors">fordivisors</a></li>
      <li><a href="#forpart">forpart</a></li>
      <li><a href="#forcomp">forcomp</a></li>
      <li><a href="#forcomb">forcomb</a></li>
      <li><a href="#forperm">forperm</a></li>
      <li><a href="#forderange">forderange</a></li>
      <li><a href="#formultiperm">formultiperm</a></li>
      <li><a href="#lastfor">lastfor</a></li>
      <li><a href="#prime_iterator">prime_iterator</a></li>
      <li><a href="#prime_iterator_object">prime_iterator_object</a></li>
      <li><a href="#prime_count">prime_count</a></li>
      <li><a href="#prime_count_upper">prime_count_upper</a></li>
      <li><a href="#prime_count_lower">prime_count_lower</a></li>
      <li><a href="#prime_count_approx">prime_count_approx</a></li>
      <li><a href="#twin_primes">twin_primes</a></li>
      <li><a href="#twin_prime_count">twin_prime_count</a></li>
      <li><a href="#twin_prime_count_approx">twin_prime_count_approx</a></li>
      <li><a href="#ramanujan_primes">ramanujan_primes</a></li>
      <li><a href="#ramanujan_prime_count">ramanujan_prime_count</a></li>
      <li><a href="#ramanujan_prime_count_approx">ramanujan_prime_count_approx</a></li>
      <li><a href="#ramanujan_prime_count_lower">ramanujan_prime_count_lower</a></li>
      <li><a href="#ramanujan_prime_count_upper">ramanujan_prime_count_upper</a></li>
      <li><a href="#sieve_range">sieve_range</a></li>
      <li><a href="#sieve_prime_cluster">sieve_prime_cluster</a></li>
      <li><a href="#sum_primes">sum_primes</a></li>
      <li><a href="#print_primes">print_primes</a></li>
      <li><a href="#nth_prime">nth_prime</a></li>
      <li><a href="#nth_prime_upper">nth_prime_upper</a></li>
      <li><a href="#nth_prime_lower">nth_prime_lower</a></li>
      <li><a href="#nth_prime_approx">nth_prime_approx</a></li>
      <li><a href="#nth_twin_prime">nth_twin_prime</a></li>
      <li><a href="#nth_twin_prime_approx">nth_twin_prime_approx</a></li>
      <li><a href="#nth_ramanujan_prime">nth_ramanujan_prime</a></li>
      <li><a href="#nth_ramanujan_prime_approx">nth_ramanujan_prime_approx</a></li>
      <li><a href="#nth_ramanujan_prime_lower">nth_ramanujan_prime_lower</a></li>
      <li><a href="#nth_ramanujan_prime_upper">nth_ramanujan_prime_upper</a></li>
      <li><a href="#is_pseudoprime">is_pseudoprime</a></li>
      <li><a href="#is_euler_pseudoprime">is_euler_pseudoprime</a></li>
      <li><a href="#is_strong_pseudoprime">is_strong_pseudoprime</a></li>
      <li><a href="#is_lucas_pseudoprime">is_lucas_pseudoprime</a></li>
      <li><a href="#is_strong_lucas_pseudoprime">is_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_extra_strong_lucas_pseudoprime">is_extra_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_almost_extra_strong_lucas_pseudoprime">is_almost_extra_strong_lucas_pseudoprime</a></li>
      <li><a href="#is_euler_plumb_pseudoprime">is_euler_plumb_pseudoprime</a></li>
      <li><a href="#is_perrin_pseudoprime">is_perrin_pseudoprime</a></li>
      <li><a href="#is_catalan_pseudoprime">is_catalan_pseudoprime</a></li>
      <li><a href="#is_frobenius_pseudoprime">is_frobenius_pseudoprime</a></li>
      <li><a href="#is_frobenius_underwood_pseudoprime">is_frobenius_underwood_pseudoprime</a></li>
      <li><a href="#is_frobenius_khashin_pseudoprime">is_frobenius_khashin_pseudoprime</a></li>
      <li><a href="#miller_rabin_random">miller_rabin_random</a></li>
      <li><a href="#is_prob_prime">is_prob_prime</a></li>
      <li><a href="#is_bpsw_prime">is_bpsw_prime</a></li>
      <li><a href="#is_provable_prime">is_provable_prime</a></li>
      <li><a href="#prime_certificate">prime_certificate</a></li>
      <li><a href="#is_provable_prime_with_cert">is_provable_prime_with_cert</a></li>
      <li><a href="#verify_prime">verify_prime</a></li>
      <li><a href="#is_aks_prime">is_aks_prime</a></li>
      <li><a href="#is_mersenne_prime">is_mersenne_prime</a></li>
      <li><a href="#is_ramanujan_prime">is_ramanujan_prime</a></li>
      <li><a href="#is_power">is_power</a></li>
      <li><a href="#is_prime_power">is_prime_power</a></li>
      <li><a href="#is_square">is_square</a></li>
      <li><a href="#sqrtint">sqrtint</a></li>
      <li><a href="#rootint">rootint</a></li>
      <li><a href="#logint">logint</a></li>
      <li><a href="#lucasu">lucasu</a></li>
      <li><a href="#lucasv">lucasv</a></li>
      <li><a href="#lucas_sequence">lucas_sequence</a></li>
      <li><a href="#gcd">gcd</a></li>
      <li><a href="#lcm">lcm</a></li>
      <li><a href="#gcdext">gcdext</a></li>
      <li><a href="#chinese">chinese</a></li>
      <li><a href="#vecsum">vecsum</a></li>
      <li><a href="#vecprod">vecprod</a></li>
      <li><a href="#vecmin">vecmin</a></li>
      <li><a href="#vecmax">vecmax</a></li>
      <li><a href="#vecreduce">vecreduce</a></li>
      <li><a href="#vecany">vecany</a></li>
      <li><a href="#vecall">vecall</a></li>
      <li><a href="#vecnone">vecnone</a></li>
      <li><a href="#vecnotall">vecnotall</a></li>
      <li><a href="#vecfirst">vecfirst</a></li>
      <li><a href="#vecfirstidx">vecfirstidx</a></li>
      <li><a href="#vecextract">vecextract</a></li>
      <li><a href="#todigits">todigits</a></li>
      <li><a href="#todigitstring">todigitstring</a></li>
      <li><a href="#fromdigits">fromdigits</a></li>
      <li><a href="#sumdigits">sumdigits</a></li>
      <li><a href="#invmod">invmod</a></li>
      <li><a href="#sqrtmod">sqrtmod</a></li>
      <li><a href="#addmod">addmod</a></li>
      <li><a href="#mulmod">mulmod</a></li>
      <li><a href="#powmod">powmod</a></li>
      <li><a href="#divmod">divmod</a></li>
      <li><a href="#valuation">valuation</a></li>
      <li><a href="#hammingweight">hammingweight</a></li>
      <li><a href="#is_square_free">is_square_free</a></li>
      <li><a href="#is_carmichael">is_carmichael</a></li>
      <li><a href="#is_quasi_carmichael">is_quasi_carmichael</a></li>
      <li><a href="#is_semiprime">is_semiprime</a></li>
      <li><a href="#is_fundamental">is_fundamental</a></li>
      <li><a href="#is_totient">is_totient</a></li>
      <li><a href="#is_pillai">is_pillai</a></li>
      <li><a href="#is_polygonal">is_polygonal</a></li>
      <li><a href="#moebius">moebius</a></li>
      <li><a href="#mertens">mertens</a></li>
      <li><a href="#euler_phi">euler_phi</a></li>
      <li><a href="#jordan_totient">jordan_totient</a></li>
      <li><a href="#ramanujan_sum">ramanujan_sum</a></li>
      <li><a href="#exp_mangoldt">exp_mangoldt</a></li>
      <li><a href="#liouville">liouville</a></li>
      <li><a href="#chebyshev_theta">chebyshev_theta</a></li>
      <li><a href="#chebyshev_psi">chebyshev_psi</a></li>
      <li><a href="#divisor_sum">divisor_sum</a></li>
      <li><a href="#ramanujan_tau">ramanujan_tau</a></li>
      <li><a href="#primorial">primorial</a></li>
      <li><a href="#pn_primorial">pn_primorial</a></li>
      <li><a href="#consecutive_integer_lcm">consecutive_integer_lcm</a></li>
      <li><a href="#partitions">partitions</a></li>
      <li><a href="#carmichael_lambda">carmichael_lambda</a></li>
      <li><a href="#kronecker">kronecker</a></li>
      <li><a href="#factorial">factorial</a></li>
      <li><a href="#factorialmod">factorialmod</a></li>
      <li><a href="#binomial">binomial</a></li>
      <li><a href="#hclassno">hclassno</a></li>
      <li><a href="#bernfrac">bernfrac</a></li>
      <li><a href="#bernreal">bernreal</a></li>
      <li><a href="#stirling">stirling</a></li>
      <li><a href="#harmfrac">harmfrac</a></li>
      <li><a href="#harmreal">harmreal</a></li>
      <li><a href="#znorder">znorder</a></li>
      <li><a href="#znprimroot">znprimroot</a></li>
      <li><a href="#is_primitive_root">is_primitive_root</a></li>
      <li><a href="#znlog">znlog</a></li>
      <li><a href="#legendre_phi">legendre_phi</a></li>
      <li><a href="#inverse_li">inverse_li</a></li>
      <li><a href="#numtoperm">numtoperm</a></li>
      <li><a href="#permtonum">permtonum</a></li>
      <li><a href="#randperm">randperm</a></li>
      <li><a href="#shuffle">shuffle</a></li>
    </ul>
  </li>
  <li><a href="#RANDOM-NUMBERS">RANDOM NUMBERS</a>
    <ul>
      <li><a href="#OVERVIEW">OVERVIEW</a></li>
      <li><a href="#irand">irand</a></li>
      <li><a href="#irand64">irand64</a></li>
      <li><a href="#drand">drand</a></li>
      <li><a href="#random_bytes">random_bytes</a></li>
      <li><a href="#entropy_bytes">entropy_bytes</a></li>
      <li><a href="#urandomb">urandomb</a></li>
      <li><a href="#urandomm">urandomm</a></li>
      <li><a href="#csrand">csrand</a></li>
      <li><a href="#srand">srand</a></li>
      <li><a href="#rand">rand</a></li>
    </ul>
  </li>
  <li><a href="#RANDOM-PRIMES">RANDOM PRIMES</a>
    <ul>
      <li><a href="#random_prime">random_prime</a></li>
      <li><a href="#random_ndigit_prime">random_ndigit_prime</a></li>
      <li><a href="#random_nbit_prime">random_nbit_prime</a></li>
      <li><a href="#random_strong_prime">random_strong_prime</a></li>
      <li><a href="#random_proven_prime">random_proven_prime</a></li>
      <li><a href="#random_proven_prime_with_cert">random_proven_prime_with_cert</a></li>
      <li><a href="#random_maurer_prime">random_maurer_prime</a></li>
      <li><a href="#random_maurer_prime_with_cert">random_maurer_prime_with_cert</a></li>
      <li><a href="#random_shawe_taylor_prime">random_shawe_taylor_prime</a></li>
      <li><a href="#random_shawe_taylor_prime_with_cert">random_shawe_taylor_prime_with_cert</a></li>
      <li><a href="#random_semiprime">random_semiprime</a></li>
      <li><a href="#random_unrestricted_semiprime">random_unrestricted_semiprime</a></li>
    </ul>
  </li>
  <li><a href="#UTILITY-FUNCTIONS">UTILITY FUNCTIONS</a>
    <ul>
      <li><a href="#prime_precalc">prime_precalc</a></li>
      <li><a href="#prime_memfree">prime_memfree</a></li>
      <li><a href="#Math::Prime::Util::MemFree-new">Math::Prime::Util::MemFree-&gt;new</a></li>
      <li><a href="#prime_get_config">prime_get_config</a></li>
      <li><a href="#prime_set_config">prime_set_config</a></li>
    </ul>
  </li>
  <li><a href="#FACTORING-FUNCTIONS">FACTORING FUNCTIONS</a>
    <ul>
      <li><a href="#factor">factor</a></li>
      <li><a href="#factor_exp">factor_exp</a></li>
      <li><a href="#divisors">divisors</a></li>
      <li><a href="#trial_factor">trial_factor</a></li>
      <li><a href="#fermat_factor">fermat_factor</a></li>
      <li><a href="#holf_factor">holf_factor</a></li>
      <li><a href="#lehman_factor">lehman_factor</a></li>
      <li><a href="#squfof_factor">squfof_factor</a></li>
      <li><a href="#prho_factor">prho_factor</a></li>
      <li><a href="#pbrent_factor">pbrent_factor</a></li>
      <li><a href="#pminus1_factor">pminus1_factor</a></li>
      <li><a href="#pplus1_factor">pplus1_factor</a></li>
      <li><a href="#ecm_factor">ecm_factor</a></li>
    </ul>
  </li>
  <li><a href="#MATHEMATICAL-FUNCTIONS">MATHEMATICAL FUNCTIONS</a>
    <ul>
      <li><a href="#ExponentialIntegral">ExponentialIntegral</a></li>
      <li><a href="#LogarithmicIntegral">LogarithmicIntegral</a></li>
      <li><a href="#RiemannZeta">RiemannZeta</a></li>
      <li><a href="#RiemannR">RiemannR</a></li>
      <li><a href="#LambertW">LambertW</a></li>
      <li><a href="#Pi">Pi</a></li>
    </ul>
  </li>
  <li><a href="#EXAMPLES">EXAMPLES</a></li>
  <li><a href="#PRIMALITY-TESTING-NOTES">PRIMALITY TESTING NOTES</a></li>
  <li><a href="#LIMITATIONS">LIMITATIONS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#PERFORMANCE">PERFORMANCE</a>
    <ul>
      <li><a href="#PRIME-COUNTS">PRIME COUNTS</a></li>
      <li><a href="#PRIMALITY-TESTING1">PRIMALITY TESTING</a></li>
      <li><a href="#FACTORING">FACTORING</a></li>
      <li><a href="#PRIMALITY-PROVING">PRIMALITY PROVING</a></li>
      <li><a href="#RANDOM-PRIME-GENERATION">RANDOM PRIME GENERATION</a></li>
    </ul>
  </li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#REFERENCES">REFERENCES</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Math::Prime::Util - Utilities related to prime numbers, including fast sieves and factoring</p>

<h1 id="VERSION">VERSION</h1>

<p>Version 0.69</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  <span class="comment"># Nothing is exported by default.  List the functions, or use :all.</span>
  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">':all'</span><span class="operator">;</span>  <span class="comment"># import all functions</span>
  
  <span class="comment"># The ':rand' tag replaces srand and rand (not done by default)</span>
  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">':rand'</span><span class="operator">;</span>  <span class="comment"># import srand, rand, irand, irand64</span>
  
  
  <span class="comment"># Get a big array reference of many primes</span>
  <span class="keyword">my</span> <span class="variable">$aref</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">100_000_000</span> <span class="operator">);</span>
  
  <span class="comment"># All the primes between 5k and 10k inclusive</span>
  <span class="variable">$aref</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">5_000</span><span class="operator">,</span> <span class="number">10_000</span> <span class="operator">);</span>
  
  <span class="comment"># If you want them in an array instead</span>
  <span class="keyword">my</span> <span class="variable">@primes</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">primes</span><span class="operator">(</span> <span class="number">500</span> <span class="operator">)</span><span class="operator">}</span><span class="operator">;</span>
  
  <span class="comment"># You can do something for every prime in a range.  Twin primes to 10k:</span>
  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">+</span><span class="number">2</span><span class="operator">)</span> <span class="operator">}</span> <span class="number">10000</span><span class="operator">;</span>
  <span class="comment"># Or for the composites in a range</span>
  <span class="variable">forcomposites</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="keyword">if</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span><span class="number">2</span><span class="operator">)</span> <span class="operator">}</span> <span class="number">10000</span><span class="operator">,</span> <span class="number">10</span><span class="operator">**</span><span class="number">6</span><span class="operator">;</span>
  
  <span class="comment"># For non-bigints, is_prime and is_prob_prime will always be 0 or 2.</span>
  <span class="comment"># They return 0 (composite), 2 (prime), or 1 (probably prime)</span>
  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="number">1000003</span><span class="operator">;</span>  <span class="comment"># for example</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is prime"</span>  <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is "</span><span class="operator">,</span> <span class="operator">(</span><span class="string">qw(composite maybe_prime? prime)</span><span class="operator">)</span><span class="operator">[</span><span class="variable">is_prob_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span><span class="operator">]</span><span class="operator">;</span>
  
  <span class="comment"># Strong pseudoprime test with multiple bases, using Miller-Rabin</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or 2/7/61-psp"</span> <span class="keyword">if</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">61</span><span class="operator">);</span>
  
  <span class="comment"># Standard and strong Lucas-Selfridge, and extra strong Lucas tests</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or lpsp"</span>   <span class="keyword">if</span> <span class="variable">is_lucas_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or slpsp"</span>  <span class="keyword">if</span> <span class="variable">is_strong_lucas_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a prime or eslpsp"</span> <span class="keyword">if</span> <span class="variable">is_extra_strong_lucas_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  <span class="comment"># step to the next prime (returns 0 if not using bigints and we'd overflow)</span>
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">next_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  <span class="comment"># step back (returns undef if given input 2 or less)</span>
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">prev_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  
  <span class="comment"># Return Pi(n) -- the number of primes E&lt;lt&gt;= n.</span>
  <span class="keyword">my</span> <span class="variable">$primepi</span> <span class="operator">=</span> <span class="variable">prime_count</span><span class="operator">(</span> <span class="number">1_000_000</span> <span class="operator">);</span>
  <span class="variable">$primepi</span> <span class="operator">=</span> <span class="variable">prime_count</span><span class="operator">(</span> <span class="number">10</span><span class="operator">**</span><span class="number">14</span><span class="operator">,</span> <span class="number">10</span><span class="operator">**</span><span class="number">14</span><span class="operator">+</span><span class="number">1000</span> <span class="operator">);</span>  <span class="comment"># also does ranges</span>
  
  <span class="comment"># Quickly return an approximation to Pi(n)</span>
  <span class="keyword">my</span> <span class="variable">$approx_number_of_primes</span> <span class="operator">=</span> <span class="variable">prime_count_approx</span><span class="operator">(</span> <span class="number">10</span><span class="operator">**</span><span class="number">17</span> <span class="operator">);</span>
  
  <span class="comment"># Lower and upper bounds.  lower &lt;= Pi(n) &lt;= upper for all n</span>
  <span class="keyword">die</span> <span class="keyword">unless</span> <span class="variable">prime_count_lower</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">&lt;=</span> <span class="variable">prime_count</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">die</span> <span class="keyword">unless</span> <span class="variable">prime_count_upper</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="variable">prime_count</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  
  <span class="comment"># Return p_n, the nth prime</span>
  <span class="keyword">say</span> <span class="string">"The ten thousandth prime is "</span><span class="operator">,</span> <span class="variable">nth_prime</span><span class="operator">(</span><span class="number">10_000</span><span class="operator">);</span>
  
  <span class="comment"># Return a quick approximation to the nth prime</span>
  <span class="keyword">say</span> <span class="string">"The one trillionth prime is ~ "</span><span class="operator">,</span> <span class="variable">nth_prime_approx</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">12</span><span class="operator">);</span>
  
  <span class="comment"># Lower and upper bounds.   lower &lt;= nth_prime(n) &lt;= upper for all n</span>
  <span class="keyword">die</span> <span class="keyword">unless</span> <span class="variable">nth_prime_lower</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">&lt;=</span> <span class="variable">nth_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">die</span> <span class="keyword">unless</span> <span class="variable">nth_prime_upper</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="variable">nth_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  
  <span class="comment"># Get the prime factors of a number</span>
  <span class="keyword">my</span> <span class="variable">@prime_factors</span> <span class="operator">=</span> <span class="variable">factor</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>
  
  <span class="comment"># Return ([p1,e1],[p2,e2], ...) for $n = p1^e1 * p2*e2 * ...</span>
  <span class="keyword">my</span> <span class="variable">@pe</span> <span class="operator">=</span> <span class="variable">factor_exp</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>
  
  <span class="comment"># Get all divisors other than 1 and n</span>
  <span class="keyword">my</span> <span class="variable">@divisors</span> <span class="operator">=</span> <span class="variable">divisors</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>
  <span class="comment"># Or just apply a block for each one</span>
  <span class="keyword">my</span> <span class="variable">$sum</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">fordivisors</span>  <span class="operator">{</span> <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$_</span> <span class="operator">+</span> <span class="variable">$_</span><span class="operator">*</span><span class="variable">$_</span> <span class="operator">}</span>  <span class="variable">$n</span><span class="operator">;</span>
  
  <span class="comment"># Euler phi (Euler's totient) on a large number</span>
  <span class="keyword">use</span> <span class="variable">bigint</span><span class="operator">;</span>  <span class="keyword">say</span> <span class="variable">euler_phi</span><span class="operator">(</span> <span class="number">801294088771394680000412</span> <span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">jordan_totient</span><span class="operator">(</span><span class="number">5</span><span class="operator">,</span> <span class="number">1234</span><span class="operator">);</span>  <span class="comment"># Jordan's totient</span>
  
  <span class="comment"># Moebius function used to calculate Mertens</span>
  <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">200</span><span class="operator">);</span> <span class="keyword">say</span> <span class="string">"Mertens(200) = </span><span class="variable">$sum</span><span class="string">"</span><span class="operator">;</span>
  <span class="comment"># Mertens function directly (more efficient for large values)</span>
  <span class="keyword">say</span> <span class="variable">mertens</span><span class="operator">(</span><span class="number">10_000_000</span><span class="operator">);</span>
  <span class="comment"># Exponential of Mangoldt function</span>
  <span class="keyword">say</span> <span class="string">"lamba(49) = "</span><span class="operator">,</span> <span class="keyword">log</span><span class="operator">(</span><span class="variable">exp_mangoldt</span><span class="operator">(</span><span class="number">49</span><span class="operator">));</span>
  <span class="comment"># Some more number theoretical functions</span>
  <span class="keyword">say</span> <span class="variable">liouville</span><span class="operator">(</span><span class="number">4292384</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">chebyshev_psi</span><span class="operator">(</span><span class="number">234984</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">chebyshev_theta</span><span class="operator">(</span><span class="number">92384234</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">partitions</span><span class="operator">(</span><span class="number">1000</span><span class="operator">);</span>
  <span class="comment"># Show all prime partitions of 25</span>
  <span class="variable">forpart</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@_</span><span class="string">"</span> <span class="keyword">unless</span> <span class="keyword">scalar</span> <span class="keyword">grep</span> <span class="operator">{</span> <span class="operator">!</span><span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@_</span> <span class="operator">}</span> <span class="number">25</span><span class="operator">;</span>
  <span class="comment"># List all 3-way combinations of an array</span>
  <span class="keyword">my</span> <span class="variable">@cdata</span> <span class="operator">=</span> <span class="string">qw/apple bread curry donut eagle/</span><span class="operator">;</span>
  <span class="variable">forcomb</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@cdata</span><span class="string">[</span><span class="variable">@_</span><span class="string">]"</span> <span class="operator">}</span> <span class="variable">@cdata</span><span class="operator">,</span> <span class="number">3</span><span class="operator">;</span>
  <span class="comment"># or all permutations</span>
  <span class="variable">forperm</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@cdata</span><span class="string">[</span><span class="variable">@_</span><span class="string">]"</span> <span class="operator">}</span> <span class="variable">@cdata</span><span class="operator">;</span>
  
  <span class="comment"># divisor sum</span>
  <span class="keyword">my</span> <span class="variable">$sigma</span>  <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>       <span class="comment"># sum of divisors</span>
  <span class="keyword">my</span> <span class="variable">$sigma0</span> <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span><span class="operator">,</span> <span class="number">0</span> <span class="operator">);</span>    <span class="comment"># count of divisors</span>
  <span class="keyword">my</span> <span class="variable">$sigmak</span> <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span><span class="operator">,</span> <span class="variable">$k</span> <span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sigmaf</span> <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span><span class="operator">,</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">log</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">}</span> <span class="operator">);</span> <span class="comment"># arbitrary func</span>
  
  <span class="comment"># primorial n#, primorial p(n)#, and lcm</span>
  <span class="keyword">say</span> <span class="string">"The product of primes below 47 is "</span><span class="operator">,</span>     <span class="variable">primorial</span><span class="operator">(</span><span class="number">47</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"The product of the first 47 primes is "</span><span class="operator">,</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="number">47</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"lcm(1..1000) is "</span><span class="operator">,</span> <span class="variable">consecutive_integer_lcm</span><span class="operator">(</span><span class="number">1000</span><span class="operator">);</span>
  
  <span class="comment"># Ei, li, and Riemann R functions</span>
  <span class="keyword">my</span> <span class="variable">$ei</span>   <span class="operator">=</span> <span class="variable">ExponentialIntegral</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>   <span class="comment"># $x a real: $x != 0</span>
  <span class="keyword">my</span> <span class="variable">$li</span>   <span class="operator">=</span> <span class="variable">LogarithmicIntegral</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>   <span class="comment"># $x a real: $x &gt;= 0</span>
  <span class="keyword">my</span> <span class="variable">$R</span>    <span class="operator">=</span> <span class="variable">RiemannR</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>              <span class="comment"># $x a real: $x &gt; 0</span>
  <span class="keyword">my</span> <span class="variable">$Zeta</span> <span class="operator">=</span> <span class="variable">RiemannZeta</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>           <span class="comment"># $x a real: $x &gt;= 0</span>
  
  
  <span class="comment"># Precalculate a sieve, possibly speeding up later work.</span>
  <span class="variable">prime_precalc</span><span class="operator">(</span> <span class="number">1_000_000_000</span> <span class="operator">);</span>
  
  <span class="comment"># Free any memory used by the module.</span>
  <span class="variable">prime_memfree</span><span class="operator">;</span>
  
  <span class="comment"># Alternate way to free.  When this leaves scope, memory is freed.</span>
  <span class="keyword">my</span> <span class="variable">$mf</span> <span class="operator">=</span> <span class="variable">Math::Prime::Util::MemFree</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  
  <span class="comment"># Random primes</span>
  <span class="keyword">my</span><span class="operator">(</span><span class="variable">$rand_prime</span><span class="operator">);</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_prime</span><span class="operator">(</span><span class="number">1000</span><span class="operator">);</span>        <span class="comment"># random prime &lt;= limit</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_prime</span><span class="operator">(</span><span class="number">100</span><span class="operator">,</span> <span class="number">10000</span><span class="operator">);</span>  <span class="comment"># random prime within a range</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_ndigit_prime</span><span class="operator">(</span><span class="number">6</span><span class="operator">);</span>    <span class="comment"># random 6-digit prime</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_nbit_prime</span><span class="operator">(</span><span class="number">128</span><span class="operator">);</span>    <span class="comment"># random 128-bit prime</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_strong_prime</span><span class="operator">(</span><span class="number">256</span><span class="operator">);</span>  <span class="comment"># random 256-bit strong prime</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_maurer_prime</span><span class="operator">(</span><span class="number">256</span><span class="operator">);</span>  <span class="comment"># random 256-bit provable prime</span>
  <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_shawe_taylor_prime</span><span class="operator">(</span><span class="number">256</span><span class="operator">);</span>  <span class="comment"># as above</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>A module for number theory in Perl. This includes prime sieving, primality tests, primality proofs, integer factoring, counts / bounds / approximations for primes, nth primes, and twin primes, random prime generation, and much more.</p>

<p>This module is the fastest on CPAN for almost all operations it supports. This includes <a>Math::Prime::XS</a>, <a>Math::Prime::FastSieve</a>, <a>Math::Factor::XS</a>, <a>Math::Prime::TiedArray</a>, <a>Math::Big::Factors</a>, <a>Math::Factoring</a>, and <a>Math::Primality</a> (when the GMP module is available). For numbers in the 10-20 digit range, it is often orders of magnitude faster. Typically it is faster than <a>Math::Pari</a> for 64-bit operations.</p>

<p>All operations support both Perl UV&#39;s (32-bit or 64-bit) and bignums. If you want high performance with big numbers (larger than Perl&#39;s native 32-bit or 64-bit size), you should install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> and <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a>. This will be a recurring theme throughout this documentation -- while all bignum operations are supported in pure Perl, most methods will be much slower than the C+GMP alternative.</p>

<p>The module is thread-safe and allows concurrency between Perl threads while still sharing a prime cache. It is not itself multi-threaded. See the <a href="#LIMITATIONS">Limitations</a> section if you are using Win32 and threads in your program. Also note that <a>Math::Pari</a> is not thread-safe (and will crash as soon as it is loaded in threads), so if you use <a>Math::BigInt::Pari</a> rather than <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> or the default backend, things will go pear-shaped.</p>

<p>Two scripts are also included and installed by default:</p>

<ul>

<li><p>primes.pl displays primes between start and end values or expressions, with many options for filtering (e.g. twin, safe, circular, good, lucky, etc.). Use <code>--help</code> to see all the options.</p>

</li>
<li><p>factor.pl operates similar to the GNU <code>factor</code> program. It supports bigint and expression inputs.</p>

</li>
</ul>

<h1 id="BIGNUM-SUPPORT">BIGNUM SUPPORT</h1>

<p>By default all functions support bignums. For performance, you should install and use <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> or <a>Math::BigInt::Pari</a>, and <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>.</p>

<p>If you are using bigints, here are some performance suggestions:</p>

<ul>

<li><p>Install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>, as that will vastly increase the speed of many of the functions. This does require the <a href="http://gmplib.org">GMP</a> library be installed on your system, but this increasingly comes pre-installed or easily available using the OS vendor package installation tool.</p>

</li>
<li><p>Install and use <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> or <a>Math::BigInt::Pari</a>, then use <code>use bigint try =&gt; &#39;GMP,Pari&#39;</code> in your script, or on the command line <code>-Mbigint=lib,GMP</code>. Large modular exponentiation is much faster using the GMP or Pari backends, as are the math and approximation functions when called with very large inputs.</p>

</li>
<li><p>Install <a>Math::MPFR</a> if you use the Ei, li, Zeta, or R functions. If that module can be loaded, these functions will run much faster on bignum inputs, and are able to provide higher accuracy.</p>

</li>
<li><p>I have run these functions on many versions of Perl, and my experience is that if you&#39;re using anything older than Perl 5.14, I would recommend you upgrade if you are using bignums a lot. There are some brittle behaviors on 5.12.4 and earlier with bignums. For example, the default BigInt backend in older versions of Perl will sometimes convert small results to doubles, resulting in corrupted output.</p>

</li>
</ul>

<h1 id="PRIMALITY-TESTING">PRIMALITY TESTING</h1>

<p>This module provides three functions for general primality testing, as well as numerous specialized functions. The three main functions are: <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> and <a href="#is_prime">&quot;is_prime&quot;</a> for general use, and <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> for proofs. For inputs below <code>2^64</code> the functions are identical and fast deterministic testing is performed. That is, the results will always be correct and should take at most a few microseconds for any input. This is hundreds to thousands of times faster than other CPAN modules. For inputs larger than <code>2^64</code>, an extra-strong <a href="http://en.wikipedia.org/wiki/Baillie-PSW_primality_test">BPSW test</a> is used. See the <a href="#PRIMALITY-TESTING-NOTES">&quot;PRIMALITY TESTING NOTES&quot;</a> section for more discussion.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="is_prime">is_prime</h2>

<pre><code>  <span class="keyword">print</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is prime"</span> <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns 0 is the number is composite, 1 if it is probably prime, and 2 if it is definitely prime. For numbers smaller than <code>2^64</code> it will only return 0 (composite) or 2 (definitely prime), as this range has been exhaustively tested and has no counterexamples. For larger numbers, an extra-strong BPSW test is used. If <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> is installed, some additional primality tests are also performed, and a quick attempt is made to perform a primality proof, so it will return 2 for many other inputs.</p>

<p>Also see the <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> function, which will never do additional tests, and the <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> function which will construct a proof that the input is number prime and returns 2 for almost all primes (at the expense of speed).</p>

<p>For native precision numbers (anything smaller than <code>2^64</code>, all three functions are identical and use a deterministic set of tests (selected Miller-Rabin bases or BPSW). For larger inputs both <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> and <a href="#is_prime">&quot;is_prime&quot;</a> return probable prime results using the extra-strong Baillie-PSW test, which has had no counterexample found since it was published in 1980.</p>

<p>For cryptographic key generation, you may want even more testing for probable primes (NIST recommends some additional M-R tests). This can be done using a different test (e.g. <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a>) or using additional M-R tests with random bases with <a href="#miller_rabin_random">&quot;miller_rabin_random&quot;</a>. Even better, make sure <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> is installed and use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> which should be reasonably fast for sizes under 2048 bits. Another possibility is to use <a href="../../../lib/Math/Prime/Util.html#random_maurer_prime">&quot;random_maurer_prime&quot; in Math::Prime::Util</a> or <a href="../../../lib/Math/Prime/Util.html#random_shawe_taylor_prime">&quot;random_shawe_taylor_prime&quot; in Math::Prime::Util</a> which construct random provable primes.</p>

<h2 id="primes">primes</h2>

<p>Returns all the primes between the lower and upper limits (inclusive), with a lower limit of <code>2</code> if none is given.</p>

<p>An array reference is returned (with large lists this is much faster and uses less memory than returning an array directly).</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$aref1</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">1_000_000</span> <span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$aref2</span> <span class="operator">=</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">1_000_000_000_000</span><span class="operator">,</span> <span class="number">1_000_000_001_000</span> <span class="operator">);</span>
  
  <span class="keyword">my</span> <span class="variable">@primes</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span> <span class="variable">primes</span><span class="operator">(</span> <span class="number">500</span> <span class="operator">)</span> <span class="operator">}</span><span class="operator">;</span>
  
  <span class="keyword">print</span> <span class="string">"</span><span class="variable">$_</span><span class="string">\n"</span> <span class="keyword">for</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">primes</span><span class="operator">(</span><span class="number">20</span><span class="operator">,</span><span class="number">100</span><span class="operator">)</span><span class="operator">}</span><span class="operator">;</span>
</code></pre>

<p>Sieving will be done if required. The algorithm used will depend on the range and whether a sieve result already exists. Possibilities include primality testing (for very small ranges), a Sieve of Eratosthenes using wheel factorization, or a segmented sieve.</p>

<h2 id="next_prime">next_prime</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">next_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns the next prime greater than the input number. The result will be a bigint if it can not be exactly represented in the native int type (larger than <code>4,294,967,291</code> in 32-bit Perl; larger than <code>18,446,744,073,709,551,557</code> in 64-bit).</p>

<h2 id="prev_prime">prev_prime</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">prev_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns the prime preceding the input number (i.e. the largest prime that is strictly less than the input). <code>undef</code> is returned if the input is <code>2</code> or lower.</p>

<p>The behavior in various programs of the <i>previous prime</i> function is varied. Pari/GP and <a>Math::Pari</a> returns the input if it is prime, as does <a>&quot;nearest_le&quot; in Math::Prime::FastSieve</a>. When given an input such that the return value will be the first prime less than <code>2</code>, <a>Math::Prime::FastSieve</a>, <a>Math::Pari</a>, Pari/GP, and older versions of MPU will return <code>0</code>. <a>Math::Primality</a> and the current MPU will return <code>undef</code>. WolframAlpha returns <code>-2</code>. Maple gives a range error.</p>

<h2 id="forprimes">forprimes</h2>

<pre><code>  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="operator">}</span> <span class="number">100</span><span class="operator">,</span><span class="number">200</span><span class="operator">;</span>                  <span class="comment"># print primes from 100 to 200</span>
  
  <span class="variable">$sum</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span>  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$_</span> <span class="operator">}</span> <span class="number">100000</span><span class="operator">;</span>   <span class="comment"># sum primes to 100k</span>
  
  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">+</span><span class="number">2</span><span class="operator">)</span> <span class="operator">}</span> <span class="number">10000</span><span class="operator">;</span>  <span class="comment"># print twin primes to 10k</span>
</code></pre>

<p>Given a block and either an end count or a start and end pair, calls the block for each prime in the range. Compared to getting a big array of primes and iterating through it, this is more memory efficient and perhaps more convenient. This will almost always be the fastest way to loop over a range of primes. Nesting and use in threads are allowed.</p>

<p>Math::BigInt objects may be used for the range.</p>

<p>For some uses an iterator (<a href="#prime_iterator">&quot;prime_iterator&quot;</a>, <a href="#prime_iterator_object">&quot;prime_iterator_object&quot;</a>) or a tied array (<a href="../../../lib/Math/Prime/Util/PrimeArray.html">Math::Prime::Util::PrimeArray</a>) may be more convenient. Objects can be passed to functions, and allow early loop exits.</p>

<h2 id="forcomposites">forcomposites</h2>

<pre><code>  <span class="variable">forcomposites</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="operator">}</span> <span class="number">1000</span><span class="operator">;</span>
  <span class="variable">forcomposites</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="operator">}</span> <span class="number">2000</span><span class="operator">,</span><span class="number">2020</span><span class="operator">;</span>
</code></pre>

<p>Given a block and either an end number or a start and end pair, calls the block for each composite in the inclusive range. The composites, <a href="http://oeis.org/A002808">OEIS A002808</a>, are the numbers greater than 1 which are not prime: <code>4, 6, 8, 9, 10, 12, 14, 15, ...</code>.</p>

<h2 id="foroddcomposites">foroddcomposites</h2>

<p>Similar to <a href="#forcomposites">&quot;forcomposites&quot;</a>, but skipping all even numbers. The odd composites, <a href="http://oeis.org/A071904">OEIS A071904</a>, are the numbers greater than 1 which are not prime and not divisible by two: <code>9, 15, 21, 25, 27, 33, 35, ...</code>.</p>

<h2 id="fordivisors">fordivisors</h2>

<pre><code>  <span class="variable">fordivisors</span> <span class="operator">{</span> <span class="variable">$prod</span> <span class="operator">*=</span> <span class="variable">$_</span> <span class="operator">}</span> <span class="variable">$n</span><span class="operator">;</span>
</code></pre>

<p>Given a block and a non-negative number <code>n</code>, the block is called with <code>$_</code> set to each divisor in sorted order. Also see <a href="#divisor_sum">&quot;divisor_sum&quot;</a>.</p>

<h2 id="forpart">forpart</h2>

<pre><code>  <span class="variable">forpart</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@_</span><span class="string">"</span> <span class="operator">}</span> <span class="number">25</span><span class="operator">;</span>           <span class="comment"># unrestricted partitions</span>
  <span class="variable">forpart</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@_</span><span class="string">"</span> <span class="operator">}</span> <span class="number">25</span><span class="operator">,</span><span class="operator">{</span><span class="string">n</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">}</span>     <span class="comment"># ... with exactly 5 values</span>
  <span class="variable">forpart</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@_</span><span class="string">"</span> <span class="operator">}</span> <span class="number">25</span><span class="operator">,</span><span class="operator">{</span><span class="string">nmax</span><span class="operator">=&gt;</span><span class="number">5</span><span class="operator">}</span>  <span class="comment"># ... with &lt;=5 values</span>
</code></pre>

<p>Given a non-negative number <code>n</code>, the block is called with <code>@_</code> set to the array of additive integer partitions. The operation is very similar to the <code>forpart</code> function in Pari/GP 2.6.x, though the ordering is different. The ordering is lexicographic. Use <a href="#partitions">&quot;partitions&quot;</a> to get just the count of unrestricted partitions.</p>

<p>An optional hash reference may be given to produce restricted partitions. Each value must be a non-negative integer. The allowable keys are:</p>

<pre><code>  n       restrict to exactly this many values
  amin    all elements must be at least this value
  amax    all elements must be at most this value
  nmin    the array must have at least this many values
  nmax    the array must have at most this many values
  prime   all elements must be prime (non-zero) or non-prime (zero)</code></pre>

<p>Like forcomb and forperm, the partition return values are read-only. Any attempt to modify them will result in undefined behavior.</p>

<h2 id="forcomp">forcomp</h2>

<p>Similar to <a href="#forpart">&quot;forpart&quot;</a>, but iterates over integer compositions rather than partitions. This can be thought of as all ordering of partitions, or alternately partitions may be viewed as an ordered subset of compositions. The ordering is lexicographic. All options from <a href="#forpart">&quot;forpart&quot;</a> may be used.</p>

<p>The number of unrestricted compositions of <code>n</code> is <code>2^(n-1)</code>.</p>

<h2 id="forcomb">forcomb</h2>

<p>Given non-negative arguments <code>n</code> and <code>k</code>, the block is called with <code>@_</code> set to the <code>k</code> element array of values from <code>0</code> to <code>n-1</code> representing the combinations in lexicographical order. While the <a>binomial</a> function gives the total number, this function can be used to enumerate the choices.</p>

<p>Rather than give a data array as input, an integer is used for <code>n</code>. A convenient way to map to array elements is:</p>

<pre><code>  <span class="variable">forcomb</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@data</span><span class="string">[</span><span class="variable">@_</span><span class="string">]"</span> <span class="operator">}</span> <span class="variable">@data</span><span class="operator">,</span> <span class="number">3</span><span class="operator">;</span>
</code></pre>

<p>where the block maps the combination array <code>@_</code> to array values, the argument for <code>n</code> is given the array since it will be evaluated as a scalar and hence give the size, and the argument for <code>k</code> is the desired size of the combinations.</p>

<p>Like forpart and forperm, the index return values are read-only. Any attempt to modify them will result in undefined behavior.</p>

<p>If the second argument <code>k</code> is not supplied, then all k-subsets are returned starting with the smallest set <code>k=0</code> and continuing to <code>k=n</code>. Each k-subset is in lexicographical order. This is the power set of <code>n</code>.</p>

<p>This corresponds to the Pari/GP 2.10 <code>forsubset</code> function.</p>

<h2 id="forperm">forperm</h2>

<p>Given non-negative argument <code>n</code>, the block is called with <code>@_</code> set to the <code>k</code> element array of values from <code>0</code> to <code>n-1</code> representing permutations in lexicographical order. The total number of calls will be <code>n!</code>.</p>

<p>Rather than give a data array as input, an integer is used for <code>n</code>. A convenient way to map to array elements is:</p>

<pre><code>  <span class="variable">forperm</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@data</span><span class="string">[</span><span class="variable">@_</span><span class="string">]"</span> <span class="operator">}</span> <span class="variable">@data</span><span class="operator">;</span>
</code></pre>

<p>where the block maps the permutation array <code>@_</code> to array values, and the argument for <code>n</code> is given the array since it will be evaluated as a scalar and hence give the size.</p>

<p>Like forpart and forcomb, the index return values are read-only. Any attempt to modify them will result in undefined behavior.</p>

<h2 id="forderange">forderange</h2>

<p>Similar to forperm, but iterates over derangements. This is the set of permutations skipping any which maps an element to its original position.</p>

<h2 id="formultiperm">formultiperm</h2>

<pre><code>  <span class="comment"># Show all anagrams of 'serpent':</span>
  <span class="variable">formultiperm</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">}</span> <span class="operator">[</span><span class="keyword">split</span><span class="operator">(</span><span class="regex">//</span><span class="operator">,</span><span class="string">"serpent"</span><span class="operator">)</span><span class="operator">]</span><span class="operator">;</span>
</code></pre>

<p>Similar to <a href="#forperm">&quot;forperm&quot;</a> but takes an array reference as an argument. This is treated as a multiset, and the block will be called with each multiset permutation. While the standard permutation iterator takes a scalar and returns index permutations, this takes the set itself.</p>

<p>If all values are unique, then the results will be the same as a standard permutation. Otherwise, the results will be similar to a standard permutation removing duplicate entries. While generating all permutations and filtering out duplicates works, it is very slow for large sets. This iterator will be much more efficient.</p>

<p>There is no ordering requirement for the input array reference. The results will be in lexicographic order.</p>

<h2 id="lastfor">lastfor</h2>

<pre><code>  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">lastfor</span><span class="operator">,</span><span class="keyword">return</span> <span class="keyword">if</span> <span class="variable">$_</span> <span class="operator">&gt;</span> <span class="number">1000</span><span class="operator">;</span> <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$_</span><span class="operator">;</span> <span class="operator">}</span> <span class="number">1e9</span><span class="operator">;</span>
</code></pre>

<p>Calling lastfor requests that the current for... loop stop after this call. Ideally this would act exactly like a <code>last</code> inside a loop, but technical reasons mean it does not exit the block early, hence one typically adds a <code>return</code> if needed.</p>

<h2 id="prime_iterator">prime_iterator</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">=</span> <span class="variable">prime_iterator</span><span class="operator">;</span>
  <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$it</span><span class="operator">-&gt;()</span> <span class="keyword">for</span> <span class="number">1</span><span class="operator">..</span><span class="number">100000</span><span class="operator">;</span>
</code></pre>

<p>Returns a closure-style iterator. The start value defaults to the first prime (2) but an initial value may be given as an argument, which will result in the first value returned being the next prime greater than or equal to the argument. For example, this:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">=</span> <span class="variable">prime_iterator</span><span class="operator">(</span><span class="number">200</span><span class="operator">);</span>  <span class="keyword">say</span> <span class="variable">$it</span><span class="operator">-&gt;();</span>  <span class="keyword">say</span> <span class="variable">$it</span><span class="operator">-&gt;();</span>
</code></pre>

<p>will return 211 followed by 223, as those are the next primes &gt;= 200. On each call, the iterator returns the current value and increments to the next prime.</p>

<p>Other options include <a href="#forprimes">&quot;forprimes&quot;</a> (more efficiency, less flexibility), <a href="../../../lib/Math/Prime/Util/PrimeIterator.html">Math::Prime::Util::PrimeIterator</a> (an iterator with more functionality), or <a href="../../../lib/Math/Prime/Util/PrimeArray.html">Math::Prime::Util::PrimeArray</a> (a tied array).</p>

<h2 id="prime_iterator_object">prime_iterator_object</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">=</span> <span class="variable">prime_iterator_object</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">value</span> <span class="operator">&lt;</span> <span class="number">100</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">value</span><span class="operator">;</span> <span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">next</span><span class="operator">;</span> <span class="operator">}</span>
  <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$it</span><span class="operator">-&gt;</span><span class="variable">iterate</span> <span class="keyword">for</span> <span class="number">1</span><span class="operator">..</span><span class="number">100000</span><span class="operator">;</span>
</code></pre>

<p>Returns a <a href="../../../lib/Math/Prime/Util/PrimeIterator.html">Math::Prime::Util::PrimeIterator</a> object. A shortcut that loads the package if needed, calls new, and returns the object. See the documentation for that package for details. This object has more features than the simple one above (e.g. the iterator is bi-directional), and also handles iterating across bigints.</p>

<h2 id="prime_count">prime_count</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$primepi</span> <span class="operator">=</span> <span class="variable">prime_count</span><span class="operator">(</span> <span class="number">1_000</span> <span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$pirange</span> <span class="operator">=</span> <span class="variable">prime_count</span><span class="operator">(</span> <span class="number">1_000</span><span class="operator">,</span> <span class="number">10_000</span> <span class="operator">);</span>
</code></pre>

<p>Returns the Prime Count function <code>Pi(n)</code>, also called <code>primepi</code> in some math packages. When given two arguments, it returns the inclusive count of primes between the ranges. E.g. <code>(13,17)</code> returns 2, <code>(14,17)</code> and <code>(13,16)</code> return 1, <code>(14,16)</code> returns 0.</p>

<p>The current implementation decides based on the ranges whether to use a segmented sieve with a fast bit count, or the extended LMO algorithm. The former is preferred for small sizes as well as small ranges. The latter is much faster for large ranges.</p>

<p>The segmented sieve is very memory efficient and is quite fast even with large base values. Its complexity is approximately <code>O(sqrt(a) + (b-a))</code>, where the first term is typically negligible below <code>~ 10^11</code>. Memory use is proportional only to <code>sqrt(a)</code>, with total memory use under 1MB for any base under <code>10^14</code>.</p>

<p>The extended LMO method has complexity approximately <code>O(b^(2/3)) + O(a^(2/3))</code>, and also uses low memory. A calculation of <code>Pi(10^14)</code> completes in a few seconds, <code>Pi(10^15)</code> in well under a minute, and <code>Pi(10^16)</code> in about one minute. In contrast, even parallel primesieve would take over a week on a similar machine to determine <code>Pi(10^16)</code>.</p>

<p>Also see the function <a href="#prime_count_approx">&quot;prime_count_approx&quot;</a> which gives a very good approximation to the prime count, and <a href="#prime_count_lower">&quot;prime_count_lower&quot;</a> and <a href="#prime_count_upper">&quot;prime_count_upper&quot;</a> which give tight bounds to the actual prime count. These functions return quickly for any input, including bigints.</p>

<h2 id="prime_count_upper">prime_count_upper</h2>

<h2 id="prime_count_lower">prime_count_lower</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$lower_limit</span> <span class="operator">=</span> <span class="variable">prime_count_lower</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$upper_limit</span> <span class="operator">=</span> <span class="variable">prime_count_upper</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="comment">#   $lower_limit  &lt;=  prime_count(n)  &lt;=  $upper_limit</span>
</code></pre>

<p>Returns an upper or lower bound on the number of primes below the input number. These are analytical routines, so will take a fixed amount of time and no memory. The actual <code>prime_count</code> will always be equal to or between these numbers.</p>

<p>A common place these would be used is sizing an array to hold the first <code>$n</code> primes. It may be desirable to use a bit more memory than is necessary, to avoid calling <code>prime_count</code>.</p>

<p>These routines use verified tight limits below a range at least <code>2^35</code>. For larger inputs various methods are used including Dusart (2010), B&uuml;the (2014,2015), and Axler (2014). These bounds do not assume the Riemann Hypothesis. If the configuration option <code>assume_rh</code> has been set (it is off by default), then the Schoenfeld (1976) bounds can be used for very large values.</p>

<h2 id="prime_count_approx">prime_count_approx</h2>

<pre><code>  <span class="keyword">print</span> <span class="string">"there are about "</span><span class="operator">,</span>
        <span class="variable">prime_count_approx</span><span class="operator">(</span> <span class="number">10</span> <span class="operator">**</span> <span class="number">18</span> <span class="operator">),</span>
        <span class="string">" primes below one quintillion.\n"</span><span class="operator">;</span>
</code></pre>

<p>Returns an approximation to the <code>prime_count</code> function, without having to generate any primes. For values under <code>10^36</code> this uses the Riemann R function, which is quite accurate: an error of less than <code>0.0005%</code> is typical for input values over <code>2^32</code>, and decreases as the input gets larger. If <a>Math::MPFR</a> is installed, the Riemann R function is used for all values, and will be very fast. If not, then values of <code>10^36</code> and larger will use the approximation <code>li(x) - li(sqrt(x))/2</code>. While not as accurate as the Riemann R function, it still should have error less than <code>0.00000000000000001%</code>.</p>

<p>A slightly faster but much less accurate answer can be obtained by averaging the upper and lower bounds.</p>

<h2 id="twin_primes">twin_primes</h2>

<p>Returns the lesser of twin primes between the lower and upper limits (inclusive), with a lower limit of <code>2</code> if none is given. This is <a href="http://oeis.org/A001359">OEIS A001359</a>. Given a twin prime pair <code>(p,q)</code> with <code>q = p + 2</code>, <code>p prime</code>, and &lt;q prime&gt;, this function uses <code>p</code> to represent the pair. Hence the bounds need to include <code>p</code>, and the returned list will have <code>p</code> but not <code>q</code>.</p>

<p>This works just like the <a href="#primes">&quot;primes&quot;</a> function, though only the first primes of twin prime pairs are returned. Like that function, an array reference is returned.</p>

<h2 id="twin_prime_count">twin_prime_count</h2>

<p>Similar to prime count, but returns the count of twin primes (primes <code>p</code> where <code>p+2</code> is also prime). Takes either a single number indicating a count from 2 to the argument, or two numbers indicating a range.</p>

<p>The primes being counted are the first value, so a range of <code>(3,5)</code> will return a count of two, because both <code>3</code> and <code>5</code> are counted as twin primes. A range of <code>(12,13)</code> will return a count of zero, because neither <code>12+2</code> nor <code>13+2</code> are prime. In contrast, <code>primesieve</code> requires all elements of a constellation to be within the range to be counted, so would return one for the first example (<code>5</code> is not counted because its pair <code>7</code> is not in the range).</p>

<p>There is no useful formula known for this, unlike prime counts. We sieve for the answer, using some small table acceleration.</p>

<h2 id="twin_prime_count_approx">twin_prime_count_approx</h2>

<p>Returns an approximation to the twin prime count of <code>n</code>. This returns quickly and has a very small error for large values. The method used is conjecture B of Hardy and Littlewood 1922, as stated in Sebah and Gourdon 2002. For inputs under 10M, a correction factor is additionally applied to reduce the mean squared error.</p>

<h2 id="ramanujan_primes">ramanujan_primes</h2>

<p>Returns the Ramanujan primes R_n between the upper and lower limits (inclusive), with a lower limit of <code>2</code> if none is given. This is <a href="http://oeis.org/A104272">OEIS A104272</a>. These are the Rn such that if <code>x &gt; Rn</code> then <a href="#prime_count">&quot;prime_count&quot;</a>(n) - <a href="#prime_count">&quot;prime_count&quot;</a>(n/2) &gt;= <code>n</code>.</p>

<p>This has a similar API to the <a href="#primes">&quot;primes&quot;</a> and <a href="#twin_primes">&quot;twin_primes&quot;</a> functions, and like them, returns an array reference.</p>

<p>Generating Ramanujan primes takes some effort, including overhead to cover a range. This will be substantially slower than generating standard primes.</p>

<h2 id="ramanujan_prime_count">ramanujan_prime_count</h2>

<p>Similar to prime count, but returns the count of Ramanujan primes. Takes either a single number indicating a count from 2 to the argument, or two numbers indicating a range.</p>

<p>While not nearly as efficient as <a>prime_count</a>, this does use a number of speedups that result it in being much more efficient than generating all the Ramanujan primes.</p>

<h2 id="ramanujan_prime_count_approx">ramanujan_prime_count_approx</h2>

<p>A fast approximation of the count of Ramanujan primes under <code>n</code>.</p>

<h2 id="ramanujan_prime_count_lower">ramanujan_prime_count_lower</h2>

<p>A fast lower limit on the count of Ramanujan primes under <code>n</code>.</p>

<h2 id="ramanujan_prime_count_upper">ramanujan_prime_count_upper</h2>

<p>A fast upper limit on the count of Ramanujan primes under <code>n</code>.</p>

<h2 id="sieve_range">sieve_range</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@candidates</span> <span class="operator">=</span> <span class="variable">sieve_range</span><span class="operator">(</span><span class="number">2</span><span class="operator">**</span><span class="number">1000</span><span class="operator">,</span> <span class="number">10000</span><span class="operator">,</span> <span class="number">40000</span><span class="operator">);</span>
</code></pre>

<p>Given a start value <code>n</code>, and native unsigned integers <code>width</code> and <code>depth</code>, a sieve of maximum depth <code>depth</code> is done for the <code>width</code> consecutive numbers beginning with <code>n</code>. An array of offsets from the start is returned.</p>

<p>The returned list contains those offsets in the range <code>n</code> to <code>n+width-1</code> where <code>n + offset</code> has no prime factors less than <code>depth</code>.</p>

<p>This function is very similar to the three argument form of <a href="#sieve_primes">&quot;sieve_primes&quot;</a>. The differences are using <code>(n,width)</code> instead of <code>(low,high)</code>, and most importantly returning small offsets from the start value rather than the values themselves. This can substantially reduce overhead for multi-thousand digit numbers.</p>

<h2 id="sieve_prime_cluster">sieve_prime_cluster</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@s</span> <span class="operator">=</span> <span class="variable">sieve_prime_cluster</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">1e9</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">12</span><span class="operator">,</span><span class="number">18</span><span class="operator">,</span><span class="number">20</span><span class="operator">);</span>
</code></pre>

<p>Efficiently finds prime clusters between the first two arguments <code>low</code> and <code>high</code>. The remaining arguments describe the cluster. The cluster values must be even, less than 31 bits, and strictly increasing. Given a cluster set <code>C</code>, the returned values are all primes in the range where <code>p+c</code> is prime for each <code>c</code> in the cluster set <code>C</code>. For returned values under <code>2^64</code>, all cluster values are definitely prime. Above this range, all cluster values are BPSW probable primes (no counterexamples known).</p>

<p>This function returns an array rather than an array reference. Typically the number of returned values is much lower than for other primes functions, so this uses the more convenient array return. This function has an identical signature to the function of the same name in <a>Math::Prime::Util:GMP</a>.</p>

<p>The cluster is described as offsets from 0, with the implicit prime at 0. Hence an empty list is asking for all primes (the cluster <code>p+0</code>). A list with the single value <code>2</code> will find all twin primes (the cluster where <code>p+0</code> and <code>p+2</code> are prime). The list <code>2,6,8</code> will find prime quadruplets. Note that there is no requirement that the list denote a constellation (a cluster with minimal distance) -- the list <code>42,92,606</code> is just fine.</p>

<h2 id="sum_primes">sum_primes</h2>

<p>Returns the summation of primes between the lower and upper limits (inclusive), with a lower limit of <code>2</code> if none is given. This is essentially similar to either of:</p>

<pre><code>    <span class="variable">$sum</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$_</span> <span class="operator">}</span> <span class="variable">$low</span><span class="operator">,</span><span class="variable">$high</span><span class="operator">;</span>  <span class="variable">$sum</span><span class="operator">;</span>
    <span class="comment"># or</span>
    <span class="variable">vecsum</span><span class="operator">(</span> <span class="variable">@</span><span class="operator">{</span> <span class="variable">primes</span><span class="operator">(</span><span class="variable">$low</span><span class="operator">,</span><span class="variable">$high</span><span class="operator">)</span> <span class="operator">}</span> <span class="operator">);</span>
</code></pre>

<p>but is much more efficient.</p>

<p>The current implementation is a small-table-enhanced sieve count for sums that fit in a UV, an efficient sieve count for small ranges, and a Legendre sum method for larger values.</p>

<p>While this is fairly efficient, the state of the art is Kim Walisch&#39;s <a href="https://github.com/kimwalisch/primesum">primesum</a>. It is recommended for very large values.</p>

<h2 id="print_primes">print_primes</h2>

<pre><code>  <span class="variable">print_primes</span><span class="operator">(</span><span class="number">1_000_000</span><span class="operator">);</span>             <span class="comment"># print the first 1 million primes</span>
  <span class="variable">print_primes</span><span class="operator">(</span><span class="number">1000</span><span class="operator">,</span> <span class="number">2000</span><span class="operator">);</span>            <span class="comment"># print primes in range</span>
  <span class="variable">print_primes</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span><span class="number">1000</span><span class="operator">,</span><span class="keyword">fileno</span><span class="operator">(</span><span class="variable">STDERR</span><span class="operator">))</span>  <span class="comment"># print to a different descriptor</span>
</code></pre>

<p>With a single argument this prints all primes from 2 to <code>n</code> to standard out. With two arguments it prints primes between <code>low</code> and <code>high</code> to standard output. With three arguments it prints primes between <code>low</code> and <code>high</code> to the file descriptor given. If the file descriptor cannot be written to, this will croak with &quot;print_primes write error&quot;. It will produce identical output to:</p>

<pre><code>    <span class="variable">forprimes</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="operator">}</span> <span class="variable">$low</span><span class="operator">,</span><span class="variable">$high</span><span class="operator">;</span>
</code></pre>

<p>The point of this function is just efficiency. It is over 10x faster than using <code>say</code>, <code>print</code>, or <code>printf</code>, though much more limited in functionality. A later version may allow a file handle as the third argument.</p>

<h2 id="nth_prime">nth_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The ten thousandth prime is "</span><span class="operator">,</span> <span class="variable">nth_prime</span><span class="operator">(</span><span class="number">10_000</span><span class="operator">);</span>
</code></pre>

<p>Returns the prime that lies in index <code>n</code> in the array of prime numbers. Put another way, this returns the smallest <code>p</code> such that <code>Pi(p) &gt;= n</code>.</p>

<p>Like most programs with similar functionality, this is one-based. <code>nth_prime(0)</code> returns <code>undef</code>, <code>nth_prime(1)</code> returns <code>2</code>.</p>

<p>For relatively small inputs (below 1 million or so), this does a sieve over a range containing the nth prime, then counts up to the number. This is fairly efficient in time and memory. For larger values, create a low-biased estimate using the inverse logarithmic integral, use a fast prime count, then sieve in the small difference.</p>

<p>While this method is thousands of times faster than generating primes, and doesn&#39;t involve big tables of precomputed values, it still can take a fair amount of time for large inputs. Calculating the <code>10^12th</code> prime takes about 1 second, the <code>10^13th</code> prime takes under 10 seconds, and the <code>10^14th</code> prime (3475385758524527) takes under 30 seconds. Think about whether a bound or approximation would be acceptable, as they can be computed analytically.</p>

<p>If the result is larger than a native integer size (32-bit or 64-bit), the result will take a very long time. A later version of <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> may include this functionality which would help for 32-bit machines.</p>

<h2 id="nth_prime_upper">nth_prime_upper</h2>

<h2 id="nth_prime_lower">nth_prime_lower</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$lower_limit</span> <span class="operator">=</span> <span class="variable">nth_prime_lower</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$upper_limit</span> <span class="operator">=</span> <span class="variable">nth_prime_upper</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="comment"># For all $n:   $lower_limit  &lt;=  nth_prime($n)  &lt;=  $upper_limit</span>
</code></pre>

<p>Returns an analytical upper or lower bound on the Nth prime. No sieving is done, so these are fast even for large inputs.</p>

<p>For tiny values of <code>n</code>. exact answers are returned. For small inputs, an inverse of the opposite prime count bound is used. For larger values, the Dusart (2010) and Axler (2013) bounds are used.</p>

<h2 id="nth_prime_approx">nth_prime_approx</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The one trillionth prime is ~ "</span><span class="operator">,</span> <span class="variable">nth_prime_approx</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">12</span><span class="operator">);</span>
</code></pre>

<p>Returns an approximation to the <code>nth_prime</code> function, without having to generate any primes. For values where the nth prime is smaller than <code>2^64</code>, the inverse Riemann R function is used. For larger values, the inverse logarithmic integral is used.</p>

<h2 id="nth_twin_prime">nth_twin_prime</h2>

<p>Returns the Nth twin prime. This is done via sieving and counting, so is not very fast for large values.</p>

<h2 id="nth_twin_prime_approx">nth_twin_prime_approx</h2>

<p>Returns an approximation to the Nth twin prime. A curve fit is used for small inputs (under 1200), while for larger inputs a binary search is done on the approximate twin prime count.</p>

<h2 id="nth_ramanujan_prime">nth_ramanujan_prime</h2>

<p>Returns the Nth Ramanujan prime. For reasonable size values of <code>n</code>, e.g. under <code>10^8</code> or so, this is relatively efficient for single calls. If multiple calls are being made, it will be much more efficient to get the list once.</p>

<h2 id="nth_ramanujan_prime_approx">nth_ramanujan_prime_approx</h2>

<p>A fast approximation of the Nth Ramanujan prime.</p>

<h2 id="nth_ramanujan_prime_lower">nth_ramanujan_prime_lower</h2>

<p>A fast lower limit on the Nth Ramanujan prime.</p>

<h2 id="nth_ramanujan_prime_upper">nth_ramanujan_prime_upper</h2>

<p>A fast upper limit on the Nth Ramanujan prime.</p>

<h2 id="is_pseudoprime">is_pseudoprime</h2>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is a probable prime to each base, <code>0</code> if not. This is the simple Fermat primality test. Removing primes, given base 2 this produces the sequence <a href="http://oeis.org/A001567">OEIS A001567</a>.</p>

<p>For practical use, <a href="#is_strong_pseudoprime">&quot;is_strong_pseudoprime&quot;</a> is a much stronger test with similar or better performance.</p>

<p>Note that there is a set of composites (the Carmichael numbers) that will pass this test for all bases. This downside is not shared by the Euler and strong probable prime tests (also called the Solovay-Strassen and Miller-Rabin tests).</p>

<h2 id="is_euler_pseudoprime">is_euler_pseudoprime</h2>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is an Euler probable prime to each base, <code>0</code> if not. This is the Euler test, sometimes called the Euler-Jacobi test. Removing primes, given base 2 this produces the sequence <a href="http://oeis.org/A047713">OEIS A047713</a>.</p>

<p>If 0 is returned, then the number really is a composite. If 1 is returned, then it is either a prime or an Euler pseudoprime to all the given bases. Given enough distinct bases, the chances become very high that the number is actually prime.</p>

<p>This test forms the basis of the Solovay-Strassen test, which is a precursor to the Miller-Rabin test (which uses the strong probable prime test). There are no analogies to the Carmichael numbers for this test. For the Euler test, at <i>most</i> 1/2 of witnesses pass for a composite, while at most 1/4 pass for the strong pseudoprime test.</p>

<h2 id="is_strong_pseudoprime">is_strong_pseudoprime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$maybe_prime</span> <span class="operator">=</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$probably_prime</span> <span class="operator">=</span> <span class="variable">is_strong_pseudoprime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">7</span><span class="operator">,</span> <span class="number">11</span><span class="operator">,</span> <span class="number">13</span><span class="operator">,</span> <span class="number">17</span><span class="operator">);</span>
</code></pre>

<p>Takes a positive number <code>n</code> and one or more non-zero positive bases as input. Returns <code>1</code> if the input is a strong probable prime to each base, <code>0</code> if not.</p>

<p>If 0 is returned, then the number really is a composite. If 1 is returned, then it is either a prime or a strong pseudoprime to all the given bases. Given enough distinct bases, the chances become very, very high that the number is actually prime.</p>

<p>This is usually used in combination with other tests to make either stronger tests (e.g. the strong BPSW test) or deterministic results for numbers less than some verified limit (e.g. it has long been known that no more than three selected bases are required to give correct primality test results for any 32-bit number). Given the small chances of passing multiple bases, there are some math packages that just use multiple MR tests for primality testing.</p>

<p>Even inputs other than 2 will always return 0 (composite). While the algorithm does run with even input, most sources define it only on odd input. Returning composite for all non-2 even input makes the function match most other implementations including <a>Math::Primality</a>&#39;s <code>is_strong_pseudoprime</code> function.</p>

<h2 id="is_lucas_pseudoprime">is_lucas_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input is a standard Lucas probable prime using the Selfridge method of choosing D, P, and Q (some sources call this a Lucas-Selfridge pseudoprime). Removing primes, this produces the sequence <a href="http://oeis.org/A217120">OEIS A217120</a>.</p>

<h2 id="is_strong_lucas_pseudoprime">is_strong_lucas_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input is a strong Lucas probable prime using the Selfridge method of choosing D, P, and Q (some sources call this a strong Lucas-Selfridge pseudoprime). This is one half of the BPSW primality test (the Miller-Rabin strong pseudoprime test with base 2 being the other half). Removing primes, this produces the sequence <a href="http://oeis.org/A217255">OEIS A217255</a>.</p>

<h2 id="is_extra_strong_lucas_pseudoprime">is_extra_strong_lucas_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes the extra strong Lucas test (as defined in <a href="http://www.ams.org/mathscinet-getitem?mr=1680879">Grantham 2000</a>). This test has more stringent conditions than the strong Lucas test, and produces about 60% fewer pseudoprimes. Performance is typically 20-30% <i>faster</i> than the strong Lucas test.</p>

<p>The parameters are selected using the <a href="http://oeis.org/A217719">Baillie-OEIS method</a> method: increment <code>P</code> from <code>3</code> until <code>jacobi(D,n) = -1</code>. Removing primes, this produces the sequence <a href="http://oeis.org/A217719">OEIS A217719</a>.</p>

<h2 id="is_almost_extra_strong_lucas_pseudoprime">is_almost_extra_strong_lucas_pseudoprime</h2>

<p>This is similar to the <a href="#is_extra_strong_lucas_pseudoprime">&quot;is_extra_strong_lucas_pseudoprime&quot;</a> function, but does not calculate <code>U</code>, so is a little faster, but also weaker. With the current implementations, there is little reason to prefer this unless trying to reproduce specific results. The extra-strong implementation has been optimized to use similar features, removing most of the performance advantage.</p>

<p>An optional second argument (an integer between 1 and 256) indicates the increment amount for <code>P</code> parameter selection. The default value of 1 yields the parameter selection described in <a href="#is_extra_strong_lucas_pseudoprime">&quot;is_extra_strong_lucas_pseudoprime&quot;</a>, creating a pseudoprime sequence which is a superset of the latter&#39;s pseudoprime sequence <a href="http://oeis.org/A217719">OEIS A217719</a>. A value of 2 yields the method used by <a href="http://pari.math.u-bordeaux.fr/faq.html#primetest">Pari</a>.</p>

<p>Because the <code>U = 0</code> condition is ignored, this produces about 5% more pseudoprimes than the extra-strong Lucas test. However this is still only 66% of the number produced by the strong Lucas-Selfridge test. No BPSW counterexamples have been found with any of the Lucas tests described.</p>

<h2 id="is_euler_plumb_pseudoprime">is_euler_plumb_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input and returns 1 if <code>n</code> passes Colin Plumb&#39;s Euler Criterion primality test. Pseudoprimes to this test are a subset of the base 2 Fermat and Euler tests, but a superset of the base 2 strong pseudoprime (Miller-Rabin) test.</p>

<p>The main reason for this test is that is a bit more efficient than other probable prime tests.</p>

<h2 id="is_perrin_pseudoprime">is_perrin_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input and returns 1 if <code>n</code> divides <code>P(n)</code> where <code>P(n)</code> is the Perrin number of <code>n</code>. The Perrin sequence is defined by <code>P(n) = P(n-2) + P(n-3)</code> with <code>P(0) = 3, P(1) = 0, P(2) = 2</code>.</p>

<p>While pseudoprimes are relatively rare (the first two are 271441 and 904631), infinitely many exist. They have significant overlap with the base-2 pseudoprimes and strong pseudoprimes, making the test inferior to the Lucas or Frobenius tests for combined testing. The pseudoprime sequence is <a href="http://oeis.org/A013998">OEIS A013998</a>.</p>

<p>The implementation uses modular pre-filters, Montgomery math, and the Adams/Shanks doubling method. This is significantly more efficient than other known implementations.</p>

<p>An optional second argument <code>r</code> indicates whether to run additional tests. With <code>r=1</code>, <code>P(-n) = -1 mod n</code> is also verified, creating the &quot;minimal restricted&quot; test. With <code>r=2</code>, the full signature is also tested using the Adams and Shanks (1982) rules (without the quadratic form test). With <code>r=3</code>, the full signature is testing using the Grantham (2000) test, which additionally does not allow pseudoprimes to be divisible by 2 or 23. The minimal restricted pseudoprime sequence is <a href="http://oeis.org/A018187">OEIS A018187</a>.</p>

<h2 id="is_catalan_pseudoprime">is_catalan_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input and returns 1 if <code>-1^((n-1/2)) C_((n-1/2)</code> is congruent to 2 mod <code>n</code>, where <code>C_n</code> is the nth Catalan number. The nth Catalan number is equal to <code>binomial(2n,n)/(n+1)</code>. All odd primes satisfy this condition, and only three known composites.</p>

<p>The pseudoprime sequence is <a href="http://oeis.org/A163209">OEIS A163209</a>.</p>

<p>There is no known efficient method to perform the Catalan primality test, so it is a curiosity rather than a practical test. The implementation uses a method from Charles Greathouse IV (2015) and results from Aebi and Cairns (2008) to produce results many orders of magnitude faster than other known implementations, but it is still vastly slower than other compositeness tests.</p>

<h2 id="is_frobenius_pseudoprime">is_frobenius_pseudoprime</h2>

<p>Takes a positive number <code>n</code> as input, and two optional parameters <code>a</code> and <code>b</code>, and returns 1 if the <code>n</code> is a Frobenius probable prime with respect to the polynomial <code>x^2 - ax + b</code>. Without the parameters, <code>b = 2</code> and <code>a</code> is the least positive odd number such that <code>(a^2-4b|n) = -1</code>. This selection has no pseudoprimes below <code>2^64</code> and none known. In any case, the discriminant <code>a^2-4b</code> must not be a perfect square.</p>

<p>Some authors use the Fibonacci polynomial <code>x^2-x-1</code> corresponding to <code>(1,-1)</code> as the default method for a Frobenius probable prime test. This creates a weaker test than most other parameter choices (e.g. over twenty times more pseudoprimes than <code>(3,-5)</code>), so is not used as the default here. With the <code>(1,-1)</code> parameters the pseudoprime sequence is <a href="http://oeis.org/A212424">OEIS A212424</a>.</p>

<p>The Frobenius test is a stronger test than the Lucas test. Any Frobenius <code>(a,b)</code> pseudoprime is also a Lucas <code>(a,b)</code> pseudoprime but the converse is not true, as any Frobenius <code>(a,b)</code> pseudoprime is also a Fermat pseudoprime to the base <code>|b|</code>. We can see that with the default parameters this is similar to, but somewhat weaker than, the BPSW test used by this module (which uses the strong and extra-strong versions of the probable prime and Lucas tests respectively).</p>

<p>Also see the more efficient <a href="#is_frobenius_khashin_pseudoprime">&quot;is_frobenius_khashin_pseudoprime&quot;</a> and <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a> which have no known counterexamples and run quite a bit faster.</p>

<h2 id="is_frobenius_underwood_pseudoprime">is_frobenius_underwood_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes the efficient Frobenius test of Paul Underwood. This selects a parameter <code>a</code> as the least non-negative integer such that <code>(a^2-4|n)=-1</code>, then verifies that <code>(x+2)^(n+1) = 2a + 5 mod (x^2-ax+1,n)</code>. This combines a Fermat and Lucas test with a cost of only slightly more than 2 strong pseudoprime tests. This makes it similar to, but faster than, a regular Frobenius test.</p>

<p>There are no known pseudoprimes to this test and extensive computation has shown no counterexamples under <code>2^50</code>. This test also has no overlap with the BPSW test, making it a very effective method for adding additional certainty. Performance at 1e12 is about 60% slower than BPSW.</p>

<h2 id="is_frobenius_khashin_pseudoprime">is_frobenius_khashin_pseudoprime</h2>

<p>Takes a positive number as input, and returns 1 if the input passes the Frobenius test of Sergey Khashin. This ensures <code>n</code> is not a perfect square, selects the parameter <code>c</code> as the smallest odd prime such that <code>(c|n)=-1</code>, then verifies that <code>(1+D)^n = (1-D) mod n</code> where <code>D = sqrt(c) mod n</code>.</p>

<p>There are no known pseudoprimes to this test and Khashin shows that under certain restrictions there are no counterexamples under <code>2^60</code>. Any that exist must have either one factor under 19 or have <code>c &gt; 128</code>. Performance at 1e12 is about 40% slower than BPSW.</p>

<h2 id="miller_rabin_random">miller_rabin_random</h2>

<p>Takes a positive number (<code>n</code>) as input and a positive number (<code>k</code>) of bases to use. Performs <code>k</code> Miller-Rabin tests using uniform random bases between 2 and <code>n-2</code>.</p>

<p>This should not be used in place of <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a>, <a href="#is_prime">&quot;is_prime&quot;</a>, or <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a>. Those functions will be faster and provide better results than running <code>k</code> Miller-Rabin tests. This function can be used if one wants more assurances for non-proven primes, such as for cryptographic uses where the size is large enough that proven primes are not desired.</p>

<h2 id="is_prob_prime">is_prob_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$prob_prime</span> <span class="operator">=</span> <span class="variable">is_prob_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="comment"># Returns 0 (composite), 2 (prime), or 1 (probably prime)</span>
</code></pre>

<p>Takes a positive number as input and returns back either 0 (composite), 2 (definitely prime), or 1 (probably prime).</p>

<p>For 64-bit input (native or bignum), this uses either a deterministic set of Miller-Rabin tests (1, 2, or 3 tests) or a strong BPSW test consisting of a single base-2 strong probable prime test followed by a strong Lucas test. This has been verified with Jan Feitsma&#39;s 2-PSP database to produce no false results for 64-bit inputs. Hence the result will always be 0 (composite) or 2 (prime).</p>

<p>For inputs larger than <code>2^64</code>, an extra-strong Baillie-PSW primality test is performed (also called BPSW or BSW). This is a probabilistic test, so only 0 (composite) and 1 (probably prime) are returned. There is a possibility that composites may be returned marked prime, but since the test was published in 1980, not a single BPSW pseudoprime has been found, so it is extremely likely to be prime. While we believe (Pomerance 1984) that an infinite number of counterexamples exist, there is a weak conjecture (Martin) that none exist under 10000 digits.</p>

<h2 id="is_bpsw_prime">is_bpsw_prime</h2>

<p>Given a positive number input, returns 0 (composite), 2 (definitely prime), or 1 (probably prime), using the BPSW primality test (extra-strong variant). Normally one of the <a href="../../../lib/Math/Prime/Util.html#is_prime">&quot;is_prime&quot; in Math::Prime::Util</a> or <a href="../../../lib/Math/Prime/Util.html#is_prob_prime">&quot;is_prob_prime&quot; in Math::Prime::Util</a> functions will suffice, but those functions do pre-tests to find easy composites. If you know this is not necessary, then calling <a href="#is_bpsw_prime">&quot;is_bpsw_prime&quot;</a> may save a small amount of time.</p>

<h2 id="is_provable_prime">is_provable_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_provable_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">2</span><span class="operator">;</span>
</code></pre>

<p>Takes a positive number as input and returns back either 0 (composite), 2 (definitely prime), or 1 (probably prime). This gives it the same return values as <a href="#is_prime">&quot;is_prime&quot;</a> and <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a>. Note that numbers below 2^64 are considered proven by the deterministic set of Miller-Rabin bases or the BPSW test. Both of these have been tested for all small (64-bit) composites and do not return false positives.</p>

<p>Using the <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> module is <b>highly recommended</b> for doing primality proofs, as it is much, much faster. The pure Perl code is just not fast for this type of operation, nor does it have the best algorithms. It should suffice for proofs of up to 40 digit primes, while the latest MPU::GMP works for primes of hundreds of digits (thousands with an optional larger polynomial set).</p>

<p>The pure Perl implementation uses theorem 5 of BLS75 (Brillhart, Lehmer, and Selfridge&#39;s 1975 paper), an improvement on the Pocklington-Lehmer test. This requires <code>n-1</code> to be factored to <code>(n/2)^(1/3))</code>. This is often fast, but as <code>n</code> gets larger, it takes exponentially longer to find factors.</p>

<p><a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> implements both the BLS75 theorem 5 test as well as ECPP (elliptic curve primality proving). It will typically try a quick <code>n-1</code> proof before using ECPP. Certificates are available with either method. This results in proofs of 200-digit primes in under 1 second on average, and many hundreds of digits are possible. This makes it significantly faster than Pari 2.1.7&#39;s <code>is_prime(n,1)</code> which is the default for <a>Math::Pari</a>.</p>

<h2 id="prime_certificate">prime_certificate</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$cert</span> <span class="operator">=</span> <span class="variable">prime_certificate</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">verify_prime</span><span class="operator">(</span><span class="variable">$cert</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"proven prime"</span> <span class="operator">:</span> <span class="string">"not prime"</span><span class="operator">;</span>
</code></pre>

<p>Given a positive integer <code>n</code> as input, returns a primality certificate as a multi-line string. If we could not prove <code>n</code> prime, an empty string is returned (<code>n</code> may or may not be composite). This may be examined or given to <a href="#verify_prime">&quot;verify_prime&quot;</a> for verification. The latter function contains the description of the format.</p>

<h2 id="is_provable_prime_with_cert">is_provable_prime_with_cert</h2>

<p>Given a positive integer as input, returns a two element array containing the result of <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a>: 0 definitely composite 1 probably prime 2 definitely prime and a primality certificate like <a href="#prime_certificate">&quot;prime_certificate&quot;</a>. The certificate will be an empty string if the first element is not 2.</p>

<h2 id="verify_prime">verify_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$cert</span> <span class="operator">=</span> <span class="variable">prime_certificate</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">verify_prime</span><span class="operator">(</span><span class="variable">$cert</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"proven prime"</span> <span class="operator">:</span> <span class="string">"not prime"</span><span class="operator">;</span>
</code></pre>

<p>Given a primality certificate, returns either 0 (not verified) or 1 (verified). Most computations are done using pure Perl with Math::BigInt, so you probably want to install and use Math::BigInt::GMP, and ECPP certificates will be faster with Math::Prime::Util::GMP for its elliptic curve computations.</p>

<p>If the certificate is malformed, the routine will carp a warning in addition to returning 0. If the <code>verbose</code> option is set (see <a href="#prime_set_config">&quot;prime_set_config&quot;</a>) then if the validation fails, the reason for the failure is printed in addition to returning 0. If the <code>verbose</code> option is set to 2 or higher, then a message indicating success and the certificate type is also printed.</p>

<p>A certificate may have arbitrary text before the beginning (the primality routines from this module will not have any extra text, but this way verbose output from the prover can be safely stored in a certificate). The certificate begins with the line:</p>

<pre><code>  [MPU - Primality Certificate]</code></pre>

<p>All lines in the certificate beginning with <code><span class="comment">#</span>
</code> are treated as comments and ignored, as are blank lines. A version number may follow, such as:</p>

<pre><code>  Version 1.0</code></pre>

<p>For all inputs, base 10 is the default, but at any point this may be changed with a line like:</p>

<pre><code>  Base 16</code></pre>

<p>where allowed bases are 10, 16, and 62. This module will only use base 10, so its routines will not output Base commands.</p>

<p>Next, we look for (using &quot;100003&quot; as an example):</p>

<pre><code>  Proof for:
  N 100003</code></pre>

<p>where the text <code>Proof for:</code> indicates we will read an <code>N</code> value. Skipping comments and blank lines, the next line should be &quot;N &quot; followed by the number.</p>

<p>After this, we read one or more blocks. Each block is a proof of the form:</p>

<pre><code>  If Q is prime, then N is prime.</code></pre>

<p>Some of the blocks have more than one Q value associated with them, but most only have one. Each block has its own set of conditions which must be verified, and this can be done completely self-contained. That is, each block is independent of the other blocks and may be processed in any order. To be a complete proof, each block must successfully verify. The block types and their conditions are shown below.</p>

<p>Finally, when all blocks have been read and verified, we must ensure we can construct a proof tree from the set of blocks. The root of the tree is the initial <code>N</code>, and for each node (block), all <code>Q</code> values must either have a block using that value as its <code>N</code> or <code>Q</code> must be less than <code>2^64</code> and pass BPSW.</p>

<p>Some other certificate formats (e.g. Primo) use an ordered chain, where the first block must be for the initial <code>N</code>, a single <code>Q</code> is given which is the implied <code>N</code> for the next block, and so on. This simplifies validation implementation somewhat, and removes some redundant information from the certificate, but has no obvious way to add proof types such as Lucas or the various BLS75 theorems that use multiple factors. I decided that the most general solution was to have the certificate contain the set in any order, and let the verifier do the work of constructing the tree.</p>

<p>The blocks begin with the text &quot;Type ...&quot; where ... is the type. One or more values follow. The defined types are:</p>

<dl>

<dt id="Small"><code>Small</code></dt>
<dd>

<pre><code>  Type Small
  N 5791</code></pre>

<p>N must be less than 2^64 and be prime (use BPSW or deterministic M-R).</p>

</dd>
<dt id="BLS3"><code>BLS3</code></dt>
<dd>

<pre><code>  Type BLS3
  N  2297612322987260054928384863
  Q  16501461106821092981
  A  5</code></pre>

<p>A simple n-1 style proof using BLS75 theorem 3. This block verifies if: a Q is odd b Q &gt; 2 c Q divides N-1 . Let M = (N-1)/Q d MQ+1 = N e M &gt; 0 f 2Q+1 &gt; sqrt(N) g A^((N-1)/2) mod N = N-1 h A^(M/2) mod N != N-1</p>

</dd>
<dt id="Pocklington"><code>Pocklington</code></dt>
<dd>

<pre><code>  Type Pocklington
  N  2297612322987260054928384863
  Q  16501461106821092981
  A  5</code></pre>

<p>A simple n-1 style proof using generalized Pocklington. This is more restrictive than BLS3 and much more than BLS5. This is Primo&#39;s type 1, and this module does not currently generate these blocks. This block verifies if: a Q divides N-1 . Let M = (N-1)/Q b M &gt; 0 c M &lt; Q d MQ+1 = N e A &gt; 1 f A^(N-1) mod N = 1 g gcd(A^M - 1, N) = 1</p>

</dd>
<dt id="BLS15"><code>BLS15</code></dt>
<dd>

<pre><code>  Type BLS15
  N  8087094497428743437627091507362881
  Q  175806402118016161687545467551367
  LP 1
  LQ 22</code></pre>

<p>A simple n+1 style proof using BLS75 theorem 15. This block verifies if: a Q is odd b Q &gt; 2 c Q divides N+1 . Let M = (N+1)/Q d MQ-1 = N e M &gt; 0 f 2Q-1 &gt; sqrt(N) . Let D = LP*LP - 4*LQ g D != 0 h Jacobi(D,N) = -1 . Note: V_{k} indicates the Lucas V sequence with LP,LQ i V_{m/2} mod N != 0 j V_{(N+1)/2} mod N == 0</p>

</dd>
<dt id="BLS5"><code>BLS5</code></dt>
<dd>

<pre><code>  Type BLS5
  N  8087094497428743437627091507362881
  Q[1]  98277749
  Q[2]  3631
  A[0]  11
  ----</code></pre>

<p>A more sophisticated n-1 proof using BLS theorem 5. This requires N-1 to be factored only to <code>(N/2)^(1/3)</code>. While this looks much more complicated, it really isn&#39;t much more work. The biggest drawback is just that we have multiple Q values to chain rather than a single one. This block verifies if:</p>

<pre><code>  a  N &gt; 2
  b  N is odd
  .  Note: the block terminates on the first line starting with a C&lt;-&gt;.
  .  Let Q[0] = 2
  .  Let A[i] = 2 if Q[i] exists and A[i] does not
  c  For each i (0 .. maxi):
  c1   Q[i] &gt; 1
  c2   Q[i] &lt; N-1
  c3   A[i] &gt; 1
  c4   A[i] &lt; N
  c5   Q[i] divides N-1
  . Let F = N-1 divided by each Q[i] as many times as evenly possible
  . Let R = (N-1)/F
  d  F is even
  e  gcd(F, R) = 1
  . Let s = integer    part of R / 2F
  . Let f = fractional part of R / 2F
  . Let P = (F+1) * (2*F*F + (r-1)*F + 1)
  f  n &lt; P
  g  s = 0  OR  r^2-8s is not a perfect square
  h  For each i (0 .. maxi):
  h1   A[i]^(N-1) mod N = 1
  h2   gcd(A[i]^((N-1)/Q[i])-1, N) = 1</code></pre>

</dd>
<dt id="ECPP"><code>ECPP</code></dt>
<dd>

<pre><code>  Type ECPP
  N  175806402118016161687545467551367
  A  96642115784172626892568853507766
  B  111378324928567743759166231879523
  M  175806402118016177622955224562171
  Q  2297612322987260054928384863
  X  3273750212
  Y  82061726986387565872737368000504</code></pre>

<p>An elliptic curve primality block, typically generated with an Atkin/Morain ECPP implementation, but this should be adequate for anything using the Atkin-Goldwasser-Kilian-Morain style certificates. Some basic elliptic curve math is needed for these. This block verifies if:</p>

<pre><code>  .  Note: A and B are allowed to be negative, with -1 not uncommon.
  .  Let A = A % N
  .  Let B = B % N
  a  N &gt; 0
  b  gcd(N, 6) = 1
  c  gcd(4*A^3 + 27*B^2, N) = 1
  d  Y^2 mod N = X^3 + A*X + B mod N
  e  M &gt;= N - 2*sqrt(N) + 1
  f  M &lt;= N + 2*sqrt(N) + 1
  g  Q &gt; (N^(1/4)+1)^2
  h  Q &lt; N
  i  M != Q
  j  Q divides M
  .  Note: EC(A,B,N,X,Y) is the point (X,Y) on Y^2 = X^3 + A*X + B, mod N
  .        All values work in affine coordinates, but in theory other
  .        representations work just as well.
  .  Let POINT1 = (M/Q) * EC(A,B,N,X,Y)
  .  Let POINT2 = M * EC(A,B,N,X,Y)  [ = Q * POINT1 ]
  k  POINT1 is not the identity
  l  POINT2 is the identity</code></pre>

</dd>
</dl>

<h2 id="is_aks_prime">is_aks_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is definitely prime"</span> <span class="keyword">if</span> <span class="variable">is_aks_prime</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Takes a non-negative number as input, and returns 1 if the input passes the Agrawal-Kayal-Saxena (AKS) primality test. This is a deterministic unconditional primality test which runs in polynomial time for general input.</p>

<p>While this is an important theoretical algorithm, and makes an interesting example, it is hard to overstate just how impractically slow it is in practice. It is not used for any purpose in non-theoretical work, as it is literally <b>millions</b> of times slower than other algorithms. From R.P. Brent, 2010: &quot;AKS is not a practical algorithm. ECPP is much faster.&quot; We have ECPP, and indeed it is much faster.</p>

<p>This implementation uses theorem 4.1 from Bernstein (2003). It runs substantially faster than the original, v6 revised paper with Lenstra improvements, or the late 2002 improvements of Voloch and Bornemann. The GMP implementation uses a binary segmentation method for modular polynomial multiplication (see Bernstein&#39;s 2007 Quartic paper), which reduces to a single scalar multiplication, at which GMP excels. Because of this, the GMP implementation is likely to be faster once the input is larger than <code>2^33</code>.</p>

<h2 id="is_mersenne_prime">is_mersenne_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"2^607-1 (M607) is a Mersenne prime"</span> <span class="keyword">if</span> <span class="variable">is_mersenne_prime</span><span class="operator">(</span><span class="number">607</span><span class="operator">);</span>
</code></pre>

<p>Takes a non-negative number <code>p</code> as input and returns 1 if the Mersenne number <code>2^p-1</code> is prime. Since an enormous effort has gone into testing these, a list of known Mersenne primes is used to accelerate this. Beyond the highest sequential Mersenne prime (currently 37,156,667) this performs pretesting followed by the Lucas-Lehmer test.</p>

<p>The Lucas-Lehmer test is a deterministic unconditional test that runs very fast compared to other primality methods for numbers of comparable size, and vastly faster than any known general-form primality proof methods. While this test is fast, the GMP implementation is not nearly as fast as specialized programs such as <code>prime95</code>. Additionally, since we use the table for &quot;small&quot; numbers, testing via this function call will only occur for numbers with over 9.8 million digits. At this size, tools such as <code>prime95</code> are greatly preferred.</p>

<h2 id="is_ramanujan_prime">is_ramanujan_prime</h2>

<p>Takes a positive number <code>n</code> as input and returns back either 0 or 1, indicating whether <code>n</code> is a Ramanujan prime. Numbers that can be produced by the functions <a href="#ramanujan_primes">&quot;ramanujan_primes&quot;</a> and <a href="#nth_ramanujan_prime">&quot;nth_ramanujan_prime&quot;</a> will return 1, while all other numbers will return 0.</p>

<p>There is no simple function for this predicate, so Ramanujan primes through at least <code>n</code> are generated, then a search is performed for <code>n</code>. This is not efficient for multiple calls.</p>

<h2 id="is_power">is_power</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a perfect square"</span> <span class="keyword">if</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a perfect cube"</span> <span class="keyword">if</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is a "</span><span class="operator">,</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">),</span> <span class="string">"-th power"</span><span class="operator">;</span>
</code></pre>

<p>Given a single non-negative integer input <code>n</code>, returns k if <code>n = r^k</code> for some integer <code>r &gt; 1, k &gt; 1</code>, and 0 otherwise. The k returned is the largest possible. This can be used in a boolean statement to determine if <code>n</code> is a perfect power.</p>

<p>If given two arguments <code>n</code> and <code>k</code>, returns 1 if <code>n</code> is a <code>k-th</code> power, and 0 otherwise. For example, if <code>k=2</code> then this detects perfect squares. Setting <code>k=0</code> gives behavior like the first case (the largest root is found and its value is returned).</p>

<p>If a third argument is present, it must be a scalar reference. If <code>n</code> is a k-th power, then this will be set to the k-th root of <code>n</code>. For example:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="number">222657534574035968</span><span class="operator">;</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$pow</span> <span class="operator">=</span> <span class="variable">is_power</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$root</span><span class="operator">))</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> = </span><span class="variable">$root</span><span class="string">^</span><span class="variable">$pow</span><span class="string">"</span> <span class="operator">}</span>
  <span class="comment"># prints:  222657534574035968 = 2948^5</span>
</code></pre>

<p>This corresponds to Pari/GP&#39;s <code>ispower</code> function with integer arguments.</p>

<h2 id="is_prime_power">is_prime_power</h2>

<p>Given an integer input <code>n</code>, returns <code>k</code> if <code>n = p^k</code> for some prime p, and zero otherwise.</p>

<p>If a second argument is present, it must be a scalar reference. If the return value is non-zero, then it will be set to <code>p</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>isprimepower</code> function.</p>

<h2 id="is_square">is_square</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a perfect square, 0 otherwise. This is identical to <code>is_power(n,2)</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>issquare</code> function.</p>

<h2 id="sqrtint">sqrtint</h2>

<p>Given a non-negative integer input <code>n</code>, returns the integer square root. For native integers, this is equal to <code>int(sqrt(n))</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>sqrtint</code> function.</p>

<h2 id="rootint">rootint</h2>

<p>Given an non-negative integer <code>n</code> and positive exponent <code>k</code>, return the integer k-th root of <code>n</code>. This is the largest integer <code>r</code> such that <code>r^k &lt;= n</code>.</p>

<p>If a third argument is present, it must be a scalar reference. It will be set to <code>r^k</code>.</p>

<p>Technically if <code>n</code> is negative and <code>k</code> is odd, the root exists and is equal to <code>sign(n) * |rootint(abs(n),k)</code>. It was decided to follow the behavior of Pari/GP and Math::BigInt and disallow negative <code>n</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>sqrtnint</code> function.</p>

<h2 id="logint">logint</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"decimal digits: "</span><span class="operator">,</span> <span class="number">1</span><span class="operator">+</span><span class="variable">logint</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">10</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"digits in base 12: "</span><span class="operator">,</span> <span class="number">1</span><span class="operator">+</span><span class="variable">logint</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">12</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$be</span><span class="operator">;</span> <span class="keyword">my</span> <span class="variable">$e</span> <span class="operator">=</span> <span class="variable">logint</span><span class="operator">(</span><span class="number">1000</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$be</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"smallest power of 2 less than 1000:  2^</span><span class="variable">$e</span><span class="string"> = </span><span class="variable">$be</span><span class="string">"</span><span class="operator">;</span>
</code></pre>

<p>Given a non-zero positive integer <code>n</code> and an integer base <code>b</code> greater than 1, returns the largest integer <code>e</code> such that <code>b^e &lt;= n</code>.</p>

<p>If a third argument is present, it must be a scalar reference. It will be set to <code>b^e</code>.</p>

<p>This corresponds to Pari/GP&#39;s <code>logint</code> function.</p>

<h2 id="lucasu">lucasu</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Fibonacci(</span><span class="variable">$_</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">lucasu</span><span class="operator">(</span><span class="number">1</span><span class="operator">,-</span><span class="number">1</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">0</span><span class="operator">..</span><span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>P</code>, <code>Q</code>, and the non-negative integer <code>k</code>, computes <code>U_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>. These include the Fibonacci numbers (<code>1,-1</code>), the Pell numbers (<code>2,-1</code>), the Jacobsthal numbers (<code>1,-2</code>), the Mersenne numbers (<code>3,2</code>), and more.</p>

<p>This corresponds to OpenPFGW&#39;s <code>lucasU</code> function and gmpy2&#39;s <code>lucasu</code> function.</p>

<h2 id="lucasv">lucasv</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Lucas(</span><span class="variable">$_</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">lucasv</span><span class="operator">(</span><span class="number">1</span><span class="operator">,-</span><span class="number">1</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">0</span><span class="operator">..</span><span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>P</code>, <code>Q</code>, and the non-negative integer <code>k</code>, computes <code>V_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>. These include the Lucas numbers (<code>1,-1</code>).</p>

<p>This corresponds to OpenPFGW&#39;s <code>lucasV</code> function and gmpy2&#39;s <code>lucasv</code> function.</p>

<h2 id="lucas_sequence">lucas_sequence</h2>

<pre><code>  my($U, $V, $Qk) = lucas_sequence($n, $P, $Q, $k)</code></pre>

<p>Computes <code>U_k</code>, <code>V_k</code>, and <code>Q_k</code> for the Lucas sequence defined by <code>P</code>,<code>Q</code>, modulo <code>n</code>. The modular Lucas sequence is used in a number of primality tests and proofs. The following conditions must hold: <code> |P| &lt; n</code> ; <code> |Q| &lt; n</code> ; <code> k &gt;= 0</code> ; <code> n &gt;= 2</code>.</p>

<h2 id="gcd">gcd</h2>

<p>Given a list of integers, returns the greatest common divisor. This is often used to test for <a href="https://oeis.org/wiki/Coprimality">coprimality</a>.</p>

<h2 id="lcm">lcm</h2>

<p>Given a list of integers, returns the least common multiple. Note that we follow the semantics of Mathematica, Pari, and Perl 6, re:</p>

<pre><code>  lcm(0, n) = 0              Any zero in list results in zero return
  lcm(n,-m) = lcm(n, m)      We use the absolute values</code></pre>

<h2 id="gcdext">gcdext</h2>

<p>Given two integers <code>x</code> and <code>y</code>, returns <code>u,v,d</code> such that <code>d = gcd(x,y)</code> and <code>u*x + v*y = d</code>. This uses the extended Euclidian algorithm to compute the values satisfying B&eacute;zout&#39;s Identity.</p>

<p>This corresponds to Pari&#39;s <code>gcdext</code> function, which was renamed from <code>bezout</code> out Pari 2.6. The results will hence match <a>&quot;bezout&quot; in Math::Pari</a>.</p>

<h2 id="chinese">chinese</h2>

<pre><code>  <span class="keyword">say</span> <span class="variable">chinese</span><span class="operator">(</span> <span class="operator">[</span><span class="number">14</span><span class="operator">,</span><span class="number">643</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="number">254</span><span class="operator">,</span><span class="number">419</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="number">87</span><span class="operator">,</span><span class="number">733</span><span class="operator">]</span> <span class="operator">);</span>  <span class="comment"># 87041638</span>
</code></pre>

<p>Solves a system of simultaneous congruences using the Chinese Remainder Theorem (with extension to non-coprime moduli). A list of <code>[a,n]</code> pairs are taken as input, each representing an equation <code>x &equiv; a mod n</code>. If no solution exists, <code>undef</code> is returned. If a solution is returned, the modulus is equal to the lcm of all the given moduli (see <a href="#lcm">&quot;lcm&quot;</a>. In the standard case where all values of <code>n</code> are coprime, this is just the product. The <code>n</code> values must be positive integers, while the <code>a</code> values are integers.</p>

<p>Comparison to similar functions in other software:</p>

<pre><code>  <span class="variable">Math::ModInt::ChineseRemainder</span><span class="operator">:</span>
    <span class="variable">cr_combine</span><span class="operator">(</span> <span class="variable">mod</span><span class="operator">(</span><span class="variable">a1</span><span class="operator">,</span><span class="variable">m1</span><span class="operator">),</span> <span class="variable">mod</span><span class="operator">(</span><span class="variable">a2</span><span class="operator">,</span><span class="variable">m2</span><span class="operator">),</span> <span class="operator">...</span> <span class="operator">)</span>
  
  <span class="variable">Pari</span><span class="operator">/</span><span class="variable">GP</span><span class="operator">:</span>
    <span class="variable">chinese</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">Mod</span><span class="operator">(</span><span class="variable">a1</span><span class="operator">,</span><span class="variable">m1</span><span class="operator">),</span> <span class="variable">Mod</span><span class="operator">(</span><span class="variable">a2</span><span class="operator">,</span><span class="variable">m2</span><span class="operator">),</span> <span class="operator">...</span><span class="operator">]</span> <span class="operator">)</span>
  
  <span class="variable">Mathematica</span><span class="operator">:</span>
    <span class="variable">ChineseRemainder</span><span class="operator">[{</span><span class="variable">a1</span><span class="operator">,</span> <span class="variable">a2</span><span class="operator">,</span> <span class="operator">...</span><span class="operator">}{</span><span class="variable">m1</span><span class="operator">,</span> <span class="variable">m2</span><span class="operator">,</span> <span class="operator">...</span><span class="operator">}]</span>
</code></pre>

<h2 id="vecsum">vecsum</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Totient sum 500,000: "</span><span class="operator">,</span> <span class="variable">vecsum</span><span class="operator">(</span><span class="variable">euler_phi</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="number">500_000</span><span class="operator">));</span>
</code></pre>

<p>Returns the sum of all arguments, each of which must be an integer. This is similar to List::Util&#39;s <a href="../../../lib/List/Util.html#sum0">&quot;sum0&quot; in List::Util</a> function, but has a very important difference. List::Util turns all inputs into doubles and returns a double, which will mean incorrect results with large integers. <code>vecsum</code> sums (signed) integers and returns the untruncated result. Processing is done on native integers while possible.</p>

<h2 id="vecprod">vecprod</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Totient product 5,000: "</span><span class="operator">,</span> <span class="variable">vecprod</span><span class="operator">(</span><span class="variable">euler_phi</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">5_000</span><span class="operator">));</span>
</code></pre>

<p>Returns the product of all arguments, each of which must be an integer. This is similar to List::Util&#39;s <a href="../../../lib/List/Util.html#product">&quot;product&quot; in List::Util</a> function, but keeps all results as integers and automatically switches to bigints if needed.</p>

<h2 id="vecmin">vecmin</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Smallest Totient 100k-200k: "</span><span class="operator">,</span> <span class="variable">vecmin</span><span class="operator">(</span><span class="variable">euler_phi</span><span class="operator">(</span><span class="number">100_000</span><span class="operator">,</span><span class="number">200_000</span><span class="operator">));</span>
</code></pre>

<p>Returns the minimum of all arguments, each of which must be an integer. This is similar to List::Util&#39;s <a href="../../../lib/List/Util.html#min">&quot;min&quot; in List::Util</a> function, but has a very important difference. List::Util turns all inputs into doubles and returns a double, which gives incorrect results with large integers. <code>vecmin</code> validates and compares all results as integers. The validation step will make it a little slower than <a href="../../../lib/List/Util.html#min">&quot;min&quot; in List::Util</a> but this prevents accidental and unintentional use of floats.</p>

<h2 id="vecmax">vecmax</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Largest Totient 100k-200k: "</span><span class="operator">,</span> <span class="variable">vecmax</span><span class="operator">(</span><span class="variable">euler_phi</span><span class="operator">(</span><span class="number">100_000</span><span class="operator">,</span><span class="number">200_000</span><span class="operator">));</span>
</code></pre>

<p>Returns the maximum of all arguments, each of which must be an integer. This is similar to List::Util&#39;s <a href="../../../lib/List/Util.html#max">&quot;max&quot; in List::Util</a> function, but has a very important difference. List::Util turns all inputs into doubles and returns a double, which gives incorrect results with large integers. <code>vecmax</code> validates and compares all results as integers. The validation step will make it a little slower than <a href="../../../lib/List/Util.html#max">&quot;max&quot; in List::Util</a> but this prevents accidental and unintentional use of floats.</p>

<h2 id="vecreduce">vecreduce</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Count of non-zero elements: "</span><span class="operator">,</span> <span class="variable">vecreduce</span> <span class="operator">{</span> <span class="variable">$a</span> <span class="operator">+</span> <span class="operator">!!</span><span class="variable">$b</span> <span class="operator">}</span> <span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="variable">@v</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$checksum</span> <span class="operator">=</span> <span class="variable">vecreduce</span> <span class="operator">{</span> <span class="variable">$a</span> <span class="operator">^</span> <span class="variable">$b</span> <span class="operator">}</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">twin_primes</span><span class="operator">(</span><span class="number">1000000</span><span class="operator">)</span><span class="operator">}</span><span class="operator">;</span>
</code></pre>

<p>Does a reduce operation via left fold. Takes a block and a list as arguments. The block uses the special local variables <code>a</code> and <code>b</code> representing the accumulation and next element respectively, with the result of the block being used for the new accumulation. No initial element is used, so <code>undef</code> will be returned with an empty list.</p>

<p>The interface is exactly the same as <a href="../../../lib/List/Util.html#reduce">&quot;reduce&quot; in List::Util</a>. This was done to increase portability and minimize confusion. See chapter 7 of Higher Order Perl (or many other references) for a discussion of reduce with empty or singular-element lists. It is often a good idea to give an identity element as the first list argument.</p>

<p>While operations like <a>vecmin</a>, <a>vecmax</a>, <a>vecsum</a>, <a>vecprod</a>, etc. can be fairly easily done with this function, it will not be as efficient. There are a wide variety of other functions that can be easily made with reduce, making it a useful tool.</p>

<h2 id="vecany">vecany</h2>

<h2 id="vecall">vecall</h2>

<h2 id="vecnone">vecnone</h2>

<h2 id="vecnotall">vecnotall</h2>

<h2 id="vecfirst">vecfirst</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"all values are Carmichael"</span> <span class="keyword">if</span> <span class="variable">vecall</span> <span class="operator">{</span> <span class="variable">is_carmichael</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@n</span><span class="operator">;</span>
</code></pre>

<p>Short circuit evaluations of a block over a list. Takes a block and a list as arguments. The block is called with <code>$_</code> set to each list element, and evaluation on list elements is done until either all list values have been evaluated or the result condition can be determined. For instance, in the example of <code>vecall</code> above, evaluation stops as soon as any value returns false.</p>

<p>The interface is exactly the same as the <code>any</code>, <code>all</code>, <code>none</code>, <code>notall</code>, and <code>first</code> functions in <a href="../../../lib/List/Util.html">List::Util</a>. This was done to increase portability and minimize confusion. Unlike other vector functions like <code>vecmax</code>, <code>vecmax</code>, <code>vecsum</code>, etc. there is no added value to using these versus the ones from <a href="../../../lib/List/Util.html">List::Util</a>. They are here for convenience.</p>

<p>These operations can fairly easily be mapped to <code><span class="keyword">scalar</span><span class="operator">(</span><span class="keyword">grep</span> <span class="operator">{...}</span> <span class="variable">@n</span><span class="operator">)</span>
</code>, but that does not short-circuit and is less obvious.</p>

<h2 id="vecfirstidx">vecfirstidx</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"first Carmichael is index "</span><span class="operator">,</span> <span class="variable">vecfirstidx</span> <span class="operator">{</span> <span class="variable">is_carmichael</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@n</span><span class="operator">;</span>
</code></pre>

<p>Returns the index of the first element in a list that evaluates to true. Just like vecfirst, but returns the index instead of the value. Returns -1 if the item could not be found.</p>

<p>This interface matches <code>firstidx</code> and <code>first_index</code> from <a href="../../../lib/List/MoreUtils.html">List::MoreUtils</a>.</p>

<h2 id="vecextract">vecextract</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Power set: "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">" "</span><span class="operator">,</span><span class="variable">vecextract</span><span class="operator">(\</span><span class="variable">@v</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">))</span> <span class="keyword">for</span> <span class="number">0</span><span class="operator">..</span><span class="number">2</span><span class="operator">**</span><span class="keyword">scalar</span><span class="operator">(</span><span class="variable">@v</span><span class="operator">)-</span><span class="number">1</span><span class="operator">;</span>
  <span class="variable">@word</span> <span class="operator">=</span> <span class="variable">vecextract</span><span class="operator">(</span><span class="operator">[</span><span class="string">"a"</span><span class="operator">..</span><span class="string">"z"</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="number">15</span><span class="operator">,</span> <span class="number">17</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">12</span><span class="operator">,</span> <span class="number">4</span><span class="operator">]</span><span class="operator">);</span>
</code></pre>

<p>Extracts elements from an array reference based on a mask, with the result returned as an array. The mask is either an unsigned integer which is treated as a bit mask, or an array reference containing integer indices.</p>

<p>If the second argument is an integer, each bit set in the mask results in the corresponding element from the array reference to be returned. Bits are read from the right, so a mask of <code>1</code> returns the first element, while <code>5</code> will return the first and third. The mask may be a bigint.</p>

<p>If the second argument is an array reference, then its elements will be used as zero-based indices into the first array. Duplicate values are allowed and the ordering is preserved. Hence these are equivalent:</p>

<pre><code>    <span class="variable">vecextract</span><span class="operator">(</span><span class="variable">$aref</span><span class="operator">,</span> <span class="variable">$iref</span><span class="operator">);</span>
    <span class="variable">@$aref</span><span class="operator">[</span><span class="variable">@$iref</span><span class="operator">]</span><span class="operator">;</span>
</code></pre>

<h2 id="todigits">todigits</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"product of digits of n: "</span><span class="operator">,</span> <span class="variable">vecprod</span><span class="operator">(</span><span class="variable">todigits</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">));</span>
</code></pre>

<p>Given an integer <code>n</code>, return an array of digits of <code>|n|</code>. An optional second integer argument specifies a base (default 10). For example, given a base of 2, this returns an array of binary digits of <code>n</code>. An optional third argument specifies a length for the returned array. The result will be either have upper digits truncated or have leading zeros added. This is most often used with base 2, 8, or 16.</p>

<p>The values returned may be read-only. <code>todigits(0)</code> returns an empty array. The base must be at least 2, and is limited to an int. Length must be at least zero and is limited to an int.</p>

<p>This corresponds to Pari&#39;s <code>digits</code> and <code>binary</code> functions, and Mathematica&#39;s <code>IntegerDigits</code> function.</p>

<h2 id="todigitstring">todigitstring</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"decimal 456 in hex is "</span><span class="operator">,</span> <span class="variable">todigitstring</span><span class="operator">(</span><span class="number">456</span><span class="operator">,</span> <span class="number">16</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"last 4 bits of </span><span class="variable">$n</span><span class="string"> are: "</span><span class="operator">,</span> <span class="variable">todigitstring</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">4</span><span class="operator">);</span>
</code></pre>

<p>Similar to <a href="#todigits">&quot;todigits&quot;</a> but returns a string. For bases &lt;= 10, this is equivalent to joining the array returned by <a href="#todigits">&quot;todigits&quot;</a>. For bases between 11 and 36, lower case characters <code>a</code> to <code>z</code> are used to represent larger values. This makes <code>todigitstring($n,16)</code> return a usable hex string.</p>

<p>This corresponds to Mathematica&#39;s <code>IntegerString</code> function.</p>

<h2 id="fromdigits">fromdigits</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"hex 1c8 in decimal is "</span><span class="operator">,</span> <span class="variable">fromdigits</span><span class="operator">(</span><span class="string">"1c8"</span><span class="operator">,</span> <span class="number">16</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"Base 3 array to number is: "</span><span class="operator">,</span> <span class="variable">fromdigits</span><span class="operator">(</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span><span class="number">3</span><span class="operator">);</span>
</code></pre>

<p>This takes either a string or array reference, and an optional base (default 10). With a string, each character will be interpreted as a digit in the given base, with both upper and lower case denoting values 11 through 36. With an array reference, the values indicate the entries in that location, and values larger than the base are allowed (results are carried). The result is a number (either a native integer or a bigint).</p>

<p>This corresponds to Pari&#39;s <code>fromdigits</code> function and Mathematica&#39;s <code>FromDigits</code> function.</p>

<h2 id="sumdigits">sumdigits</h2>

<pre><code>  <span class="comment"># Sum digits of primes to 1 million.</span>
  <span class="keyword">my</span> <span class="variable">$s</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span> <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">$s</span> <span class="operator">+=</span> <span class="variable">sumdigits</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">);</span> <span class="operator">}</span> <span class="number">1e6</span><span class="operator">;</span> <span class="keyword">say</span> <span class="variable">$s</span><span class="operator">;</span>
</code></pre>

<p>Given an input <code>n</code>, return the sum of the digits of <code>n</code>. Any non-digit characters of <code>n</code> are ignored (including negative signs and decimal points). This is similar to the command <code>vecsum(split(//,$n))</code> but faster, allows non-positive-integer inputs, and can sum in other bases.</p>

<p>An optional second argument indicates the base of the input number. This defaults to 10, and must be between 2 and 36. Any character that is outside the range <code>0</code> to <code>base-1</code> will be ignored.</p>

<p>If no base is given and the input number <code>n</code> begins with <code>0x</code> or <code>0b</code> then it will be interpreted as a string in base 16 or 2 respectively.</p>

<p>Regardless of the base, the output sum is a decimal number.</p>

<p>This is similar but not identical to Pari&#39;s <code>sumdigits</code> function from version 2.8 and later. The Pari/GP function always takes the input as a decimal number, uses the optional base as a base to first convert to, then sums the digits. This can be done with either <code>vecsum(todigits($n, $base))</code> or <code>sumdigits(todigitstring($n,$base))</code>.</p>

<h2 id="invmod">invmod</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The inverse of 42 mod 2017 = "</span><span class="operator">,</span> <span class="variable">invmod</span><span class="operator">(</span><span class="number">42</span><span class="operator">,</span><span class="number">2017</span><span class="operator">);</span>
</code></pre>

<p>Given two integers <code>a</code> and <code>n</code>, return the inverse of <code>a</code> modulo <code>n</code>. If not defined, undef is returned. If defined, then the return value multiplied by <code>a</code> equals <code>1</code> modulo <code>n</code>.</p>

<p>The results correspond to the Pari result of <code>lift(Mod(1/a,n))</code>. The semantics with respect to negative arguments match Pari. Notably, a negative <code>n</code> is negated, which is different from Math::BigInt, but in both cases the return value is still congruent to <code>1</code> modulo <code>n</code> as expected.</p>

<h2 id="sqrtmod">sqrtmod</h2>

<p>Given two integers <code>a</code> and <code>n</code>, return the square root of <code>a</code> mod <code>n</code>. If no square root exists, undef is returned. If defined, the return value <code>r</code> will always satisfy <code>r^2 = a mod n</code>.</p>

<p>If the modulus is prime, the function will always return <code>r</code>, the smaller of the two square roots (the other being <code>-r mod p</code>. If the modulus is composite, one of possibly many square roots will be returned, and it will not necessarily be the smallest.</p>

<h2 id="addmod">addmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>n</code> is positive, return <code>(a+b) mod n</code>. This is particularly useful when dealing with numbers that are larger than a half-word but still native size. No bigint package is needed and this can be 10-200x faster than using one.</p>

<h2 id="mulmod">mulmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>n</code> is positive, return <code>(a*b) mod n</code>. This is particularly useful when <code>n</code> fits in a native integer. No bigint package is needed and this can be 10-200x faster than using one.</p>

<h2 id="powmod">powmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>n</code> is positive, return <code>(a ** b) mod n</code>. Typically binary exponentiation is used, so the process is very efficient. With native size inputs, no bigint library is needed.</p>

<h2 id="divmod">divmod</h2>

<p>Given three integers <code>a</code>, <code>b</code>, and <code>n</code> where <code>n</code> is positive, return <code>(a/b) mod n</code>. This is done as <code>(a * (1/b mod n)) mod n</code>. If no inverse of <code>b</code> mod <code>n</code> exists then undef if returned.</p>

<h2 id="valuation">valuation</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is divisible by 2 "</span><span class="operator">,</span> <span class="variable">valuation</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span><span class="number">2</span><span class="operator">),</span> <span class="string">" times."</span><span class="operator">;</span>
</code></pre>

<p>Given integers <code>n</code> and <code>k</code>, returns the numbers of times <code>n</code> is divisible by <code>k</code>. This is a very limited version of the algebraic valuation meaning, just applied to integers. This corresponds to Pari&#39;s <code>valuation</code> function. <code>0</code> is returned if <code>n</code> or <code>k</code> is one of the values <code>-1</code>, <code>0</code>, or <code>1</code>.</p>

<h2 id="hammingweight">hammingweight</h2>

<p>Given an integer <code>n</code>, returns the binary Hamming weight of <code>abs(n)</code>. This is also called the population count, and is the number of 1s in the binary representation. This corresponds to Pari&#39;s <code>hammingweight</code> function for <code>t_INT</code> arguments.</p>

<h2 id="is_square_free">is_square_free</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> has no repeating factors"</span> <span class="keyword">if</span> <span class="variable">is_square_free</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns 1 if the input <code>n</code> has no repeated factor.</p>

<h2 id="is_carmichael">is_carmichael</h2>

<pre><code>  <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">1e6</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="keyword">if</span> <span class="variable">is_carmichael</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="comment"># Carmichaels under 1,000,000</span>
</code></pre>

<p>Returns 1 if the input <code>n</code> is a Carmichael number. These are composites that satisfy <code>b^(n-1) &equiv; 1 mod n</code> for all <code>1 &lt; b &lt; n</code> relatively prime to <code>n</code>. Alternately Korselt&#39;s theorem says these are composites such that <code>n</code> is square-free and <code>p-1</code> divides <code>n-1</code> for all prime divisors <code>p</code> of <code>n</code>.</p>

<p>For inputs larger than 50 digits after removing very small factors, this uses a probabilistic test since factoring the number could take unreasonably long. The first 150 primes are used for testing. Any that divide <code>n</code> are checked for square-free-ness and the Korselt condition, while those that do not divide <code>n</code> are used as the pseudoprime base. The chances of a non-Carmichael passing this test are less than <code>2^-150</code>.</p>

<p>This is the <a href="http://oeis.org/A002997">OEIS series A002997</a>.</p>

<h2 id="is_quasi_carmichael">is_quasi_carmichael</h2>

<p>Returns 0 if the input <code>n</code> is not a quasi-Carmichael number, and the number of bases otherwise. These are square-free composites that satisfy <code>p+b</code> divides <code>n+b</code> for all prime factors <code>p</code> or <code>n</code> and for one or more non-zero integer <code>b</code>.</p>

<p>This is the <a href="http://oeis.org/A257750">OEIS series A257750</a>.</p>

<h2 id="is_semiprime">is_semiprime</h2>

<p>Given a positive integer <code>n</code>, returns 1 if <code>n</code> is a semiprime, 0 otherwise. A semiprime is the product of exactly two primes.</p>

<p>The boolean result is the same as <code>scalar(factor(n)) == 2</code>, but this function performs shortcuts that can greatly speed up the operation.</p>

<h2 id="is_fundamental">is_fundamental</h2>

<p>Given an integer <code>d</code>, returns 1 if <code>d</code> is a fundamental discriminant, 0 otherwise. We consider 1 to be a fundamental discriminant.</p>

<p>This is the <a href="http://oeis.org/A003658">OEIS series A003658</a> (positive) and <a href="http://oeis.org/A003657">OEIS series A003657</a> (negative).</p>

<p>This corresponds to Pari&#39;s <code>isfundamental</code> function.</p>

<h2 id="is_totient">is_totient</h2>

<p>Given an integer <code>n</code>, returns 1 if there exists an integer <code>x</code> where <code>euler_phi(x) == n</code>.</p>

<p>This corresponds to Pari&#39;s <code>istotient</code> function, though without the optional second argument to return an <code>x</code>. <a>Math::NumSeq::Totient</a> also has a similar function.</p>

<h2 id="is_pillai">is_pillai</h2>

<p>Given a positive integer <code>n</code>, if there exists a <code>v</code> where <code>v! % n == n-1</code> and <code>n % v != 1</code>, then <code>v</code> is returned. Otherwise 0.</p>

<p>For n prime, this is the <a href="http://oeis.org/A063980">OEIS series A063980</a>.</p>

<h2 id="is_polygonal">is_polygonal</h2>

<p>Given integers <code>x</code> and <code>s</code>, return 1 if x is an s-gonal number, 0 otherwise. <code>s</code> must be greater than 2.</p>

<p>If a third argument is present, it must be a scalar reference. It will be set to n if x is the nth s-gonal number. If the function returns 0, then it will be unchanged.</p>

<p>This corresponds to Pari&#39;s <code>ispolygonal</code> function.</p>

<h2 id="moebius">moebius</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> is square free"</span> <span class="keyword">if</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">200</span><span class="operator">);</span> <span class="keyword">say</span> <span class="string">"Mertens(200) = </span><span class="variable">$sum</span><span class="string">"</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="string">"Mertens(2000) = "</span><span class="operator">,</span> <span class="variable">vecsum</span><span class="operator">(</span><span class="variable">moebius</span><span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="number">2000</span><span class="operator">));</span>
</code></pre>

<p>Returns &mu;(n), the M&ouml;bius function (also known as the Moebius, Mobius, or MoebiusMu function) for an integer input. This function is 1 if <code>n = 1</code>, 0 if <code>n</code> is not square-free (i.e. <code>n</code> has a repeated factor), and <code>-1^t</code> if <code>n</code> is a product of <code>t</code> distinct primes. This is an important function in prime number theory. Like SAGE, we define <code>moebius(0) = 0</code> for convenience.</p>

<p>If called with two arguments, they define a range <code>low</code> to <code>high</code>, and the function returns an array with the value of the M&ouml;bius function for every n from low to high inclusive. Large values of high will result in a lot of memory use. The algorithm used for ranges is Del&eacute;glise and Rivat (1996) algorithm 4.1, which is a segmented version of Lioen and van de Lune (1994) algorithm 3.2.</p>

<p>The return values are read-only constants. This should almost never come up, but it means trying to modify aliased return values will cause an exception (modifying the returned scalar or array is fine).</p>

<h2 id="mertens">mertens</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Mertens(10M) = "</span><span class="operator">,</span> <span class="variable">mertens</span><span class="operator">(</span><span class="number">10_000_000</span><span class="operator">);</span>   <span class="comment"># = 1037</span>
</code></pre>

<p>Returns M(n), the Mertens function for a non-negative integer input. This function is defined as <code>sum(moebius(1..n))</code>, but calculated more efficiently for large inputs. For example, computing Mertens(100M) takes:</p>

<pre><code>   time    approx mem
     0.4s      0.1MB   mertens(100_000_000)
     3.0s    880MB     vecsum(moebius(1,100_000_000))
    56s        0MB     $sum += moebius($_) for 1..100_000_000</code></pre>

<p>The summation of individual terms via factoring is quite expensive in time, though uses O(1) space. Using the range version of moebius is much faster, but returns a 100M element array which, even though they are shared constants, is not good for memory at this size. In comparison, this function will generate the equivalent output via a sieving method that is relatively memory frugal and very fast. The current method is a simple <code>n^1/2</code> version of Del&eacute;glise and Rivat (1996), which involves calculating all moebius values to <code>n^1/2</code>, which in turn will require prime sieving to <code>n^1/4</code>.</p>

<p>Various algorithms exist for this, using differing quantities of &mu;(n). The simplest way is to efficiently sum all <code>n</code> values. Benito and Varona (2008) show a clever and simple method that only requires <code>n/3</code> values. Del&eacute;glise and Rivat (1996) describe a segmented method using only <code>n^1/3</code> values. The current implementation does a simple non-segmented <code>n^1/2</code> version of their method. Kuznetsov (2011) gives an alternate method that he indicates is even faster. Lastly, one of the advanced prime count algorithms could be theoretically used to create a faster solution.</p>

<h2 id="euler_phi">euler_phi</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"The Euler totient of </span><span class="variable">$n</span><span class="string"> is "</span><span class="operator">,</span> <span class="variable">euler_phi</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns &phi;(n), the Euler totient function (also called Euler&#39;s phi or phi function) for an integer value. This is an arithmetic function which counts the number of positive integers less than or equal to <code>n</code> that are relatively prime to <code>n</code>.</p>

<p>Given the definition used, <code>euler_phi</code> will return 0 for all <code>n &lt; 1</code>. This follows the logic used by SAGE. Mathematica and Pari return <code>euler_phi(-n)</code> for <code>n &lt; 0</code>. Mathematica returns 0 for <code>n = 0</code>, Pari pre-2.6.2 raises an exception, and Pari 2.6.2 and newer returns 2.</p>

<p>If called with two arguments, they define a range <code>low</code> to <code>high</code>, and the function returns a list with the totient of every n from low to high inclusive.</p>

<h2 id="jordan_totient">jordan_totient</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Jordan's totient J_</span><span class="variable">$k</span><span class="string">(</span><span class="variable">$n</span><span class="string">) is "</span><span class="operator">,</span> <span class="variable">jordan_totient</span><span class="operator">(</span><span class="variable">$k</span><span class="operator">,</span> <span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Returns Jordan&#39;s totient function for a given integer value. Jordan&#39;s totient is a generalization of Euler&#39;s totient, where <code>jordan_totient(1,$n) == euler_totient($n)</code> This counts the number of k-tuples less than or equal to n that form a coprime tuple with n. As with <code>euler_phi</code>, 0 is returned for all <code>n &lt; 1</code>. This function can be used to generate some other useful functions, such as the Dedekind psi function, where <code>psi(n) = J(2,n) / J(1,n)</code>.</p>

<h2 id="ramanujan_sum">ramanujan_sum</h2>

<p>Returns Ramanujan&#39;s sum of the two positive variables <code>k</code> and <code>n</code>. This is the sum of the nth powers of the primitive k-th roots of unity.</p>

<h2 id="exp_mangoldt">exp_mangoldt</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"exp(lambda(</span><span class="variable">$_</span><span class="string">)) = "</span><span class="operator">,</span> <span class="variable">exp_mangoldt</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">100</span><span class="operator">;</span>
</code></pre>

<p>Returns EXP(&Lambda;(n)), the exponential of the Mangoldt function (also known as von Mangoldt&#39;s function) for an integer value. The Mangoldt function is equal to log p if n is prime or a power of a prime, and 0 otherwise. We return the exponential so all results are integers. Hence the return value for <code>exp_mangoldt</code> is:</p>

<pre><code>   p   if n = p^m for some prime p and integer m &gt;= 1
   1   otherwise.</code></pre>

<h2 id="liouville">liouville</h2>

<p>Returns &lambda;(n), the Liouville function for a non-negative integer input. This is -1 raised to &Omega;(n) (the total number of prime factors).</p>

<h2 id="chebyshev_theta">chebyshev_theta</h2>

<pre><code>  <span class="keyword">say</span> <span class="variable">chebyshev_theta</span><span class="operator">(</span><span class="number">10000</span><span class="operator">);</span>
</code></pre>

<p>Returns &theta;(n), the first Chebyshev function for a non-negative integer input. This is the sum of the logarithm of each prime where <code>p &lt;= n</code>. This is effectively:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$s</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">$s</span> <span class="operator">+=</span> <span class="keyword">log</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">$n</span><span class="operator">;</span>  <span class="keyword">return</span> <span class="variable">$s</span><span class="operator">;</span>
</code></pre>

<h2 id="chebyshev_psi">chebyshev_psi</h2>

<pre><code>  <span class="keyword">say</span> <span class="variable">chebyshev_psi</span><span class="operator">(</span><span class="number">10000</span><span class="operator">);</span>
</code></pre>

<p>Returns &psi;(n), the second Chebyshev function for a non-negative integer input. This is the sum of the logarithm of each prime power where <code>p^k &lt;= n</code> for an integer k. An alternate but slower computation is as the summatory Mangoldt function, such as:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$s</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>  <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">{</span> <span class="variable">$s</span> <span class="operator">+=</span> <span class="keyword">log</span><span class="operator">(</span><span class="variable">exp_mangoldt</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">))</span> <span class="operator">}</span>  <span class="keyword">return</span> <span class="variable">$s</span><span class="operator">;</span>
</code></pre>

<h2 id="divisor_sum">divisor_sum</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"Sum of divisors of </span><span class="variable">$n</span><span class="string">:"</span><span class="operator">,</span> <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span> <span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"sigma_2(</span><span class="variable">$n</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"Number of divisors: sigma_0(</span><span class="variable">$n</span><span class="string">) = "</span><span class="operator">,</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</code></pre>

<p>This function takes a positive integer as input and returns the sum of its divisors, including 1 and itself. An optional second argument <code>k</code> may be given, which will result in the sum of the <code>k-th</code> powers of the divisors to be returned.</p>

<p>This is known as the sigma function (see Hardy and Wright section 16.7). The API is identical to Pari/GP&#39;s <code>sigma</code> function, and not dissimilar to Mathematica&#39;s <code>DivisorSigma[k,n]</code> function. This function is useful for calculating things like aliquot sums, abundant numbers, perfect numbers, etc.</p>

<p>With various <code>k</code> values, the results are the OEIS sequences <a href="http://oeis.org/A000005">OEIS series A000005</a> (<code>k=0</code>, number of divisors), <a href="http://oeis.org/A000203">OEIS series A000203</a> (<code>k=1</code>, sum of divisors), <a href="http://oeis.org/A001157">OEIS series A001157</a> (<code>k=2</code>, sum of squares of divisors), <a href="http://oeis.org/A001158">OEIS series A001158</a> (<code>k=4</code>, sum of cubes of divisors), etc.</p>

<p>The second argument may also be a code reference, which is called for each divisor and the results are summed. This allows computation of other functions, but will be less efficient than using the numeric second argument. This corresponds to Pari/GP&#39;s <code>sumdiv</code> function.</p>

<p>An example of the 5th Jordan totient (OEIS A059378):</p>

<pre><code>  <span class="variable">divisor_sum</span><span class="operator">(</span> <span class="variable">$n</span><span class="operator">,</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$d</span><span class="operator">=</span><span class="keyword">shift</span><span class="operator">;</span> <span class="variable">$d</span><span class="operator">**</span><span class="number">5</span> <span class="operator">*</span> <span class="variable">moebius</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">/</span><span class="variable">$d</span><span class="operator">);</span> <span class="operator">}</span> <span class="operator">);</span>
</code></pre>

<p>though we have a function <a href="#jordan_totient">&quot;jordan_totient&quot;</a> which is more efficient.</p>

<p>For numeric second arguments (sigma computations), the result will be a bigint if necessary. For the code reference case, the user must take care to return bigints if overflow will be a concern.</p>

<h2 id="ramanujan_tau">ramanujan_tau</h2>

<p>Takes a positive integer as input and returns the value of Ramanujan&#39;s tau function. The result is a signed integer. This corresponds to Pari v2.8&#39;s <code>tauramanujan</code> function and Mathematica&#39;s <code>RamanujanTau</code> function.</p>

<p>This currently uses a simple method based on divisor sums, which does not have a good computational growth rate. Pari&#39;s implementation uses Hurwitz class numbers and is more efficient for large inputs.</p>

<h2 id="primorial">primorial</h2>

<pre><code>  <span class="variable">$prim</span> <span class="operator">=</span> <span class="variable">primorial</span><span class="operator">(</span><span class="number">11</span><span class="operator">);</span> <span class="comment">#        11# = 2*3*5*7*11 = 2310</span>
</code></pre>

<p>Returns the primorial <code>n#</code> of the positive integer input, defined as the product of the prime numbers less than or equal to <code>n</code>. This is the <a href="http://oeis.org/A034386">OEIS series A034386</a>: primorial numbers second definition.</p>

<pre><code>  primorial(0)  == 1
  primorial($n) == pn_primorial( prime_count($n) )</code></pre>

<p>The result will be a <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> object if it is larger than the native bit size.</p>

<p>Be careful about which version (<code>primorial</code> or <code>pn_primorial</code>) matches the definition you want to use. Not all sources agree on the terminology, though they should give a clear definition of which of the two versions they mean. OEIS, Wikipedia, and Mathworld are all consistent, and these functions should match that terminology. This function should return the same result as the <code>mpz_primorial_ui</code> function added in GMP 5.1.</p>

<h2 id="pn_primorial">pn_primorial</h2>

<pre><code>  <span class="variable">$prim</span> <span class="operator">=</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span> <span class="comment">#      p_5# = 2*3*5*7*11 = 2310</span>
</code></pre>

<p>Returns the primorial number <code>p_n#</code> of the positive integer input, defined as the product of the first <code>n</code> prime numbers (compare to the factorial, which is the product of the first <code>n</code> natural numbers). This is the <a href="http://oeis.org/A002110">OEIS series A002110</a>: primorial numbers first definition.</p>

<pre><code>  pn_primorial(0)  == 1
  pn_primorial($n) == primorial( nth_prime($n) )</code></pre>

<p>The result will be a <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> object if it is larger than the native bit size.</p>

<h2 id="consecutive_integer_lcm">consecutive_integer_lcm</h2>

<pre><code>  <span class="variable">$lcm</span> <span class="operator">=</span> <span class="variable">consecutive_integer_lcm</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Given an unsigned integer argument, returns the least common multiple of all integers from 1 to <code>n</code>. This can be done by manipulation of the primes up to <code>n</code>, resulting in much faster and memory-friendly results than using a factorial.</p>

<h2 id="partitions">partitions</h2>

<p>Calculates the partition function p(n) for a non-negative integer input. This is the number of ways of writing the integer n as a sum of positive integers, without restrictions. This corresponds to Pari&#39;s <code>numbpart</code> function and Mathematica&#39;s <code>PartitionsP</code> function. The values produced in order are <a href="http://oeis.org/A000041">OEIS series A000041</a>.</p>

<p>This uses a combinatorial calculation, which means it will not be very fast compared to Pari, Mathematica, or FLINT which use the Rademacher formula using multi-precision floating point. In 10 seconds:</p>

<pre><code>           <span class="number">70</span>    <span class="variable">Integer::Partition</span>
           <span class="number">90</span>    <span class="variable">MPU</span> <span class="variable">forpart</span> <span class="operator">{</span> <span class="variable">$n</span><span class="operator">++</span> <span class="operator">}</span>
                  <span class="number">10_000</span>    <span class="variable">MPU</span> <span class="variable">pure</span> <span class="variable">Perl</span> <span class="variable">partitions</span>
                 <span class="number">250_000</span>    <span class="variable">MPU</span> <span class="variable">GMP</span> <span class="variable">partitions</span>
              <span class="number">35_000_000</span>    <span class="variable">Pari's</span> <span class="variable">numbpart</span>
             <span class="number">500_000_000</span>    <span class="variable">Jonathan</span> <span class="variable">Bober's</span> <span class="variable">partitions_c</span><span class="operator">.</span><span class="variable">cc</span> <span class="variable">v0</span><span class="number">.6</span>
</code></pre>

<p>If you want the enumerated partitions, see <a href="#forpart">&quot;forpart&quot;</a>.</p>

<h2 id="carmichael_lambda">carmichael_lambda</h2>

<p>Returns the Carmichael function (also called the reduced totient function, or Carmichael &lambda;(n)) of a positive integer argument. It is the smallest positive integer <code>m</code> such that <code>a^m = 1 mod n</code> for every integer <code>a</code> coprime to <code>n</code>. This is <a href="http://oeis.org/A002322">OEIS series A002322</a>.</p>

<h2 id="kronecker">kronecker</h2>

<p>Returns the Kronecker symbol <code>(a|n)</code> for two integers. The possible return values with their meanings for odd prime <code>n</code> are:</p>

<pre><code>   0   a = 0 mod n
   1   a is a quadratic residue mod n       (a = x^2 mod n for some x)
  -1   a is a quadratic non-residue mod n   (no a where a = x^2 mod n)</code></pre>

<p>The Kronecker symbol is an extension of the Jacobi symbol to all integer values of <code>n</code> from the latter&#39;s domain of positive odd values of <code>n</code>. The Jacobi symbol is itself an extension of the Legendre symbol, which is only defined for odd prime values of <code>n</code>. This corresponds to Pari&#39;s <code>kronecker(a,n)</code> function, Mathematica&#39;s <code>KroneckerSymbol[n,m]</code> function, and GMP&#39;s <code>mpz_kronecker(a,n)</code>, <code>mpz_jacobi(a,n)</code>, and <code>mpz_legendre(a,n)</code> functions.</p>

<h2 id="factorial">factorial</h2>

<p>Given positive integer argument <code>n</code>, returns the factorial of <code>n</code>, defined as the product of the integers 1 to <code>n</code> with the special case of <code>factorial(0) = 1</code>. This corresponds to Pari&#39;s <code>factorial(n)</code> and Mathematica&#39;s <code>Factorial[n]</code> functions.</p>

<h2 id="factorialmod">factorialmod</h2>

<p>Given two positive integer arguments <code>n</code> and <code>m</code>, returns <code>n! mod m</code>. This is much faster than computing the large <code>factorial(n)</code> followed by a mod operation.</p>

<p>While very efficient, this is not state of the art. Currently, Fredrik Johansson&#39;s fast multi-point polynomial evaluation method as used in FLINT is the fastest known method. This becomes noticeable for <code>n</code> &gt; <code>10^8</code> or so, and the O(n^.5) versus O(n) complexity makes it quite extreme as the input gets larger.</p>

<h2 id="binomial">binomial</h2>

<p>Given integer arguments <code>n</code> and <code>k</code>, returns the binomial coefficient <code>n*(n-1)*...*(n-k+1)/k!</code>, also known as the choose function. Negative arguments use the <a href="http://arxiv.org/abs/1105.3689/">Kronenburg extensions</a>. This corresponds to Pari&#39;s <code>binomial(n,k)</code> function, Mathematica&#39;s <code>Binomial[n,k]</code> function, and GMP&#39;s <code>mpz_bin_ui</code> function.</p>

<p>For negative arguments, this matches Mathematica. Pari does not implement the <code>n &lt; 0, k &lt;= n</code> extension and instead returns <code>0</code> for this case. GMP&#39;s API does not allow negative <code>k</code> but otherwise matches. <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> does not implement any extensions and the results for <code>n &lt; 0, k </code> 0&gt; are undefined.</p>

<h2 id="hclassno">hclassno</h2>

<p>Returns 12 times the Hurwitz-Kronecker class number of the input integer <code>n</code>. This will always be an integer due to the pre-multiplication by 12. The result is <code>0</code> for any input less than zero or congruent to 1 or 2 mod 4.</p>

<p>This is related to Pari&#39;s <code>qfbhclassno(n)</code> where <code>hclassno(n)</code> for positive <code>n</code> equals <code>12 * qfbhclassno(n)</code> in Pari/GP. This is <a href="http://oeis.org/A259825">OEIS A259825</a>.</p>

<h2 id="bernfrac">bernfrac</h2>

<p>Returns the Bernoulli number <code>B_n</code> for an integer argument <code>n</code>, as a rational number represented by two <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> objects. B_1 = 1/2. This corresponds to Pari&#39;s <code>bernfrac(n)</code> and Mathematica&#39;s <code>BernoulliB</code> functions.</p>

<p>Having a modern version of <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> installed will make a big difference in speed. That module uses a fast Pi/Zeta method. Our pure Perl backend uses the Seidel method as shown by Peter Luschny. This is faster than <a>Math::Pari</a> which uses an older algorithm, but quite a bit slower than modern Pari, Mathematica, or our GMP backend.</p>

<p>This corresponds to Pari&#39;s <code>bernfrac</code> function and Mathematica&#39;s <code>BernoulliB</code> function.</p>

<h2 id="bernreal">bernreal</h2>

<p>Returns the Bernoulli number <code>B_n</code> for an integer argument <code>n</code>, as a <a href="../../../lib/Math/BigFloat.html">Math::BigFloat</a> object using the default precision. An optional second argument may be given specifying the precision to be used.</p>

<p>This corresponds to Pari&#39;s <code>bernreal</code> function.</p>

<h2 id="stirling">stirling</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"s(14,2) = "</span><span class="operator">,</span> <span class="variable">stirling</span><span class="operator">(</span><span class="number">14</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"S(14,2) = "</span><span class="operator">,</span> <span class="variable">stirling</span><span class="operator">(</span><span class="number">14</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="string">"L(14,2) = "</span><span class="operator">,</span> <span class="variable">stirling</span><span class="operator">(</span><span class="number">14</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
</code></pre>

<p>Returns the Stirling numbers of either the first kind (default), the second kind, or the third kind (the unsigned Lah numbers), with the kind selected as an optional third argument. It takes two non-negative integer arguments <code>n</code> and <code>k</code> plus the optional <code>type</code>. This corresponds to Pari&#39;s <code><span class="variable">stirling</span><span class="operator">(</span><span class="variable">n</span><span class="operator">,</span><span class="variable">k</span><span class="operator">,</span><span class="operator">{</span><span class="string">type</span><span class="operator">}</span><span class="operator">)</span>
</code> function and Mathematica&#39;s <code>StirlingS1</code> / <code>StirlingS2</code> functions.</p>

<p>Stirling numbers of the first kind are <code>-1^(n-k)</code> times the number of permutations of <code>n</code> symbols with exactly <code>k</code> cycles. Stirling numbers of the second kind are the number of ways to partition a set of <code>n</code> elements into <code>k</code> non-empty subsets. The Lah numbers are the number of ways to split a set of <code>n</code> elements into <code>k</code> non-empty lists.</p>

<h2 id="harmfrac">harmfrac</h2>

<p>Returns the Harmonic number <code>H_n</code> for an integer argument <code>n</code>, as a rational number represented by two <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> objects. The harmonic numbers are the sum of reciprocals of the first <code>n</code> natural numbers: <code>1 + 1/2 + 1/3 + ... + 1/n</code>.</p>

<p>Binary splitting (Fredrik Johansson&#39;s elegant formulation) is used.</p>

<p>This corresponds to Mathematica&#39;s <code>HarmonicNumber</code> function.</p>

<h2 id="harmreal">harmreal</h2>

<p>Returns the Harmonic number <code>H_n</code> for an integer argument <code>n</code>, as a <a href="../../../lib/Math/BigFloat.html">Math::BigFloat</a> object using the default precision. An optional second argument may be given specifying the precision to be used.</p>

<p>For large <code>n</code> values, using a lower precision may result in faster computation as an asymptotic formula may be used. For precisions of 13 or less, native floating point is used for even more speed.</p>

<h2 id="znorder">znorder</h2>

<pre><code>  <span class="variable">$order</span> <span class="operator">=</span> <span class="variable">znorder</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span> <span class="variable">next_prime</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">16</span><span class="operator">)-</span><span class="number">6</span><span class="operator">);</span>
</code></pre>

<p>Given two positive integers <code>a</code> and <code>n</code>, returns the multiplicative order of <code>a</code> modulo <code>n</code>. This is the smallest positive integer <code>k</code> such that <code>a^k &equiv; 1 mod n</code>. Returns 1 if <code>a = 1</code>. Returns undef if <code>a = 0</code> or if <code>a</code> and <code>n</code> are not coprime, since no value will result in 1 mod n.</p>

<p>This corresponds to Pari&#39;s <code>znorder(Mod(a,n))</code> function and Mathematica&#39;s <code>MultiplicativeOrder[a,n]</code> function.</p>

<h2 id="znprimroot">znprimroot</h2>

<p>Given a positive integer <code>n</code>, returns the smallest primitive root of <code>(Z/nZ)^*</code>, or <code>undef</code> if no root exists. A root exists when <code>euler_phi($n) == carmichael_lambda($n)</code>, which will be true for all prime <code>n</code> and some composites.</p>

<p><a href="http://oeis.org/A033948">OEIS A033948</a> is a sequence of integers where the primitive root exists, while <a href="http://oeis.org/A046145">OEIS A046145</a> is a list of the smallest primitive roots, which is what this function produces.</p>

<h2 id="is_primitive_root">is_primitive_root</h2>

<p>Given two non-negative numbers <code>a</code> and <code>n</code>, returns <code>1</code> if <code>a</code> is a primitive root modulo <code>n</code>, and <code>0</code> if not. If <code>a</code> is a primitive root, then <code>euler_phi(n)</code> is the smallest <code>e</code> for which <code>a^e = 1 mod n</code>.</p>

<h2 id="znlog">znlog</h2>

<pre><code>  $k = znlog($a, $g, $p)</code></pre>

<p>Returns the integer <code>k</code> that solves the equation <code>a = g^k mod p</code>, or undef if no solution is found. This is the discrete logarithm problem.</p>

<p>The implementation for native integers first applies Silver-Pohlig-Hellman on the group order to possibly reduce the problem to a set of smaller problems. The solutions are then performed using a mixture of trial, Shanks&#39; BSGS, and Pollard&#39;s DLP Rho.</p>

<p>The PP implementation is less sophisticated, with only a memory-heavy BSGS being used.</p>

<h2 id="legendre_phi">legendre_phi</h2>

<pre><code>  <span class="variable">$phi</span> <span class="operator">=</span> <span class="variable">legendre_phi</span><span class="operator">(</span><span class="number">1000000000</span><span class="operator">,</span> <span class="number">41</span><span class="operator">);</span>
</code></pre>

<p>Given a non-negative integer <code>n</code> and a non-negative prime number <code>a</code>, returns the Legendre phi function (also called Legendre&#39;s sum). This is the count of positive integers &lt;= <code>n</code> which are not divisible by any of the first <code>a</code> primes.</p>

<h2 id="inverse_li">inverse_li</h2>

<pre><code>  <span class="variable">$approx_prime_count</span> <span class="operator">=</span> <span class="variable">inverse_li</span><span class="operator">(</span><span class="number">1000000000</span><span class="operator">);</span>
</code></pre>

<p>Given a non-negative integer <code>n</code>, returns the least integer value <code>k</code> such that <code>Li(k)</code> &gt;= n&gt;. Since the logarithmic integral <code>Li(n)</code> is a good approximation to the number of primes less than <code>n</code>, this function is a good simple approximation to the nth prime.</p>

<h2 id="numtoperm">numtoperm</h2>

<pre><code>  <span class="variable">@p</span> <span class="operator">=</span> <span class="variable">numtoperm</span><span class="operator">(</span><span class="number">10</span><span class="operator">,</span><span class="number">654321</span><span class="operator">);</span>  <span class="comment"># @p=(1,8,2,7,6,5,3,4,9,0)</span>
</code></pre>

<p>Given a non-negative integer <code>n</code> and integer <code>k</code>, return the rank <code>k</code> lexicographic permutation of <code>n</code> elements. <code>k</code> will be interpreted as mod <code>n!</code>.</p>

<p>This will match iteration number <code>k</code> (zero based) of <a href="#forperm">&quot;forperm&quot;</a>.</p>

<p>This corresponds to Pari&#39;s <code>numtoperm(n,k)</code> function, though Pari uses an implementation specific ordering rather than lexicographic.</p>

<h2 id="permtonum">permtonum</h2>

<pre><code>  <span class="variable">$k</span> <span class="operator">=</span> <span class="variable">permtonum</span><span class="operator">(</span><span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">7</span><span class="operator">,</span><span class="number">6</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">,</span><span class="number">9</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span><span class="operator">);</span>  <span class="comment"># $k = 654321</span>
</code></pre>

<p>Given an array reference containing integers from <code>0</code> to <code>n</code>, returns the lexicographic permutation rank of the set. This is the inverse of the <a href="#numtoperm">&quot;numtoperm&quot;</a> function. All integers up to <code>n</code> must be present.</p>

<p>This will match iteration number <code>k</code> (zero based) of <a href="#forperm">&quot;forperm&quot;</a>. The result will be between <code>0</code> and <code>n!-1</code>.</p>

<p>This corresponds to Pari&#39;s <code>permtonum(n)</code> function, though Pari uses an implementation specific ordering rather than lexicographic.</p>

<h2 id="randperm">randperm</h2>

<pre><code>  <span class="variable">@p</span> <span class="operator">=</span> <span class="variable">randperm</span><span class="operator">(</span><span class="number">100</span><span class="operator">);</span>   <span class="comment"># returns shuffled 0..99</span>
  <span class="variable">@p</span> <span class="operator">=</span> <span class="variable">randperm</span><span class="operator">(</span><span class="number">100</span><span class="operator">,</span><span class="number">4</span><span class="operator">)</span>  <span class="comment"># returns 4 elements from shuffled 0..99</span>
  <span class="variable">@s</span> <span class="operator">=</span> <span class="variable">@data</span><span class="operator">[</span><span class="variable">randperm</span><span class="operator">(</span><span class="number">1</span><span class="operator">+</span><span class="variable">$#data</span><span class="operator">)</span><span class="operator">]</span><span class="operator">;</span>    <span class="comment"># shuffle an array</span>
  <span class="variable">@p</span> <span class="operator">=</span> <span class="variable">@data</span><span class="operator">[</span><span class="variable">randperm</span><span class="operator">(</span><span class="number">1</span><span class="operator">+</span><span class="variable">$#data</span><span class="operator">,</span><span class="number">2</span><span class="operator">)</span><span class="operator">]</span><span class="operator">;</span>  <span class="comment"># pick 2 from an array</span>
</code></pre>

<p>With a single argument <code>n</code>, this returns a random permutation of the values from <code>0</code> to <code>n-1</code>.</p>

<p>When given a second argument <code>k</code>, the returned list will have only <code>k</code> elements. This is more efficient than truncating the full shuffled list.</p>

<p>The randomness comes from our CSPRNG.</p>

<h2 id="shuffle">shuffle</h2>

<pre><code>  <span class="variable">@shuffled</span> <span class="operator">=</span> <span class="variable">shuffle</span><span class="operator">(</span><span class="variable">@data</span><span class="operator">);</span>
</code></pre>

<p>Takes a list as input, and returns a random permutation of the list. Like randperm, the randomness comes from our CSPRNG.</p>

<p>This function is functionally identical to the <code>shuffle</code> function in <a href="../../../lib/List/Util.html">List::Util</a>. The only difference is the random source (Chacha20 with better randomness, a larger period, and a larger state). This does make it slower.</p>

<p>If the entire shuffled array is desired, this is faster than slicing with <a href="#randperm">&quot;randperm&quot;</a> as shown in its example above. If, however, a &quot;pick&quot; operation is desired, e.g. pick 2 random elements from a large array, then the slice technique can be hundreds of times faster.</p>

<h1 id="RANDOM-NUMBERS">RANDOM NUMBERS</h1>

<h2 id="OVERVIEW">OVERVIEW</h2>

<p>Prior to version 5.20, Perl&#39;s <code>rand</code> function used the system rand function. This meant it varied by system, and was almost always a poor choice. For 5.20, Perl standardized on <code>drand48</code> and includes the source so there are no system dependencies. While this was an improvement, <code>drand48</code> is not a good PRNG. It really only has 32 bits of random values, and fails many statistical tests. See <a href="http://www.pcg-random.org/statistical-tests.html">http://www.pcg-random.org/statistical-tests.html</a> for more information.</p>

<p>There are much better choices for standard random number generators, such as the Mersenne Twister, PCG, or Xoroshiro128+. Someday perhaps Perl will get one of these to replace drand48. In the mean time, <a>Math::Random::MTwist</a> provides numerous features and excellent performance, or this module.</p>

<p>Since we often deal with random primes for cryptographic purposes, we have additional requirements. This module uses a CSPRNG for its random stream. In particular, ChaCha20, which is the same algorithm used by BSD&#39;s <code>arc4random</code> and <code>/dev/urandom</code> on BSD and Linux 4.8+. Seeding is performed at startup using the Win32 Crypto API (on Windows), <code>/dev/urandom</code>, <code>/dev/random</code>, or <a>Crypt::PRNG</a>, whichever is found first.</p>

<p>We use the original ChaCha definition rather than RFC7539. This means a 64-bit counter, resulting in a period of 2^72 bytes or 2^68 calls to <a>drand</a> or &lt;irand64&gt;. This compares favorably to the 2^48 period of Perl&#39;s <code>drand48</code>. It has a 512-bit state which is significantly larger than the 48-bit <code>drand48</code> state. When seeding, 320 bits (40 bytes) are used. Among other things, this means all 52! permutations of a shuffled card deck are possible, which is not true of <a href="../../../lib/List/Util.html#shuffle">&quot;shuffle&quot; in List::Util</a>.</p>

<p>One might think that performance would suffer from using a CSPRNG, but benchmarking shows it is less than one might expect. does not seem to be the case. The speed of irand, irand64, and drand are within 20% of the fastest existing modules using non-CSPRNG methods, and 2 to 20 times faster than most. While a faster underlying RNG is useful, the Perl call interface overhead is a majority of the time for these calls. Carefully tuning that interface is critical.</p>

<p>For performance on large amounts of data, see the tables in <a href="#random_bytes">&quot;random_bytes&quot;</a>.</p>

<p>Each thread uses its own context, meaning seeding in one thread has no impact on other threads. In addition to improved security, this is better for performance than a single context with locks. If explicit control of multiple independent streams are needed then using a more specific module is recommended. I believe <a>Crypt::PRNG</a> (part of <a>CryptX</a>) and <a>Bytes::Random::Secure</a> are good alternatives.</p>

<p>Using the <code>:rand</code> export option will define <code>rand</code> and <code>srand</code> as similar but improved versions of the system functions of the same name, as well as <a href="#irand">&quot;irand&quot;</a> and <a href="#irand64">&quot;irand64&quot;</a>.</p>

<h2 id="irand">irand</h2>

<pre><code>  <span class="variable">$n32</span> <span class="operator">=</span> <span class="variable">irand</span><span class="operator">;</span>     <span class="comment"># random 32-bit integer</span>
</code></pre>

<p>Returns a random 32-bit integer using the CSPRNG.</p>

<h2 id="irand64">irand64</h2>

<pre><code>  <span class="variable">$n64</span> <span class="operator">=</span> <span class="variable">irand64</span><span class="operator">;</span>   <span class="comment"># random 64-bit integer</span>
</code></pre>

<p>Returns a random 64-bit integer using the CSPRNG (on 64-bit Perl).</p>

<h2 id="drand">drand</h2>

<pre><code>  <span class="variable">$f</span> <span class="operator">=</span> <span class="variable">drand</span><span class="operator">;</span>       <span class="comment"># random floating point value in [0,1)</span>
  <span class="variable">$r</span> <span class="operator">=</span> <span class="variable">drand</span><span class="operator">(</span><span class="number">25.33</span><span class="operator">);</span>   <span class="comment"># random floating point value in [0,25.33)</span>
</code></pre>

<p>Returns a random NV (Perl&#39;s native floating point) using the CSPRNG. The API is similar to Perl&#39;s <code>rand</code> but giving better results.</p>

<p>The number of bits returned is equal to the number of significand bits of the NV type used in the Perl build. By default Perl uses doubles and the returned values have 53 bits (even on 32-bit Perl). If Perl is built with long double or quadmath support, each value may have 64 or even 113 bits. On newer Perls, one can check the <a href="../../../lib/Config.html">Config</a> variable <code>nvmantbits</code> to see how many are filled.</p>

<p>This gives <i>substantially</i> better quality random numbers than the default Perl <code>rand</code> function. Among other things, on modern Perl&#39;s, <code>rand</code> uses drand48, which has 32 bits of not-very-good randomness and 16 more bits of obvious patterns (e.g. the 48th bit alternates, the 47th has a period of 4, etc.). Output from <code>rand</code> fails at least 5 tests from the TestU01 SmallCrush suite, while our function easily passes.</p>

<p>With the &quot;:rand&quot; tag, this function is additionally exported as <code>rand</code>.</p>

<h2 id="random_bytes">random_bytes</h2>

<pre><code>  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">random_bytes</span><span class="operator">(</span><span class="number">32</span><span class="operator">);</span>     <span class="comment"># 32 random bytes</span>
</code></pre>

<p>Given an unsigned number <code>n</code> of bytes, returns a string filled with random data from the CSPRNG. Performance for large quantities:</p>

<pre><code>    Module/Method                  Rate   Type
    -------------             ---------   ----------------------

    Math::Prime::Util::GMP    1067 MB/s   CSPRNG - ISAAC
    ntheory random_bytes       384 MB/s   CSPRNG - ChaCha20
    Crypt::PRNG                140 MB/s   CSPRNG - Fortuna
    Crypt::OpenSSL::Random      32 MB/s   CSPRNG - SHA1 counter
    Math::Random::ISAAC::XS     15 MB/s   CSPRNG - ISAAC
    ntheory entropy_bytes       13 MB/s   CSPRNG - /dev/urandom
    Crypt::Random               12 MB/s   CSPRNG - /dev/urandom
    Crypt::Urandom              12 MB/s   CSPRNG - /dev/urandom
    Bytes::Random::Secure        6 MB/s   CSPRNG - ISAAC
    ntheory pure perl ISAAC      5 MB/s   CSPRNG - ISAAC (no XS)
    Math::Random::ISAAC::PP      2.5 MB/s CSPRNG - ISAAC (no XS)
    ntheory pure perl ChaCha     1.0 MB/s CSPRNG - ChaCha20 (no XS)
    Data::Entropy::Algorithms    0.5 MB/s CSPRNG - AES-CTR

    Math::Random::MTwist       927 MB/s   PRNG - Mersenne Twister
    Bytes::Random::XS          109 MB/s   PRNG - drand48
    pack CORE::rand             25 MB/s   PRNG - drand48 (no XS)
    Bytes::Random                2.6 MB/s PRNG - drand48 (no XS)</code></pre>

<h2 id="entropy_bytes">entropy_bytes</h2>

<p>Similar to random_bytes, but directly using the entropy source. This is not normally recommended as it can consume shared system resources and is typically slow -- on the computer that produced the <a href="#random_bytes">&quot;random_bytes&quot;</a> chart above, using <code>dd</code> generated the same 13 MB/s performance as our <a href="#entropy_bytes">&quot;entropy_bytes&quot;</a> function.</p>

<p>The actual performance will be highly system dependent.</p>

<h2 id="urandomb">urandomb</h2>

<pre><code>  <span class="variable">$n32</span> <span class="operator">=</span> <span class="variable">urandomb</span><span class="operator">(</span><span class="number">32</span><span class="operator">);</span>    <span class="comment"># Classic irand32, returns a UV</span>
  <span class="variable">$n</span>   <span class="operator">=</span> <span class="variable">urandomb</span><span class="operator">(</span><span class="number">1024</span><span class="operator">);</span>  <span class="comment"># Random integer less than 2^1024</span>
</code></pre>

<p>Given a number of bits <code>b</code>, returns a random unsigned integer less than <code>2^b</code>. The result will be uniformly distributed between <code>0</code> and <code>2^b-1</code> inclusive.</p>

<h2 id="urandomm">urandomm</h2>

<pre><code>  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">urandomm</span><span class="operator">(</span><span class="number">100</span><span class="operator">);</span>    <span class="comment"># random integer in [0,99]</span>
  <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">urandomm</span><span class="operator">(</span><span class="number">1024</span><span class="operator">);</span>   <span class="comment"># random integer in [0,1023]</span>
</code></pre>

<p>Given a positive integer <code>n</code>, returns a random unsigned integer less than <code>n</code>. The results will be uniformly distributed between <code>0</code> and <code>n-1</code> inclusive. Care is taken to prevent modulo bias.</p>

<h2 id="csrand">csrand</h2>

<p>Takes a binary string <code>data</code> as input and seeds the internal CSPRNG. This is not normally needed as system entropy is used as a seed on startup. For best security this should be 16-128 bytes of good entropy. No more than 1024 bytes will be used.</p>

<p>With no argument, reseeds using system entropy, which is preferred.</p>

<p>If the <code>secure</code> configuration has been set, then this will croak if given an argument. This allows for control of reseeding with entropy the module gets itself, but not user supplied.</p>

<h2 id="srand">srand</h2>

<p>Takes a single UV argument and seeds the CSPRNG with it, as well as returning it. If no argument is given, a new UV seed is constructed. Note that this creates a very weak seed from a cryptographic standpoint, so it is useful for testing or simulations but <a href="#csrand">&quot;csrand&quot;</a> is recommended, or keep using the system entropy default seed.</p>

<p>The API is nearly identical to the system function <code>srand</code>. It uses a UV which can be 64-bit rather than always 32-bit. The behaviour for <code>undef</code>, empty string, empty list, etc. is slightly different (we treat these as 0).</p>

<p>This function is not exported with the &quot;:all&quot; tag, but is with &quot;:rand&quot;.</p>

<p>If the <code>secure</code> configuration has been set, this function will croak. Manual seeding using <code>srand</code> is not compatible with cryptographic security.</p>

<h2 id="rand">rand</h2>

<p>An alias for <a href="#drand">&quot;drand&quot;</a>, not exported unless the &quot;:rand&quot; tag is used.</p>

<h1 id="RANDOM-PRIMES">RANDOM PRIMES</h1>

<h2 id="random_prime">random_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$small_prime</span> <span class="operator">=</span> <span class="variable">random_prime</span><span class="operator">(</span><span class="number">1000</span><span class="operator">);</span>      <span class="comment"># random prime &lt;= limit</span>
  <span class="keyword">my</span> <span class="variable">$rand_prime</span> <span class="operator">=</span> <span class="variable">random_prime</span><span class="operator">(</span><span class="number">100</span><span class="operator">,</span> <span class="number">10000</span><span class="operator">);</span> <span class="comment"># random prime within a range</span>
</code></pre>

<p>Returns a pseudo-randomly selected prime that will be greater than or equal to the lower limit and less than or equal to the upper limit. If no lower limit is given, 2 is implied. Returns undef if no primes exist within the range.</p>

<p>The goal is to return a uniform distribution of the primes in the range, meaning for each prime in the range, the chances are equally likely that it will be seen. This is removes from consideration such algorithms as <code>PRIMEINC</code>, which although efficient, gives very non-random output. This also implies that the numbers will not be evenly distributed, since the primes are not evenly distributed. Stated differently, the random prime functions return a uniformly selected prime from the set of primes within the range. Hence given <code>random_prime(1000)</code>, the numbers 2, 3, 487, 631, and 997 all have the same probability of being returned.</p>

<p>For small numbers, a random index selection is done, which gives ideal uniformity and is very efficient with small inputs. For ranges larger than this ~16-bit threshold but within the native bit size, a Monte Carlo method is used. This also gives ideal uniformity and can be very fast for reasonably sized ranges. For even larger numbers, we partition the range, choose a random partition, then select a random prime from the partition. This gives some loss of uniformity but results in many fewer bits of randomness being consumed as well as being much faster.</p>

<h2 id="random_ndigit_prime">random_ndigit_prime</h2>

<pre><code>  <span class="keyword">say</span> <span class="string">"My 4-digit prime number is: "</span><span class="operator">,</span> <span class="variable">random_ndigit_prime</span><span class="operator">(</span><span class="number">4</span><span class="operator">);</span>
</code></pre>

<p>Selects a random n-digit prime, where the input is an integer number of digits. One of the primes within that range (e.g. 1000 - 9999 for 4-digits) will be uniformly selected.</p>

<p>If the number of digits is greater than or equal to the maximum native type, then the result will be returned as a BigInt. However, if the <code>nobigint</code> configuration option is on, then output will be restricted to native size numbers, and requests for more digits than natively supported will result in an error. For better performance with large bit sizes, install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>.</p>

<h2 id="random_nbit_prime">random_nbit_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$bigprime</span> <span class="operator">=</span> <span class="variable">random_nbit_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Selects a random n-bit prime, where the input is an integer number of bits. A prime with the nth bit set will be uniformly selected.</p>

<p>For bit sizes of 64 and lower, <a href="#random_prime">&quot;random_prime&quot;</a> is used, which gives completely uniform results in this range. For sizes larger than 64, Algorithm 1 of Fouque and Tibouchi (2011) is used, wherein we select a random odd number for the lower bits, then loop selecting random upper bits until the result is prime. This allows a more uniform distribution than the general <a href="#random_prime">&quot;random_prime&quot;</a> case while running slightly faster (in contrast, for large bit sizes <a href="#random_prime">&quot;random_prime&quot;</a> selects a random upper partition then loops on the values within the partition, which very slightly skews the results towards smaller numbers).</p>

<p>The result will be a BigInt if the number of bits is greater than the native bit size. For better performance with large bit sizes, install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>.</p>

<h2 id="random_strong_prime">random_strong_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$bigprime</span> <span class="operator">=</span> <span class="variable">random_strong_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Constructs an n-bit strong prime using Gordon&#39;s algorithm. We consider a strong prime <i>p</i> to be one where</p>

<ul>

<li><p><i>p</i> is large. This function requires at least 128 bits.</p>

</li>
<li><p><i>p-1</i> has a large prime factor <i>r</i>.</p>

</li>
<li><p><i>p+1</i> has a large prime factor <i>s</i></p>

</li>
<li><p><i>r-1</i> has a large prime factor <i>t</i></p>

</li>
</ul>

<p>Using a strong prime in cryptography guards against easy factoring with algorithms like Pollard&#39;s Rho. Rivest and Silverman (1999) present a case that using strong primes is unnecessary, and most modern cryptographic systems agree. First, the smoothness does not affect more modern factoring methods such as ECM. Second, modern factoring methods like GNFS are far faster than either method so make the point moot. Third, due to key size growth and advances in factoring and attacks, for practical purposes, using large random primes offer security equivalent to strong primes.</p>

<p>Similar to <a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a>, the result will be a BigInt if the number of bits is greater than the native bit size. For better performance with large bit sizes, install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>.</p>

<h2 id="random_proven_prime">random_proven_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$bigprime</span> <span class="operator">=</span> <span class="variable">random_proven_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Constructs an n-bit random proven prime. Internally this may use <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a>(<a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a>) or <a href="#random_maurer_prime">&quot;random_maurer_prime&quot;</a> depending on the platform and bit size.</p>

<h2 id="random_proven_prime_with_cert">random_proven_prime_with_cert</h2>

<pre><code>  my($n, $cert) = random_proven_prime_with_cert(512)</code></pre>

<p>Similar to <a href="#random_proven_prime">&quot;random_proven_prime&quot;</a>, but returns a two-element array containing the n-bit provable prime along with a primality certificate. The certificate is the same as produced by <a href="#prime_certificate">&quot;prime_certificate&quot;</a> or <a href="#is_provable_prime_with_cert">&quot;is_provable_prime_with_cert&quot;</a>, and can be parsed by <a href="#verify_prime">&quot;verify_prime&quot;</a> or any other software that understands MPU primality certificates.</p>

<h2 id="random_maurer_prime">random_maurer_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$bigprime</span> <span class="operator">=</span> <span class="variable">random_maurer_prime</span><span class="operator">(</span><span class="number">512</span><span class="operator">);</span>
</code></pre>

<p>Construct an n-bit provable prime, using the FastPrime algorithm of Ueli Maurer (1995). This is the same algorithm used by <a>Crypt::Primes</a>. Similar to <a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a>, the result will be a BigInt if the number of bits is greater than the native bit size.</p>

<p>The performance with <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> installed is hundreds of times faster, so it is highly recommended.</p>

<p>The differences between this function and that in <a>Crypt::Primes</a> are described in the <a href="#SEE-ALSO">&quot;SEE ALSO&quot;</a> section.</p>

<p>Internally this additionally runs the BPSW probable prime test on every partial result, and constructs a primality certificate for the final result, which is verified. These provide additional checks that the resulting value has been properly constructed.</p>

<p>If you don&#39;t need absolutely proven results, then it is somewhat faster to use <a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a> either by itself or with some additional tests, e.g. <a href="#miller_rabin_random">&quot;miller_rabin_random&quot;</a> and/or <a href="#is_frobenius_underwood_pseudoprime">&quot;is_frobenius_underwood_pseudoprime&quot;</a>. One could also run <a>is_provable_prime</a> on the result, but this will be slow.</p>

<h2 id="random_maurer_prime_with_cert">random_maurer_prime_with_cert</h2>

<pre><code>  my($n, $cert) = random_maurer_prime_with_cert(512)</code></pre>

<p>As with <a href="#random_maurer_prime">&quot;random_maurer_prime&quot;</a>, but returns a two-element array containing the n-bit provable prime along with a primality certificate. The certificate is the same as produced by <a href="#prime_certificate">&quot;prime_certificate&quot;</a> or <a href="#is_provable_prime_with_cert">&quot;is_provable_prime_with_cert&quot;</a>, and can be parsed by <a href="#verify_prime">&quot;verify_prime&quot;</a> or any other software that understands MPU primality certificates. The proof construction consists of a single chain of <code>BLS3</code> types.</p>

<h2 id="random_shawe_taylor_prime">random_shawe_taylor_prime</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$bigprime</span> <span class="operator">=</span> <span class="variable">random_shawe_taylor_prime</span><span class="operator">(</span><span class="number">8192</span><span class="operator">);</span>
</code></pre>

<p>Construct an n-bit provable prime, using the Shawe-Taylor algorithm in section C.6 of FIPS 186-4. This uses 512 bits of randomness and SHA-256 as the hash. This is a slightly simpler and older (1986) method than Maurer&#39;s 1999 construction. It is a bit faster than Maurer&#39;s method, and uses less system entropy for large sizes. The primary reason to use this rather than Maurer&#39;s method is to use the FIPS 186-4 algorithm.</p>

<p>Similar to <a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a>, the result will be a BigInt if the number of bits is greater than the native bit size. For better performance with large bit sizes, install <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>. Also see <a href="#random_maurer_prime">&quot;random_maurer_prime&quot;</a> and <a href="#random_proven_prime">&quot;random_proven_prime&quot;</a>.</p>

<p>Internally this additionally runs the BPSW probable prime test on every partial result, and constructs a primality certificate for the final result, which is verified. These provide additional checks that the resulting value has been properly constructed.</p>

<h2 id="random_shawe_taylor_prime_with_cert">random_shawe_taylor_prime_with_cert</h2>

<pre><code>  my($n, $cert) = random_shawe_taylor_prime_with_cert(4096)</code></pre>

<p>As with <a href="#random_shawe_taylor_prime">&quot;random_shawe_taylor_prime&quot;</a>, but returns a two-element array containing the n-bit provable prime along with a primality certificate. The certificate is the same as produced by <a href="#prime_certificate">&quot;prime_certificate&quot;</a> or <a href="#is_provable_prime_with_cert">&quot;is_provable_prime_with_cert&quot;</a>, and can be parsed by <a href="#verify_prime">&quot;verify_prime&quot;</a> or any other software that understands MPU primality certificates. The proof construction consists of a single chain of <code>Pocklington</code> types.</p>

<h2 id="random_semiprime">random_semiprime</h2>

<p>Takes a positive integer number of bits <code>bits</code>, returns a random semiprime of exactly <code>bits</code> bits. The result has exactly two prime factors (hence semiprime).</p>

<p>The factors will be approximately equal size, which is typical for cryptographic use. For example, a 64-bit semiprime of this type is the product of two 32-bit primes. <code>bits</code> must be <code>4</code> or greater.</p>

<p>Some effort is taken to select uniformly from the universe of <code>bits</code>-bit semiprimes. This takes slightly longer than some methods that do not select uniformly.</p>

<h2 id="random_unrestricted_semiprime">random_unrestricted_semiprime</h2>

<p>Takes a positive integer number of bits <code>bits</code>, returns a random semiprime of exactly <code>bits</code> bits. The result has exactly two prime factors (hence semiprime).</p>

<p>The factors are uniformly selected from the universe of all <code>bits</code>-bit semiprimes. This means semiprimes with one factor equal to <code>2</code> will be most common, <code>3</code> next most common, etc. <code>bits</code> must be <code>3</code> or greater.</p>

<p>Some effort is taken to select uniformly from the universe of <code>bits</code>-bit semiprimes. This takes slightly longer than some methods that do not select uniformly.</p>

<h1 id="UTILITY-FUNCTIONS">UTILITY FUNCTIONS</h1>

<h2 id="prime_precalc">prime_precalc</h2>

<pre><code>  <span class="variable">prime_precalc</span><span class="operator">(</span> <span class="number">1_000_000_000</span> <span class="operator">);</span>
</code></pre>

<p>Let the module prepare for fast operation up to a specific number. It is not necessary to call this, but it gives you more control over when memory is allocated and gives faster results for multiple calls in some cases. In the current implementation this will calculate a sieve for all numbers up to the specified number.</p>

<h2 id="prime_memfree">prime_memfree</h2>

<pre><code>  <span class="variable">prime_memfree</span><span class="operator">;</span>
</code></pre>

<p>Frees any extra memory the module may have allocated. Like with <code>prime_precalc</code>, it is not necessary to call this, but if you&#39;re done making calls, or want things cleanup up, you can use this. The object method might be a better choice for complicated uses.</p>

<h2 id="Math::Prime::Util::MemFree-new">Math::Prime::Util::MemFree-&gt;new</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$mf</span> <span class="operator">=</span> <span class="variable">Math::Prime::Util::MemFree</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  <span class="comment"># perform operations.  When $mf goes out of scope, memory will be recovered.</span>
</code></pre>

<p>This is a more robust way of making sure any cached memory is freed, as it will be handled by the last <code>MemFree</code> object leaving scope. This means if your routines were inside an eval that died, things will still get cleaned up. If you call another function that uses a MemFree object, the cache will stay in place because you still have an object.</p>

<h2 id="prime_get_config">prime_get_config</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$cached_up_to</span> <span class="operator">=</span> <span class="variable">prime_get_config</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'precalc_to'</span><span class="operator">}</span><span class="operator">;</span>
</code></pre>

<p>Returns a reference to a hash of the current settings. The hash is copy of the configuration, so changing it has no effect. The settings include:</p>

<pre><code>  verbose         verbose level.  1 or more will result in extra output.
  precalc_to      primes up to this number are calculated
  maxbits         the maximum number of bits for native operations
  xs              0 or 1, indicating the XS code is available
  gmp             0 or 1, indicating GMP code is available
  maxparam        the largest value for most functions, without bigint
  maxdigits       the max digits in a number, without bigint
  maxprime        the largest representable prime, without bigint
  maxprimeidx     the index of maxprime, without bigint
  assume_rh       whether to assume the Riemann hypothesis (default 0)
  secure          disable ability to manually seed the CSPRNG</code></pre>

<h2 id="prime_set_config">prime_set_config</h2>

<pre><code>  <span class="variable">prime_set_config</span><span class="operator">(</span> <span class="string">assume_rh</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">);</span>
</code></pre>

<p>Allows setting of some parameters. Currently the only parameters are:</p>

<pre><code>  verbose      The default setting of 0 will generate no extra output.
               Setting to 1 or higher results in extra output.  For
               example, at setting 1 the AKS algorithm will indicate
               the chosen r and s values.  At setting 2 it will output
               a sequence of dots indicating progress.  Similarly, for
               random_maurer_prime, setting 3 shows real time progress.
               Factoring large numbers is another place where verbose
               settings can give progress indications.

  xs           Allows turning off the XS code, forcing the Pure Perl
               code to be used.  Set to 0 to disable XS, set to 1 to
               re-enable.  You probably will never want to do this.

  gmp          Allows turning off the use of L&lt;Math::Prime::Util::GMP&gt;,
               which means using Pure Perl code for big numbers.  Set
               to 0 to disable GMP, set to 1 to re-enable.
               You probably will never want to do this.

  assume_rh    Allows functions to assume the Riemann hypothesis is
               true if set to 1.  This defaults to 0.  Currently this
               setting only impacts prime count lower and upper
               bounds, but could later be applied to other areas such
               as primality testing.  A later version may also have a
               way to indicate whether no RH, RH, GRH, or ERH is to
               be assumed.

  secure       The CSPRNG may no longer be manually seeded.  Once set,
               this option cannot be disabled.  L&lt;/srand&gt; will croak
               if called, and L&lt;/csrand&gt; will croak if called with any
               arguments.  L&lt;/csrand&gt; with no arguments is still allowed,
               as that will use system entropy without giving anything
               to the caller.  The point of this option is to ensure that
               any called functions do not try to control the RNG.</code></pre>

<h1 id="FACTORING-FUNCTIONS">FACTORING FUNCTIONS</h1>

<h2 id="factor">factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">factor</span><span class="operator">(</span><span class="number">3_369_738_766_071_892_021</span><span class="operator">);</span>
  <span class="comment"># returns (204518747,16476429743)</span>
</code></pre>

<p>Produces the prime factors of a positive number input, in numerical order. The product of the returned factors will be equal to the input. <code>n = 1</code> will return an empty list, and <code>n = 0</code> will return 0. This matches Pari.</p>

<p>In scalar context, returns &Omega;(n), the total number of prime factors (<a href="http://oeis.org/A001222">OEIS A001222</a>). This corresponds to Pari&#39;s <code>bigomega(n)</code> function and Mathematica&#39;s <code>PrimeOmega[n]</code> function. This is same result that we would get if we evaluated the resulting array in scalar context.</p>

<p>The current algorithm does a little trial division, a check for perfect powers, followed by combinations of Pollard&#39;s Rho, SQUFOF, and Pollard&#39;s p-1. The combination is applied to each non-prime factor found.</p>

<p>Factoring bigints works with pure Perl, and can be very handy on 32-bit machines for numbers just over the 32-bit limit, but it can be <b>very</b> slow for &quot;hard&quot; numbers. Installing the <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> module will speed up bigint factoring a <b>lot</b>, and all future effort on large number factoring will be in that module. If you do not have that module for some reason, use the GMP or Pari version of bigint if possible (e.g. <code>use bigint try =&gt; &#39;GMP,Pari&#39;</code>), which will run 2-3x faster (though still 100x slower than the real GMP code).</p>

<h2 id="factor_exp">factor_exp</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factor_exponent_pairs</span> <span class="operator">=</span> <span class="variable">factor_exp</span><span class="operator">(</span><span class="number">29513484000</span><span class="operator">);</span>
  <span class="comment"># returns ([2,5], [3,4], [5,3], [7,2], [11,1], [13,2])</span>
  <span class="comment"># factor(29513484000)</span>
  <span class="comment"># returns (2,2,2,2,2,3,3,3,3,5,5,5,7,7,11,13,13)</span>
</code></pre>

<p>Produces pairs of prime factors and exponents in numerical factor order. This is more convenient for some algorithms. This is the same form that Mathematica&#39;s <code>FactorInteger[n]</code> and Pari/GP&#39;s <code>factorint</code> functions return. Note that <a>Math::Pari</a> transposes the Pari result matrix.</p>

<p>In scalar context, returns &omega;(n), the number of unique prime factors (<a href="http://oeis.org/A001221">OEIS A001221</a>). This corresponds to Pari&#39;s <code>omega(n)</code> function and Mathematica&#39;s <code>PrimeNu[n]</code> function. This is same result that we would get if we evaluated the resulting array in scalar context.</p>

<p>The internals are identical to <a href="#factor">&quot;factor&quot;</a>, so all comments there apply. Just the way the factors are arranged is different.</p>

<h2 id="divisors">divisors</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@divisors</span> <span class="operator">=</span> <span class="variable">divisors</span><span class="operator">(</span><span class="number">30</span><span class="operator">);</span>   <span class="comment"># returns (1, 2, 3, 5, 6, 10, 15, 30)</span>
</code></pre>

<p>Produces all the divisors of a positive number input, including 1 and the input number. The divisors are a power set of multiplications of the prime factors, returned as a uniqued sorted list. The result is identical to that of Pari&#39;s <code>divisors</code> and Mathematica&#39;s <code>Divisors[n]</code> functions.</p>

<p>In scalar context this returns the sigma0 function (see Hardy and Wright section 16.7). This is <a href="http://oeis.org/A000005">OEIS A000005</a>. The results is identical to evaluating the array in scalar context, but more efficient. This corresponds to Pari&#39;s <code>numdiv</code> and Mathematica&#39;s <code>DivisorSigma[0,n]</code> functions.</p>

<p>Also see the <a href="#for_divisors">&quot;for_divisors&quot;</a> functions for looping over the divisors.</p>

<h2 id="trial_factor">trial_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">trial_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Produces the prime factors of a positive number input. The factors will be in numerical order. For large inputs this will be very slow. Like all the specific-algorithm <code>*_factor</code> routines, this is not exported unless explicitly requested.</p>

<h2 id="fermat_factor">fermat_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">fermat_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. The particular algorithm is Knuth&#39;s algorithm C. For small inputs this will be very fast, but it slows down quite rapidly as the number of digits increases. It is very fast for inputs with a factor close to the midpoint (e.g. a semiprime p*q where p and q are the same number of digits).</p>

<h2 id="holf_factor">holf_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">holf_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. An optional number of rounds can be given as a second parameter. It is possible the function will be unable to find a factor, in which case a single element, the input, is returned. This uses Hart&#39;s One Line Factorization with no premultiplier. It is an interesting alternative to Fermat&#39;s algorithm, and there are some inputs it can rapidly factor. Overall it has the same advantages and disadvantages as Fermat&#39;s method.</p>

<h2 id="lehman_factor">lehman_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">lehman_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. An optional argument, defaulting to 0 (false), indicates whether to run trial division. Without trial division, is possible the function will be unable to find a factor, in which case a single element, the input, is returned.</p>

<p>This is Warren D. Smith&#39;s Lehman core with minor modifications. It is limited to 42-bit inputs: <code>n &lt; 8796393022208</code>.</p>

<h2 id="squfof_factor">squfof_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">squfof_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. An optional number of rounds can be given as a second parameter. It is possible the function will be unable to find a factor, in which case a single element, the input, is returned. This function typically runs very fast.</p>

<h2 id="prho_factor">prho_factor</h2>

<h2 id="pbrent_factor">pbrent_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">prho_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pbrent_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  
  <span class="comment"># Use a very small number of rounds</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">prho_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1000</span><span class="operator">);</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. An optional number of rounds can be given as a second parameter. These attempt to find a single factor using Pollard&#39;s Rho algorithm, either the original version or Brent&#39;s modified version. These are more specialized algorithms usually used for pre-factoring very large inputs, as they are very fast at finding small factors.</p>

<h2 id="pminus1_factor">pminus1_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1_000</span><span class="operator">);</span>          <span class="comment"># set B1 smoothness</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pminus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1_000</span><span class="operator">,</span> <span class="number">50_000</span><span class="operator">);</span>  <span class="comment"># set B1 and B2</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. This is Pollard&#39;s <code>p-1</code> method, using two stages with default smoothness settings of 1_000_000 for B1, and <code>10 * B1</code> for B2. This method can rapidly find a factor <code>p</code> of <code>n</code> where <code>p-1</code> is smooth (it has no large factors).</p>

<h2 id="pplus1_factor">pplus1_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pplus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">pplus1_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">1_000</span><span class="operator">);</span>          <span class="comment"># set B1 smoothness</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. This is Williams&#39; <code>p+1</code> method, using one stage and two predefined initial points.</p>

<h2 id="ecm_factor">ecm_factor</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@factors</span> <span class="operator">=</span> <span class="variable">ecm_factor</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="number">100</span><span class="operator">,</span> <span class="number">400</span><span class="operator">,</span> <span class="number">10</span><span class="operator">);</span>      <span class="comment"># B1, B2, # of curves</span>
</code></pre>

<p>Produces factors, not necessarily prime, of the positive number input. This is the elliptic curve method using two stages.</p>

<h1 id="MATHEMATICAL-FUNCTIONS">MATHEMATICAL FUNCTIONS</h1>

<h2 id="ExponentialIntegral">ExponentialIntegral</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$Ei</span> <span class="operator">=</span> <span class="variable">ExponentialIntegral</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>
</code></pre>

<p>Given a non-zero floating point input <code>x</code>, this returns the real-valued exponential integral of <code>x</code>, defined as the integral of <code>e^t/t dt</code> from <code>-infinity</code> to <code>x</code>.</p>

<p>If the bignum module has been loaded, all inputs will be treated as if they were Math::BigFloat objects.</p>

<p>For non-BigInt/BigFloat objects, the result should be accurate to at least 14 digits.</p>

<p>For BigInt / BigFloat objects, we first check to see if <a>Math::MPFR</a> is available. If so, then it is used since it is very fast and has high accuracy. Accuracy when using MPFR will be equal to the <code>accuracy()</code> value of the input (or the default BigFloat accuracy, which is 40 by default).</p>

<p>MPFR is used for positive inputs only. If <a>Math::MPFR</a> is not available or the input is negative, then other methods are used: continued fractions (<code>x &lt; -1</code>), rational Chebyshev approximation (<code> -1 &lt; x &lt; 0</code>), a convergent series (small positive <code>x</code>), or an asymptotic divergent series (large positive <code>x</code>). Accuracy should be at least 14 digits.</p>

<h2 id="LogarithmicIntegral">LogarithmicIntegral</h2>

<pre><code>  my $li = LogarithmicIntegral($x)</code></pre>

<p>Given a positive floating point input, returns the floating point logarithmic integral of <code>x</code>, defined as the integral of <code>dt/ln t</code> from <code>0</code> to <code>x</code>. If given a negative input, the function will croak. The function returns 0 at <code>x = 0</code>, and <code>-infinity</code> at <code>x = 1</code>.</p>

<p>This is often known as <code>li(x)</code>. A related function is the offset logarithmic integral, sometimes known as <code>Li(x)</code> which avoids the singularity at 1. It may be defined as <code>Li(x) = li(x) - li(2)</code>. Crandall and Pomerance use the term <code>li0</code> for this function, and define <code>li(x) = Li0(x) - li0(2)</code>. Due to this terminology confusion, it is important to check which exact definition is being used.</p>

<p>If the bignum module has been loaded, all inputs will be treated as if they were Math::BigFloat objects.</p>

<p>For non-BigInt/BigFloat objects, the result should be accurate to at least 14 digits.</p>

<p>For BigInt / BigFloat objects, we first check to see if <a>Math::MPFR</a> is available. If so, then it is used, as it will return results much faster and can be more accurate. Accuracy when using MPFR will be equal to the <code>accuracy()</code> value of the input (or the default BigFloat accuracy, which is 40 by default).</p>

<p>MPFR is used for inputs greater than 1 only. If <a>Math::MPFR</a> is not installed or the input is less than 1, results will be calculated as <code>Ei(ln x)</code>.</p>

<h2 id="RiemannZeta">RiemannZeta</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$z</span> <span class="operator">=</span> <span class="variable">RiemannZeta</span><span class="operator">(</span><span class="variable">$s</span><span class="operator">);</span>
</code></pre>

<p>Given a floating point input <code>s</code> where <code>s &gt;= 0</code>, returns the floating point value of &zeta;(s)-1, where &zeta;(s) is the Riemann zeta function. One is subtracted to ensure maximum precision for large values of <code>s</code>. The zeta function is the sum from k=1 to infinity of <code>1 / k^s</code>. This function only uses real arguments, so is basically the Euler Zeta function.</p>

<p>If the bignum module has been loaded, all inputs will be treated as if they were Math::BigFloat objects.</p>

<p>For non-BigInt/BigFloat objects, the result should be accurate to at least 14 digits. The XS code uses a rational Chebyshev approximation between 0.5 and 5, and a series for other values. The PP code uses an identical series for all values.</p>

<p>For integer arguments, the <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> module (v0.41 or newer) will quickly produce high resolution results. Alternately for any arguments, <a>Math::MPFR</a> can be used to quickly produce high resolution results.</p>

<p>For BigInt / BigFloat objects, accuracy will be equal to the <code>accuracy()</code> value of the input (or the default BigFloat accuracy, which is 40 by default).</p>

<p>If neither the GMP backend or Math::MPFR are available, then results are calculated using either Borwein (1991) algorithm 2, or the basic series. Full input accuracy is attempted, but Math::BigFloat <a href="https://rt.cpan.org/Ticket/Display.html?id=43692">RT 43692</a> produces incorrect high-accuracy computations without the fix. It is also very slow.</p>

<h2 id="RiemannR">RiemannR</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$r</span> <span class="operator">=</span> <span class="variable">RiemannR</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">);</span>
</code></pre>

<p>Given a positive non-zero floating point input, returns the floating point value of Riemann&#39;s R function. Riemann&#39;s R function gives a very close approximation to the prime counting function.</p>

<p>If the bignum module has been loaded, all inputs will be treated as if they were Math::BigFloat objects.</p>

<p>For non-BigInt/BigFloat objects, the result should be accurate to at least 14 digits.</p>

<p>For BigInt / BigFloat objects, accuracy depends on the back end modules. With <a>Math::MPFR</a> or our GMP backend on integer arguments, accuracy will be equal to the <code>accuracy()</code> value of the input (or the default BigFloat accuracy, which is 40 by default). If neither of those modules are available, then accuracy should be 35 digits.</p>

<h2 id="LambertW">LambertW</h2>

<p>Returns the principal branch of the Lambert W function of a real value. Given a value <code>k</code> this solves for <code>W</code> in the equation <code>k = We^W</code>. The input must not be less than <code>-1/e</code>. This corresponds to Pari&#39;s <code>lambertw</code> function and Mathematica&#39;s <code>ProductLog</code> / <code>LambertW</code> function.</p>

<p>This function handles all real value inputs with non-complex return values. This is a superset of Pari&#39;s <code>lambertw</code> which is similar but only for positive arguments. Mathematica&#39;s function is much more detailed, with both branches, complex arguments, and complex results.</p>

<p>Calculation will be done with C long doubles if the input is a standard scalar, but if bignum is in use or if the input is a BigFloat type, then extended precision results will be used.</p>

<p>Speed of the native code is about half of the fastest native code (Veberic&#39;s C++), and about 30x faster than Pari/GP. However the bignum calculation is <i>much</i> slower.</p>

<h2 id="Pi">Pi</h2>

<pre><code>  <span class="keyword">my</span> <span class="variable">$tau</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> <span class="variable">Pi</span><span class="operator">;</span>     <span class="comment"># $tau = 6.28318530717959</span>
  <span class="keyword">my</span> <span class="variable">$tau</span> <span class="operator">=</span> <span class="number">2</span> <span class="operator">*</span> <span class="variable">Pi</span><span class="operator">(</span><span class="number">40</span><span class="operator">);</span> <span class="comment"># $tau = 6.283185307179586476925286766559005768394</span>
</code></pre>

<p>With no arguments, returns the value of Pi as an NV. With a positive integer argument, returns the value of Pi with the requested number of digits (including the leading 3). The return value will be an NV if the number of digits fits in an NV (typically 15 or less), or a <a href="../../../lib/Math/BigFloat.html">Math::BigFloat</a> object otherwise.</p>

<p>For sizes over 10k digits, having one of <a>Math::MPFR</a>, <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>, or <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> installed will help performance. For sizes over 50k one of the first two are highly recommended.</p>

<h1 id="EXAMPLES">EXAMPLES</h1>

<p>Print Fibonacci numbers:</p>

<pre><code>    perl -Mntheory=:all -E &#39;say lucasu(1,-1,$_) for 0..20&#39;</code></pre>

<p>Print strong pseudoprimes to base 17 up to 10M:</p>

<pre><code>    <span class="comment"># Similar to A001262's isStrongPsp function, but much faster</span>
    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MMath::Prime::Util</span><span class="operator">=:</span><span class="variable">all</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'forcomposites { say if is_strong_pseudoprime($_,17) } 10000000;'</span>
</code></pre>

<p>Print some primes above 64-bit range:</p>

<pre><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MMath::Prime::Util</span><span class="operator">=:</span><span class="variable">all</span> <span class="operator">-</span><span class="variable">Mbigint</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'my $start=100000000000000000000; say join "\n", @{primes($start,$start+1000)}'</span>
    
    <span class="comment"># Another way</span>
    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MMath::Prime::Util</span><span class="operator">=:</span><span class="variable">all</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'forprimes { say } "100000000000000000039", "100000000000000000993"'</span>
    
    <span class="comment"># Similar using Math::Pari:</span>
    <span class="comment"># perl -MMath::Pari=:int,PARI,nextprime -E 'my $start = PARI "100000000000000000000"; my $end = $start+1000; my $p=nextprime($start); while ($p &lt;= $end) { say $p; $p = nextprime($p+1); }'</span>
</code></pre>

<p>Generate Carmichael numbers (<a href="http://oeis.org/A002997">OEIS A002997</a>):</p>

<pre><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">Mntheory</span><span class="operator">=:</span><span class="variable">all</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'foroddcomposites { say if is_carmichael($_) } 1e6;'</span>
    
    <span class="comment"># Less efficient, similar to Mathematica or MAGMA:</span>
    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">Mntheory</span><span class="operator">=:</span><span class="variable">all</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'foroddcomposites { say if $_ % carmichael_lambda($_) == 1 } 1e6;'</span>
</code></pre>

<p>Examining the &eta;3(x) function of Planat and Sol&eacute; (2011):</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> nu3 </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$phix</span> <span class="operator">=</span> <span class="variable">chebyshev_psi</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$nu3</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$nu</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">3</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$nu3</span> <span class="operator">+=</span> <span class="operator">(</span><span class="variable">moebius</span><span class="operator">(</span><span class="variable">$nu</span><span class="operator">)/</span><span class="variable">$nu</span><span class="operator">)</span><span class="variable">*LogarithmicIntegral</span><span class="operator">(</span><span class="variable">$phix</span><span class="operator">**(</span><span class="number">1</span><span class="operator">/</span><span class="variable">$nu</span><span class="operator">));</span>
    <span class="operator">}</span>
    <span class="keyword">return</span> <span class="variable">$nu3</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">say</span> <span class="variable">prime_count</span><span class="operator">(</span><span class="number">1000000</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">prime_count_approx</span><span class="operator">(</span><span class="number">1000000</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">nu3</span><span class="operator">(</span><span class="number">1000000</span><span class="operator">);</span>
</code></pre>

<p>Construct and use a Sophie-Germain prime iterator:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> make_sophie_germain_iterator </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span> <span class="operator">||</span> <span class="number">2</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$it</span> <span class="operator">=</span> <span class="variable">prime_iterator</span><span class="operator">(</span><span class="variable">$p</span><span class="operator">);</span>
    <span class="keyword">return</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
      <span class="keyword">do</span> <span class="operator">{</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="variable">$it</span><span class="operator">-&gt;()</span> <span class="operator">}</span> <span class="keyword">while</span> <span class="operator">!</span><span class="variable">is_prime</span><span class="operator">(</span><span class="number">2</span><span class="operator">*</span><span class="variable">$p</span><span class="operator">+</span><span class="number">1</span><span class="operator">);</span>
      <span class="variable">$p</span><span class="operator">;</span>
    <span class="operator">};</span>
  <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">$sgit</span> <span class="operator">=</span> <span class="variable">make_sophie_germain_iterator</span><span class="operator">();</span>
  <span class="keyword">print</span> <span class="variable">$sgit</span><span class="operator">-&gt;(),</span> <span class="string">"\n"</span>  <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">10000</span><span class="operator">;</span>
</code></pre>

<p>Project Euler, problem 3 (Largest prime factor):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/factor/</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">bigint</span><span class="operator">;</span>  <span class="comment"># Only necessary for 32-bit machines.</span>
  <span class="keyword">say</span> <span class="number">0</span><span class="operator">+(</span><span class="variable">factor</span><span class="operator">(</span><span class="number">600851475143</span><span class="operator">))</span><span class="operator">[</span><span class="operator">-</span><span class="number">1</span><span class="operator">]</span>
</code></pre>

<p>Project Euler, problem 7 (10001st prime):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/nth_prime/</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">nth_prime</span><span class="operator">(</span><span class="number">10_001</span><span class="operator">);</span>
</code></pre>

<p>Project Euler, problem 10 (summation of primes):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/sum_primes/</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">sum_primes</span><span class="operator">(</span><span class="number">2_000_000</span><span class="operator">);</span>
  <span class="comment">#  ... or do it a little more manually ...</span>
  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/forprimes/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$sum</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$_</span> <span class="operator">}</span> <span class="number">2_000_000</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">$sum</span><span class="operator">;</span>
  <span class="comment">#  ... or do it using a big list ...</span>
  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/vecsum primes/</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">vecsum</span><span class="operator">(</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">primes</span><span class="operator">(</span><span class="number">2_000_000</span><span class="operator">)</span><span class="operator">}</span> <span class="operator">);</span>
</code></pre>

<p>Project Euler, problem 21 (Amicable numbers):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/divisor_sum/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$sum</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">10000</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$y</span> <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$x</span><span class="operator">)-</span><span class="variable">$x</span><span class="operator">;</span>
    <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">$x</span> <span class="operator">+</span> <span class="variable">$y</span> <span class="keyword">if</span> <span class="variable">$y</span> <span class="operator">&gt;</span> <span class="variable">$x</span> <span class="operator">&amp;&amp;</span> <span class="variable">$x</span> <span class="operator">==</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$y</span><span class="operator">)-</span><span class="variable">$y</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">say</span> <span class="variable">$sum</span><span class="operator">;</span>
  <span class="comment"># Or using a pipeline:</span>
  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/vecsum divisor_sum/</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">vecsum</span><span class="operator">(</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span>
              <span class="keyword">grep</span> <span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$y</span> <span class="operator">=</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)-</span><span class="variable">$_</span><span class="operator">;</span>
                     <span class="variable">$y</span> <span class="operator">&gt;</span> <span class="variable">$_</span> <span class="operator">&amp;&amp;</span> <span class="variable">$_</span><span class="operator">==(</span><span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$y</span><span class="operator">)-</span><span class="variable">$y</span><span class="operator">)</span> <span class="operator">}</span>
              <span class="number">1</span> <span class="operator">..</span> <span class="number">10000</span> <span class="operator">);</span>
</code></pre>

<p>Project Euler, problem 41 (Pandigital prime), brute force command line:</p>

<pre><code>  <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MMath::Prime::Util</span><span class="operator">=</span><span class="variable">primes</span> <span class="operator">-</span><span class="variable">MList::Util</span><span class="operator">=</span><span class="variable">first</span> <span class="operator">-</span><span class="variable">E</span> <span class="string">'say first { /1/&amp;&amp;/2/&amp;&amp;/3/&amp;&amp;/4/&amp;&amp;/5/&amp;&amp;/6/&amp;&amp;/7/} reverse @{primes(1000000,9999999)};'</span>
</code></pre>

<p>Project Euler, problem 47 (Distinct primes factors):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/pn_primorial factor_exp/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="number">4</span><span class="operator">);</span>  <span class="comment"># Start with the first 4-factor number</span>
  <span class="comment"># factor_exp in scalar context returns the number of distinct prime factors</span>
  <span class="variable">$n</span><span class="operator">++</span> <span class="keyword">while</span> <span class="operator">(</span><span class="variable">factor_exp</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">4</span> <span class="operator">||</span> <span class="variable">factor_exp</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">+</span><span class="number">1</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">4</span> <span class="operator">||</span> <span class="variable">factor_exp</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">+</span><span class="number">2</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">4</span> <span class="operator">||</span> <span class="variable">factor_exp</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">+</span><span class="number">3</span><span class="operator">)</span> <span class="operator">!=</span> <span class="number">4</span><span class="operator">);</span>
  <span class="keyword">say</span> <span class="variable">$n</span><span class="operator">;</span>
</code></pre>

<p>Project Euler, problem 69, stupid brute force solution (about 1 second):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/euler_phi/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$maxn</span><span class="operator">,</span> <span class="variable">$maxratio</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">0</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">1000000</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$ndivphi</span> <span class="operator">=</span> <span class="variable">$n</span> <span class="operator">/</span> <span class="variable">euler_phi</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
    <span class="operator">(</span><span class="variable">$maxn</span><span class="operator">,</span> <span class="variable">$maxratio</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span> <span class="variable">$ndivphi</span><span class="operator">)</span> <span class="keyword">if</span> <span class="variable">$ndivphi</span> <span class="operator">&gt;</span> <span class="variable">$maxratio</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$maxn</span><span class="string">  </span><span class="variable">$maxratio</span><span class="string">"</span><span class="operator">;</span>
</code></pre>

<p>Here is the right way to do PE problem 69 (under 0.03s):</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/pn_primorial/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$n</span><span class="operator">++</span> <span class="keyword">while</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">+</span><span class="number">1</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">1000000</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">pn_primorial</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
</code></pre>

<p>Project Euler, problem 187, stupid brute force solution, 1 to 2 minutes:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/forcomposites factor/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$nsemis</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">forcomposites</span> <span class="operator">{</span> <span class="variable">$nsemis</span><span class="operator">++</span> <span class="keyword">if</span> <span class="keyword">scalar</span> <span class="variable">factor</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">2</span><span class="operator">;</span> <span class="operator">}</span> <span class="keyword">int</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">8</span><span class="operator">)-</span><span class="number">1</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="variable">$nsemis</span><span class="operator">;</span>
</code></pre>

<p>Here is one of the best ways for PE187: under 20 milliseconds from the command line. Much faster than Pari, and competitive with Mathematica.</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/forprimes prime_count/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$limit</span> <span class="operator">=</span> <span class="keyword">shift</span> <span class="operator">||</span> <span class="keyword">int</span><span class="operator">(</span><span class="number">10</span><span class="operator">**</span><span class="number">8</span><span class="operator">);</span>
  <span class="variable">$limit</span><span class="operator">--;</span>
  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$sum</span><span class="operator">,</span> <span class="variable">$pc</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
  <span class="variable">forprimes</span> <span class="operator">{</span>
    <span class="variable">$sum</span> <span class="operator">+=</span> <span class="variable">prime_count</span><span class="operator">(</span><span class="keyword">int</span><span class="operator">(</span><span class="variable">$limit</span><span class="operator">/</span><span class="variable">$_</span><span class="operator">))</span> <span class="operator">+</span> <span class="number">1</span> <span class="operator">-</span> <span class="variable">$pc</span><span class="operator">++;</span>
  <span class="operator">}</span> <span class="keyword">int</span><span class="operator">(</span><span class="keyword">sqrt</span><span class="operator">(</span><span class="variable">$limit</span><span class="operator">));</span>
  <span class="keyword">say</span> <span class="variable">$sum</span><span class="operator">;</span>
</code></pre>

<p>To get the result of <a>&quot;matches&quot; in Math::Factor::XS</a>:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/divisors/</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> matches </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">@d</span> <span class="operator">=</span> <span class="variable">divisors</span><span class="operator">(</span><span class="keyword">shift</span><span class="operator">);</span>
    <span class="keyword">return</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="operator">[</span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">]</span><span class="operator">,</span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$#d</span><span class="operator">-</span><span class="variable">$_</span><span class="operator">]]</span> <span class="operator">}</span> <span class="number">1</span><span class="operator">..(</span><span class="variable">@d</span><span class="operator">-</span><span class="number">1</span><span class="operator">)&gt;&gt;</span><span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="number">139650</span><span class="operator">;</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> = "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">" = "</span><span class="operator">,</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="string">"</span><span class="variable">$_</span><span class="string">-&gt;[0]</span><span class="variable">$_</span><span class="string">-&gt;[1]"</span> <span class="operator">}</span> <span class="variable">matches</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">));</span>
</code></pre>

<p>or its <code>matches</code> function with the <code>skip_multiples</code> option:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> matches </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">@d</span> <span class="operator">=</span> <span class="variable">divisors</span><span class="operator">(</span><span class="keyword">shift</span><span class="operator">);</span>
    <span class="keyword">return</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="operator">[</span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">]</span><span class="operator">,</span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$#d</span><span class="operator">-</span><span class="variable">$_</span><span class="operator">]]</span> <span class="operator">}</span>
           <span class="keyword">grep</span> <span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$div</span><span class="operator">=</span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">]</span><span class="operator">;</span> <span class="operator">!</span><span class="keyword">scalar</span><span class="operator">(</span><span class="keyword">grep</span> <span class="operator">{!(</span><span class="variable">$div</span> <span class="operator">% </span><span class="variable">$d</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">]</span><span class="operator">)}</span> <span class="number">1</span><span class="operator">..</span><span class="variable">$_</span><span class="operator">-</span><span class="number">1</span><span class="operator">)</span> <span class="operator">}</span>
           <span class="number">1</span><span class="operator">..(</span><span class="variable">@d</span><span class="operator">-</span><span class="number">1</span><span class="operator">)&gt;&gt;</span><span class="number">1</span><span class="operator">;</span> <span class="operator">}</span>
  <span class="operator">}</span>
</code></pre>

<p>Compute <a href="http://oeis.org/A054903">OEIS A054903</a> just like CRG4s Pari example:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/forcomposite divisor_sum/</span><span class="operator">;</span>
  <span class="variable">forcomposites</span> <span class="operator">{</span>
    <span class="keyword">say</span> <span class="keyword">if</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)+</span><span class="number">6</span> <span class="operator">==</span> <span class="variable">divisor_sum</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">+</span><span class="number">6</span><span class="operator">)</span>
  <span class="operator">}</span> <span class="number">9</span><span class="operator">,</span><span class="number">1e7</span><span class="operator">;</span>
</code></pre>

<p>Construct the table shown in <a href="http://oeis.org/A046147">OEIS A046147</a>:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/znorder euler_phi gcd/</span><span class="operator">;</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">100</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">znprimroot</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">))</span> <span class="operator">{</span>
      <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> -"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$phi</span> <span class="operator">=</span> <span class="variable">euler_phi</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">);</span>
      <span class="keyword">my</span> <span class="variable">@r</span> <span class="operator">=</span> <span class="keyword">grep</span> <span class="operator">{</span> <span class="variable">gcd</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="variable">znorder</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">==</span> <span class="variable">$phi</span> <span class="operator">}</span> <span class="number">1</span><span class="operator">..</span><span class="variable">$n</span><span class="operator">-</span><span class="number">1</span><span class="operator">;</span>
      <span class="keyword">say</span> <span class="string">"</span><span class="variable">$n</span><span class="string"> "</span><span class="operator">,</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">" "</span><span class="operator">,</span> <span class="variable">@r</span><span class="operator">);</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</code></pre>

<p>Find the 7-digit palindromic primes in the first 20k digits of Pi:</p>

<pre><code>  <span class="keyword">use</span> <span class="variable">Math::Prime::Util</span> <span class="string">qw/Pi is_prime/</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$pi</span> <span class="operator">=</span> <span class="string">""</span><span class="operator">.</span><span class="variable">Pi</span><span class="operator">(</span><span class="number">20000</span><span class="operator">);</span>  <span class="comment"># make sure we only stringify once</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$pos</span> <span class="operator">(</span><span class="number">2</span> <span class="operator">..</span> <span class="keyword">length</span><span class="operator">(</span><span class="variable">$pi</span><span class="operator">)-</span><span class="number">7</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$s</span> <span class="operator">=</span> <span class="keyword">substr</span><span class="operator">(</span><span class="variable">$pi</span><span class="operator">,</span> <span class="variable">$pos</span><span class="operator">,</span> <span class="number">7</span><span class="operator">);</span>
    <span class="keyword">say</span> <span class="string">"</span><span class="variable">$s</span><span class="string"> at </span><span class="variable">$pos</span><span class="string">"</span> <span class="keyword">if</span> <span class="variable">$s</span> <span class="keyword">eq</span> <span class="keyword">reverse</span><span class="operator">(</span><span class="variable">$s</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$s</span><span class="operator">);</span>
  <span class="operator">}</span>
  
  <span class="comment"># Or we could use the regex engine to find the palindromes:</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$pi</span> <span class="operator">=~</span> <span class="regex">/(([1379])(\d)(\d)\d\4\3\2)/g</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">say</span> <span class="string">"</span><span class="variable">$1</span><span class="string"> at "</span><span class="operator">,</span><span class="keyword">pos</span><span class="operator">(</span><span class="variable">$pi</span><span class="operator">)-</span><span class="number">7</span> <span class="keyword">if</span> <span class="variable">is_prime</span><span class="operator">(</span><span class="variable">$1</span><span class="operator">)</span>
  <span class="operator">}</span>
</code></pre>

<p>The <a href="https://en.wikipedia.org/wiki/Bell_number">Bell numbers</a> B_n:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> B </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="variable">vecsum</span><span class="operator">(</span><span class="keyword">map</span> <span class="operator">{</span> <span class="variable">stirling</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">,</span><span class="number">2</span><span class="operator">)</span> <span class="operator">}</span> <span class="number">0</span><span class="operator">..</span><span class="variable">$n</span><span class="operator">)</span> <span class="operator">}</span>
  <span class="keyword">say</span> <span class="string">"</span><span class="variable">$_</span><span class="string">  "</span><span class="operator">,</span><span class="variable">B</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="keyword">for</span> <span class="number">1</span><span class="operator">..</span><span class="number">50</span><span class="operator">;</span>
</code></pre>

<p>Recognizing tetrahedral numbers (<a href="http://oeis.org/A000292">OEIS A000292</a>):</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> is_tetrahedral </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$n6</span> <span class="operator">=</span> <span class="variable">vecprod</span><span class="operator">(</span><span class="number">6</span><span class="operator">,</span><span class="keyword">shift</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$k</span>  <span class="operator">=</span> <span class="variable">rootint</span><span class="operator">(</span><span class="variable">$n6</span><span class="operator">,</span><span class="number">3</span><span class="operator">);</span>
    <span class="variable">vecprod</span><span class="operator">(</span><span class="variable">$k</span><span class="operator">,</span><span class="variable">$k</span><span class="operator">+</span><span class="number">1</span><span class="operator">,</span><span class="variable">$k</span><span class="operator">+</span><span class="number">2</span><span class="operator">)</span> <span class="operator">==</span> <span class="variable">$n6</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></pre>

<p>Recognizing powerful numbers (e.g. <code>ispowerful</code> from Pari/GP):</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> ispowerful </span><span class="operator">{</span> <span class="number">0</span> <span class="operator">+</span> <span class="variable">vecall</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">&gt;</span> <span class="number">1</span> <span class="operator">}</span> <span class="variable">factor_exp</span><span class="operator">(</span><span class="keyword">shift</span><span class="operator">);</span> <span class="operator">}</span>
</code></pre>

<p>Convert from binary to hex (3000x faster than Math::BaseConvert):</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$hex_string</span> <span class="operator">=</span> <span class="variable">todigitstring</span><span class="operator">(</span><span class="variable">fromdigits</span><span class="operator">(</span><span class="variable">$bin_string</span><span class="operator">,</span><span class="number">2</span><span class="operator">),</span><span class="number">16</span><span class="operator">);</span>
</code></pre>

<p>Calculate and print derangements using permutations:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">@data</span> <span class="operator">=</span> <span class="string">qw/a b c d/</span><span class="operator">;</span>
  <span class="variable">forperm</span> <span class="operator">{</span> <span class="keyword">say</span> <span class="string">"</span><span class="variable">@data</span><span class="string">[</span><span class="variable">@_</span><span class="string">]"</span> <span class="keyword">unless</span> <span class="variable">vecany</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">]</span><span class="operator">==</span><span class="variable">$_</span> <span class="operator">}</span> <span class="number">0</span><span class="operator">..</span><span class="variable">$#_</span> <span class="operator">}</span> <span class="variable">@data</span><span class="operator">;</span>
  <span class="comment"># Using forderange directly is faster</span>
</code></pre>

<p>Compute the subfactorial of n (<a href="http://oeis.org/A000166">OEIS A000166</a>):</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> subfactorial </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="variable">vecsum</span><span class="operator">(</span><span class="keyword">map</span><span class="operator">{</span> <span class="variable">vecprod</span><span class="operator">((-</span><span class="number">1</span><span class="operator">)**(</span><span class="variable">$n</span><span class="operator">-</span><span class="variable">$_</span><span class="operator">),</span><span class="variable">binomial</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">),</span><span class="variable">factorial</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">))</span> <span class="operator">}</span><span class="number">0</span><span class="operator">..</span><span class="variable">$n</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></pre>

<p>Compute subfactorial (number of derangements) using simple recursion:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> subfactorial </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">bigint</span><span class="operator">;</span>
    <span class="operator">(</span><span class="variable">$n</span> <span class="operator">&lt;</span> <span class="number">1</span><span class="operator">)</span>  <span class="operator">?</span>  <span class="number">1</span>  <span class="operator">:</span>  <span class="variable">$n</span> <span class="operator">*</span> <span class="variable">subfactorial</span><span class="operator">(</span><span class="variable">$n</span><span class="operator">-</span><span class="number">1</span><span class="operator">)</span> <span class="operator">+</span> <span class="operator">(-</span><span class="number">1</span><span class="operator">)**</span><span class="variable">$n</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></pre>

<h1 id="PRIMALITY-TESTING-NOTES">PRIMALITY TESTING NOTES</h1>

<p>Above <code>2^64</code>, <a href="#is_prob_prime">&quot;is_prob_prime&quot;</a> performs an extra-strong <a href="http://en.wikipedia.org/wiki/Baillie-PSW_primality_test">BPSW test</a> which is fast (a little less than the time to perform 3 Miller-Rabin tests) and has no known counterexamples. If you trust the primality testing done by Pari, Maple, SAGE, FLINT, etc., then this function should be appropriate for you. <a href="#is_prime">&quot;is_prime&quot;</a> will do the same BPSW test as well as some additional testing, making it slightly more time consuming but less likely to produce a false result. This is a little more stringent than Mathematica. <a href="#is_provable_prime">&quot;is_provable_prime&quot;</a> constructs a primality proof. If a certificate is requested, then either BLS75 theorem 5 or ECPP is performed. Without a certificate, the method is implementation specific (currently it is identical, but later releases may use APRCL). With <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> installed, this is quite fast through 300 or so digits.</p>

<p>Math systems 30 years ago typically used Miller-Rabin tests with <code>k</code> bases (usually fixed bases, sometimes random) for primality testing, but these have generally been replaced by some form of BPSW as used in this module. See Pinch&#39;s 1993 paper for examples of why using <code>k</code> M-R tests leads to poor results. The three exceptions in common contemporary use I am aware of are:</p>

<dl>

<dt id="libtommath">libtommath</dt>
<dd>

<p>Uses the first <code>k</code> prime bases. This is problematic for cryptographic use, as there are known methods (e.g. Arnault 1994) for constructing counterexamples. The number of bases required to avoid false results is unreasonably high, hence performance is slow even if one ignores counterexamples. Unfortunately this is the multi-precision math library used for Perl 6 and at least one CPAN Crypto module.</p>

</dd>
<dt id="GMP-MPIR">GMP/MPIR</dt>
<dd>

<p>Uses a set of <code>k</code> static-random bases. The bases are randomly chosen using a PRNG that is seeded identically each call (the seed changes with each release). This offers a very slight advantage over using the first <code>k</code> prime bases, but not much. See, for example, Nicely&#39;s <a href="http://www.trnicely.net/misc/mpzspsp.html">mpz_probab_prime_p pseudoprimes</a> page.</p>

</dd>
<dt id="Math::Pari-not-recent-Pari-GP"><a>Math::Pari</a> (not recent Pari/GP)</dt>
<dd>

<p>Pari 2.1.7 is the default version installed with the <a>Math::Pari</a> module. It uses 10 random M-R bases (the PRNG uses a fixed seed set at compile time). Pari 2.3.0 was released in May 2006 and it, like all later releases through at least 2.6.1, use BPSW / APRCL, after complaints of false results from using M-R tests. For example, it will indicate 9 is prime about 1 out of every 276k calls.</p>

</dd>
</dl>

<p>Basically the problem is that it is just too easy to get counterexamples from running <code>k</code> M-R tests, forcing one to use a very large number of tests (at least 20) to avoid frequent false results. Using the BPSW test results in no known counterexamples after 30+ years and runs much faster. It can be enhanced with one or more random bases if one desires, and will <i>still</i> be much faster.</p>

<p>Using <code>k</code> fixed bases has another problem, which is that in any adversarial situation we can assume the inputs will be selected such that they are one of our counterexamples. Now we need absurdly large numbers of tests. This is like playing &quot;pick my number&quot; but the number is fixed forever at the start, the guesser gets to know everyone else&#39;s guesses and results, and can keep playing as long as they like. It&#39;s only valid if the players are completely oblivious to what is happening.</p>

<h1 id="LIMITATIONS">LIMITATIONS</h1>

<p>Perl versions earlier than 5.8.0 have problems doing exact integer math. Some operations will flip signs, and many operations will convert intermediate or output results to doubles, which loses precision on 64-bit systems. This causes numerous functions to not work properly. The test suite will try to determine if your Perl is broken (this only applies to really old versions of Perl compiled for 64-bit when using numbers larger than <code>~ 2^49</code>). The best solution is updating to a more recent Perl.</p>

<p>The module is thread-safe and should allow good concurrency on all platforms that support Perl threads except Win32. With Win32, either don&#39;t use threads or make sure <code>prime_precalc</code> is called before using <code>primes</code>, <code>prime_count</code>, or <code>nth_prime</code> with large inputs. This is <b>only</b> an issue if you use non-Cygwin Win32 <b>and</b> call these routines from within Perl threads.</p>

<p>Because the loop functions like <a href="#forprimes">&quot;forprimes&quot;</a> use <code>MULTICALL</code>, there is some odd behavior with anonymous sub creation inside the block. This is shared with most XS modules that use <code>MULTICALL</code>, and is rarely seen because it is such an unusual use. An example is:</p>

<pre><code>  <span class="variable">forprimes</span> <span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">=</span> <span class="string">"p is </span><span class="variable">$_</span><span class="string">"</span><span class="operator">;</span> <span class="keyword">push</span> <span class="variable">@subs</span><span class="operator">,</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">say</span> <span class="variable">$var</span><span class="operator">};</span> <span class="operator">}</span> <span class="number">50</span><span class="operator">;</span>
  <span class="variable">$_</span><span class="operator">-&gt;()</span> <span class="keyword">for</span> <span class="variable">@subs</span><span class="operator">;</span>
</code></pre>

<p>This can be worked around by using double braces for the function, e.g. <code><span class="variable">forprimes</span> <span class="operator">{{</span> <span class="operator">...</span> <span class="operator">}}</span> <span class="number">50</span>
</code>.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>This section describes other CPAN modules available that have some feature overlap with this one. Also see the <a href="#REFERENCES">&quot;REFERENCES&quot;</a> section. Please let me know if any of this information is inaccurate. Also note that just because a module doesn&#39;t match what I believe are the best set of features doesn&#39;t mean it isn&#39;t perfect for someone else.</p>

<p>I will use SoE to indicate the Sieve of Eratosthenes, and MPU to denote this module (<a href="../../../lib/Math/Prime/Util.html">Math::Prime::Util</a>). Some quick alternatives I can recommend if you don&#39;t want to use MPU:</p>

<ul>

<li><p><a>Math::Prime::FastSieve</a> is the alternative module I use for basic functionality with small integers. It&#39;s fast and simple, and has a good set of features.</p>

</li>
<li><p><a>Math::Primality</a> is the alternative module I use for primality testing on bigints. The downside is that it can be slow, and the functions other than primality tests are <i>very</i> slow.</p>

</li>
<li><p><a>Math::Pari</a> if you want the kitchen sink and can install it and handle using it. There are still some functions it doesn&#39;t do well (e.g. prime count and nth_prime).</p>

</li>
</ul>

<p><a>Math::Prime::XS</a> has <code>is_prime</code> and <code>primes</code> functionality. There is no bigint support. The <code>is_prime</code> function uses well-written trial division, meaning it is very fast for small numbers, but terribly slow for large 64-bit numbers. MPU is similarly fast with small numbers, but becomes faster as the size increases. MPXS&#39;s prime sieve is an unoptimized non-segmented SoE which returns an array. Sieve bases larger than <code>10^7</code> start taking inordinately long and using a lot of memory (gigabytes beyond <code>10^10</code>). E.g. <code>primes(10**9, 10**9+1000)</code> takes 36 seconds with MPXS, but only 0.0001 seconds with MPU.</p>

<p><a>Math::Prime::FastSieve</a> supports <code>primes</code>, <code>is_prime</code>, <code>next_prime</code>, <code>prev_prime</code>, <code>prime_count</code>, and <code>nth_prime</code>. The caveat is that all functions only work within the sieved range, so are limited to about <code>10^10</code>. It uses a fast SoE to generate the main sieve. The sieve is 2-3x slower than the base sieve for MPU, and is non-segmented so cannot be used for larger values. Since the functions work with the sieve, they are very fast. The fast bit-vector-lookup functionality can be replicated in MPU using <code>prime_precalc</code> but is not required.</p>

<p><a href="../../../lib/Bit/Vector.html">Bit::Vector</a> supports the <code>primes</code> and <code>prime_count</code> functionality in a somewhat similar way to <a>Math::Prime::FastSieve</a>. It is the slowest of all the XS sieves, and has the most memory use. It is faster than pure Perl code.</p>

<p><a>Crypt::Primes</a> supports <code>random_maurer_prime</code> functionality. MPU has more options for random primes (n-digit, n-bit, ranged, strong, and S-T) in addition to Maurer&#39;s algorithm. MPU does not have the critical bug <a href="https://rt.cpan.org/Ticket/Display.html?id=81858">RT81858</a>. MPU has a more uniform distribution as well as return a larger subset of primes (<a href="https://rt.cpan.org/Ticket/Display.html?id=81871">RT81871</a>). MPU does not depend on <a>Math::Pari</a> though can run slow for bigints unless the <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> or <a>Math::BigInt::Pari</a> modules are installed. Having <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> installed makes the speed vastly faster. Crypt::Primes is hardcoded to use <a>Crypt::Random</a> which uses /dev/random (blocking source), while MPU uses its own ChaCha20 implementation seeded from /dev/urandom or Win32. MPU can return a primality certificate. What Crypt::Primes has that MPU does not is the ability to return a generator.</p>

<p><a>Math::Factor::XS</a> calculates prime factors and factors, which correspond to the <a href="#factor">&quot;factor&quot;</a> and <a href="#divisors">&quot;divisors&quot;</a> functions of MPU. Its functions do not support bigints. Both are implemented with trial division, meaning they are very fast for really small values, but become very slow as the input gets larger (factoring 19 digit semiprimes is over 1000 times slower). The function <code>count_prime_factors</code> can be done in MPU using <code>scalar factor($n)</code>. See the <a href="#EXAMPLES">&quot;EXAMPLES&quot;</a> section for a 2-line function replicating <code>matches</code>.</p>

<p><a>Math::Big</a> version 1.12 includes <code>primes</code> functionality. The current code is only usable for very tiny inputs as it is incredibly slow and uses lots of memory. <a href="https://rt.cpan.org/Ticket/Display.html?id=81986">RT81986</a> has a patch to make it run much faster and use much less memory. Since it is in pure Perl it will still run quite slow compared to MPU.</p>

<p><a>Math::Big::Factors</a> supports factorization using wheel factorization (smart trial division). It supports bigints. Unfortunately it is extremely slow on any input that isn&#39;t the product of just small factors. Even 7 digit inputs can take hundreds or thousands of times longer to factor than MPU or <a>Math::Factor::XS</a>. 19-digit semiprimes will take <i>hours</i> versus MPU&#39;s single milliseconds.</p>

<p><a>Math::Factoring</a> is a placeholder module for bigint factoring. Version 0.02 only supports trial division (the Pollard-Rho method does not work).</p>

<p><a>Math::Prime::TiedArray</a> allows random access to a tied primes array, almost identically to what MPU provides in <a href="../../../lib/Math/Prime/Util/PrimeArray.html">Math::Prime::Util::PrimeArray</a>. MPU has attempted to fix Math::Prime::TiedArray&#39;s shift bug (<a href="https://rt.cpan.org/Ticket/Display.html?id=58151">RT58151</a>). MPU is typically much faster and will use less memory, but there are some cases where MP:TA is faster (MP:TA stores all entries up to the largest request, while MPU:PA stores only a window around the last request).</p>

<p><a>List::Gen</a> is very interesting and includes a built-in primes iterator as well as a <code>is_prime</code> filter for arbitrary sequences. Unfortunately both are very slow.</p>

<p><a>Math::Primality</a> supports <code>is_prime</code>, <code>is_pseudoprime</code>, <code>is_strong_pseudoprime</code>, <code>is_strong_lucas_pseudoprime</code>, <code>next_prime</code>, <code>prev_prime</code>, <code>prime_count</code>, and <code>is_aks_prime</code> functionality. This is a great little module that implements primality functionality. It was the first CPAN module to support the BPSW test. All inputs are processed using GMP, so it of course supports bigints. In fact, Math::Primality was made originally with bigints in mind, while MPU was originally targeted to native integers, but both have added better support for the other. The main differences are extra functionality (MPU has more functions) and performance. With native integer inputs, MPU is generally much faster, especially with <a href="#prime_count">&quot;prime_count&quot;</a>. For bigints, MPU is slower unless the <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> module is installed, in which case MPU is 2-4x faster. <a>Math::Primality</a> also installs a <code>primes.pl</code> program, but it has much less functionality than the one included with MPU.</p>

<p><a>Math::NumSeq</a> does not have a one-to-one mapping between functions in MPU, but it does offer a way to get many similar results such as primes, twin primes, Sophie-Germain primes, lucky primes, moebius, divisor count, factor count, Euler totient, primorials, etc. Math::NumSeq is set up for accessing these values in order rather than for arbitrary values, though a few sequences support random access. The primary advantage I see is the uniform access mechanism for a <i>lot</i> of sequences. For those methods that overlap, MPU is usually much faster. Importantly, most of the sequences in Math::NumSeq are limited to 32-bit indices.</p>

<p><a>&quot;cr_combine&quot; in Math::ModInt::ChineseRemainder</a> is similar to MPU&#39;s <a href="#chinese">&quot;chinese&quot;</a>, and in fact they use the same algorithm. The former module uses caching of moduli to speed up further operations. MPU does not do this. This would only be important for cases where the lcm is larger than a native int (noting that use in cryptography would always have large moduli).</p>

<p>For combinations and permutations there are many alternatives. One difference with nearly all of them is that MPU&#39;s <a href="#forcomb">&quot;forcomb&quot;</a> and <a href="#forperm">&quot;forperm&quot;</a> functions don&#39;t operate directly on a user array but on generic indices. <a>Math::Combinatorics</a> and <a>Algorithm::Combinatorics</a> have more features, but will be slower. <a>List::Permutor</a> does permutations with an iterator. <a>Algorithm::FastPermute</a> and <a>Algorithm::Permute</a> are very similar but can be 2-10x faster than MPU (they use the same user-block structure but twiddle the user array each call).</p>

<p><a>Math::Pari</a> supports a lot of features, with a great deal of overlap. In general, MPU will be faster for native 64-bit integers, while it&#39;s differs for bigints (Pari will always be faster if <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> is not installed; with it, it varies by function). Note that Pari extends many of these functions to other spaces (Gaussian integers, complex numbers, vectors, matrices, polynomials, etc.) which are beyond the realm of this module. Some of the highlights:</p>

<dl>

<dt id="isprime"><code>isprime</code></dt>
<dd>

<p>The default <a>Math::Pari</a> is built with Pari 2.1.7. This uses 10 M-R tests with randomly chosen bases (fixed seed, but doesn&#39;t reset each invocation like GMP&#39;s <code>is_probab_prime</code>). This has a much greater chance of false positives compared to the BPSW test -- some composites such as <code>9</code>, <code>88831</code>, <code>38503</code>, etc. (<a href="http://oeis.org/A141768">OEIS A141768</a>) have a surprisingly high chance of being indicated prime. Using <code>isprime($n,1)</code> will perform an <code>n-1</code> proof, but this becomes unreasonably slow past 70 or so digits.</p>

<p>If <a>Math::Pari</a> is built using Pari 2.3.5 (this requires manual configuration) then the primality tests are completely different. Using <code>ispseudoprime</code> will perform a BPSW test and is quite a bit faster than the older test. <code>isprime</code> now does an APR-CL proof (fast, but no certificate).</p>

<p><a>Math::Primality</a> uses a strong BPSW test, which is the standard BPSW test based on the 1980 paper. It has no known counterexamples (though like all these tests, we know some exist). Pari 2.3.5 (and through at least 2.6.2) uses an almost-extra-strong BPSW test for its <code>ispseudoprime</code> function. This is deterministic for native integers, and should be excellent for bigints, with a slightly lower chance of counterexamples than the traditional strong test. <a href="../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> uses the full extra-strong BPSW test, which has an even lower chance of counterexample. With <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a>, <code>is_prime</code> adds an extra M-R test using a random base, which further reduces the probability of a composite being allowed to pass.</p>

</dd>
<dt id="primepi"><code>primepi</code></dt>
<dd>

<p>Only available with version 2.3 of Pari. Similar to MPU&#39;s <a href="#prime_count">&quot;prime_count&quot;</a> function in API, but uses a naive counting algorithm with its precalculated primes, so is not of practical use. Incidently, Pari 2.6 (not usable from Perl) has fixed the pre-calculation requirement so it is more useful, but is still thousands of times slower than MPU.</p>

</dd>
<dt id="primes1"><code>primes</code></dt>
<dd>

<p>Doesn&#39;t support ranges, requires bumping up the precalculated primes for larger numbers, which means knowing in advance the upper limit for primes. Support for numbers larger than 400M requires using Pari version 2.3.5. If that is used, sieving is about 2x faster than MPU, but doesn&#39;t support segmenting.</p>

</dd>
<dt id="factorint"><code>factorint</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#factor_exp">&quot;factor_exp&quot;</a> though with a slightly different return. MPU offers <a href="#factor">&quot;factor&quot;</a> for a linear array of prime factors where n = p1 * p2 * p3 * ... as (p1,p2,p3,...) and <a href="#factor_exp">&quot;factor_exp&quot;</a> for an array of factor/exponent pairs where: n = p1^e1 * p2^e2 * ... as ([p1,e1],[p2,e2],...) Pari/GP returns an array similar to the latter. <a>Math::Pari</a> returns a transposed matrix like: n = p1^e1 * p2^e2 * ... as ([p1,p2,...],[e1,e2,...]) Slower than MPU for all 64-bit inputs on an x86_64 platform, it may be faster for large values on other platforms. With the newer <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> releases, bigint factoring is slightly faster on average in MPU.</p>

</dd>
<dt id="divisors1"><code>divisors</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#divisors">&quot;divisors&quot;</a>.</p>

</dd>
<dt id="forprime-forcomposite-fordiv-sumdiv"><code>forprime</code>, <code>forcomposite</code>, <code>fordiv</code>, <code>sumdiv</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#forprimes">&quot;forprimes&quot;</a>, <a href="#forcomposites">&quot;forcomposites&quot;</a>, <a href="#fordivisors">&quot;fordivisors&quot;</a>, and <a href="#divisor_sum">&quot;divisor_sum&quot;</a>.</p>

</dd>
<dt id="eulerphi-moebius"><code>eulerphi</code>, <code>moebius</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#euler_phi">&quot;euler_phi&quot;</a> and <a href="#moebius">&quot;moebius&quot;</a>. MPU is 2-20x faster for native integers. MPU also supported range inputs, which can be much more efficient. With bigint arguments, MPU is slightly faster than Math::Pari if the GMP backend is available, but very slow without.</p>

</dd>
<dt id="gcd-lcm-kronecker-znorder-znprimroot-znlog"><code>gcd</code>, <code>lcm</code>, <code>kronecker</code>, <code>znorder</code>, <code>znprimroot</code>, <code>znlog</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#gcd">&quot;gcd&quot;</a>, <a href="#lcm">&quot;lcm&quot;</a>, <a href="#kronecker">&quot;kronecker&quot;</a>, <a href="#znorder">&quot;znorder&quot;</a>, <a href="#znprimroot">&quot;znprimroot&quot;</a>, and <a href="#znlog">&quot;znlog&quot;</a>. Pari&#39;s <code>znprimroot</code> only returns the smallest root for prime powers. The behavior is undefined when the group is not cyclic (sometimes it throws an exception, sometimes it returns an incorrect answer, sometimes it hangs). MPU&#39;s <a href="#znprimroot">&quot;znprimroot&quot;</a> will always return the smallest root if it exists, and <code>undef</code> otherwise. Similarly, MPU&#39;s <a href="#znlog">&quot;znlog&quot;</a> will return the smallest <code>x</code> and work with non-primitive-root <code>g</code>, which is similar to Pari/GP 2.6, but not the older versions in <a>Math::Pari</a>. The performance of <a href="#znlog">&quot;znlog&quot;</a> is quite good compared to older Pari/GP, but much worse than 2.6&#39;s new methods.</p>

</dd>
<dt id="sigma"><code>sigma</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#divisor_sum">&quot;divisor_sum&quot;</a>. MPU is ~10x faster when the result fits in a native integer. Once things overflow it is fairly similar in performance. However, using <a href="../../../lib/Math/BigInt.html">Math::BigInt</a> can slow things down quite a bit, so for best performance in these cases using a <a>Math::GMP</a> object is best.</p>

</dd>
<dt id="numbpart-forpart"><code>numbpart</code>, <code>forpart</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#partitions">&quot;partitions&quot;</a> and <a href="#forpart">&quot;forpart&quot;</a>. These functions were introduced in Pari 2.3 and 2.6, hence are not in Math::Pari. <code>numbpart</code> produce identical results to <code>partitions</code>, but Pari is <i>much</i> faster. <a>forpart</a> is very similar to Pari&#39;s function, but produces a different ordering (MPU is the standard anti-lexicographical, Pari uses a size sort). Currently Pari is somewhat faster due to Perl function call overhead. When using restrictions, Pari has much better optimizations.</p>

</dd>
<dt id="eint1"><code>eint1</code></dt>
<dd>

<p>Similar to MPU&#39;s <a href="#ExponentialIntegral">&quot;ExponentialIntegral&quot;</a>.</p>

</dd>
<dt id="zeta"><code>zeta</code></dt>
<dd>

<p>MPU has <a href="#RiemannZeta">&quot;RiemannZeta&quot;</a> which takes non-negative real inputs, while Pari&#39;s function supports negative and complex inputs.</p>

</dd>
</dl>

<p>Overall, <a>Math::Pari</a> supports a huge variety of functionality and has a sophisticated and mature code base behind it (noting that the Pari library used is about 10 years old now). For native integers, typically Math::Pari will be slower than MPU. For bigints, Math::Pari may be superior and it rarely has any performance surprises. Some of the unique features MPU offers include super fast prime counts, nth_prime, ECPP primality proofs with certificates, approximations and limits for both, random primes, fast Mertens calculations, Chebyshev theta and psi functions, and the logarithmic integral and Riemann R functions. All with fairly minimal installation requirements.</p>

<h1 id="PERFORMANCE">PERFORMANCE</h1>

<p>First, for those looking for the state of the art non-Perl solutions:</p>

<dl>

<dt id="Primality-testing">Primality testing</dt>
<dd>

<p>For general numbers smaller than 2000 or so digits, MPU is the fastest solution I am aware of (it is faster than Pari 2.7, PFGW, and FLINT). For very large inputs, <a href="http://sourceforge.net/projects/openpfgw/">PFGW</a> is the fastest primality testing software I&#39;m aware of. It has fast trial division, and is especially fast on many special forms. It does not have a BPSW test however, and there are quite a few counterexamples for a given base of its PRP test, so it is commonly used for fast filtering of large candidates. A test such as the BPSW test in this module is then recommended.</p>

</dd>
<dt id="Primality-proofs">Primality proofs</dt>
<dd>

<p><a href="http://www.ellipsa.eu/">Primo</a> is the best method for open source primality proving for inputs over 1000 digits. Primo also does well below that size, but other good alternatives are David Cleaver&#39;s <a href="http://sourceforge.net/projects/mpzaprcl/">mpzaprcl</a>, the APRCL from the modern <a href="http://pari.math.u-bordeaux.fr/">Pari</a> package, or the standalone ECPP from this module with large polynomial set.</p>

</dd>
<dt id="Factoring">Factoring</dt>
<dd>

<p><a href="http://sourceforge.net/projects/yafu/">yafu</a>, <a href="http://sourceforge.net/projects/msieve/">msieve</a>, and <a href="http://ecm.gforge.inria.fr/">gmp-ecm</a> are all good choices for large inputs. The factoring code in this module (and all other CPAN modules) is very limited compared to those.</p>

</dd>
<dt id="Primes">Primes</dt>
<dd>

<p><a href="http://code.google.com/p/primesieve/">primesieve</a> and <a href="http://sourceforge.net/projects/yafu/">yafu</a> are the fastest publically available code I am aware of. Primesieve will additionally take advantage of multiple cores with excellent efficiency. Tom&aacute;s Oliveira e Silva&#39;s private code may be faster for very large values, but isn&#39;t available for testing.</p>

<p>Note that the Sieve of Atkin is <i>not</i> faster than the Sieve of Eratosthenes when both are well implemented. The only Sieve of Atkin that is even competitive is Bernstein&#39;s super optimized <i>primegen</i>, which runs on par with the SoE in this module. The SoE&#39;s in Pari, yafu, and primesieve are all faster.</p>

</dd>
<dt id="Prime-Counts-and-Nth-Prime">Prime Counts and Nth Prime</dt>
<dd>

<p>Outside of private research implementations doing prime counts for <code>n &gt; 2^64</code>, this module should be close to state of the art in performance, and supports results up to <code>2^64</code>. Further performance improvements are planned, as well as expansion to larger values.</p>

<p>The fastest solution for small inputs is a hybrid table/sieve method. This module does this for values below 60M. As the inputs get larger, either the tables have to grow exponentially or speed must be sacrificed. Hence this is not a good general solution for most uses.</p>

</dd>
</dl>

<h2 id="PRIME-COUNTS">PRIME COUNTS</h2>

<p>Counting the primes to <code>800_000_000</code> (800 million):</p>

<pre><code>  Time (s)   Module                      Version  Notes
  ---------  --------------------------  -------  -----------
       0.001 Math::Prime::Util           0.37     using extended LMO
       0.007 Math::Prime::Util           0.12     using Lehmer&#39;s method
       0.27  Math::Prime::Util           0.17     segmented mod-30 sieve
       0.39  Math::Prime::Util::PP       0.24     Perl (Lehmer&#39;s method)
       0.9   Math::Prime::Util           0.01     mod-30 sieve
       2.9   Math::Prime::FastSieve      0.12     decent odd-number sieve
      11.7   Math::Prime::XS             0.26     needs some optimization
      15.0   Bit::Vector                 7.2
      48.9   Math::Prime::Util::PP       0.14     Perl (fastest I know of)
     170.0   Faster Perl sieve (net)     2012-01  array of odds
     548.1   RosettaCode sieve (net)     2012-06  simplistic Perl
    3048.1   Math::Primality             0.08     Perl + Math::GMPz
  &gt;20000     Math::Big                   1.12     Perl, &gt; 26GB RAM used</code></pre>

<p>Python&#39;s standard modules are very slow: MPMATH v0.17 <code>primepi</code> takes 169.5s and 25+ GB of RAM. SymPy 0.7.1 <code>primepi</code> takes 292.2s. However there are very fast solutions written by Robert William Hanks (included in the xt/ directory of this distribution): pure Python in 12.1s and NUMPY in 2.8s.</p>

<h2 id="PRIMALITY-TESTING1">PRIMALITY TESTING</h2>

<dl>

<dt id="Small-inputs:-is_prime-from-1-to-20M">Small inputs: is_prime from 1 to 20M</dt>
<dd>

<pre><code>    2.0s  Math::Prime::Util      (sieve lookup if prime_precalc used)
    2.5s  Math::Prime::FastSieve (sieve lookup)
    3.3s  Math::Prime::Util      (trial + deterministic M-R)
   10.4s  Math::Prime::XS        (trial)
   19.1s  Math::Pari w/2.3.5     (BPSW)
   52.4s  Math::Pari             (10 random M-R)
  480s    Math::Primality        (deterministic M-R)</code></pre>

</dd>
<dt id="Large-native-inputs:-is_prime-from-10-16-to-10-16-20M">Large native inputs: is_prime from 10^16 to 10^16 + 20M</dt>
<dd>

<pre><code>    4.5s  Math::Prime::Util      (BPSW)
   24.9s  Math::Pari w/2.3.5     (BPSW)
  117.0s  Math::Pari             (10 random M-R)
  682s    Math::Primality        (BPSW)
  30 HRS  Math::Prime::XS        (trial)

  These inputs are too large for Math::Prime::FastSieve.</code></pre>

</dd>
<dt id="bigints:-is_prime-from-10-100-to-10-100-0.2M">bigints: is_prime from 10^100 to 10^100 + 0.2M</dt>
<dd>

<pre><code>    2.2s  Math::Prime::Util          (BPSW + 1 random M-R)
    2.7s  Math::Pari w/2.3.5         (BPSW)
   13.0s  Math::Primality            (BPSW)
   35.2s  Math::Pari                 (10 random M-R)
   38.6s  Math::Prime::Util w/o GMP  (BPSW)
   70.7s  Math::Prime::Util          (n-1 or ECPP proof)
  102.9s  Math::Pari w/2.3.5         (APR-CL proof)</code></pre>

</dd>
</dl>

<ul>

<li><p>MPU is consistently the fastest solution, and performs the most stringent probable prime tests on bigints.</p>

</li>
<li><p>Math::Primality has a lot of overhead that makes it quite slow for native size integers. With bigints we finally see it work well.</p>

</li>
<li><p>Math::Pari built with 2.3.5 not only has a better primality test versus the default 2.1.7, but runs faster. It still has quite a bit of overhead with native size integers. Pari/GP 2.5.0 takes 11.3s, 16.9s, and 2.9s respectively for the tests above. MPU is still faster, but clearly the time for native integers is dominated by the calling overhead.</p>

</li>
</ul>

<h2 id="FACTORING">FACTORING</h2>

<p>Factoring performance depends on the input, and the algorithm choices used are still being tuned. <a>Math::Factor::XS</a> is very fast when given input with only small factors, but it slows down rapidly as the smallest factor increases in size. For numbers larger than 32 bits, <a href="../../../lib/Math/Prime/Util.html">Math::Prime::Util</a> can be 100x or more faster (a number with only very small factors will be nearly identical, while a semiprime may be 3000x faster). <a>Math::Pari</a> is much slower with native sized inputs, probably due to calling overhead. For bigints, the <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> module is needed or performance will be far worse than Math::Pari. With the GMP module, performance is pretty similar from 20 through 70 digits, which the caveat that the current MPU factoring uses more memory for 60+ digit numbers.</p>

<p><a href="http://math.boisestate.edu/~liljanab/BOISECRYPTFall09/Jacobsen.pdf">This slide presentation</a> has a lot of data on 64-bit and GMP factoring performance I collected in 2009. Assuming you do not know anything about the inputs, trial division and optimized Fermat or Lehman work very well for small numbers (&lt;= 10 digits), while native SQUFOF is typically the method of choice for 11-18 digits (I&#39;ve seen claims that a lightweight QS can be faster for 15+ digits). Some form of Quadratic Sieve is usually used for inputs in the 19-100 digit range, and beyond that is the General Number Field Sieve. For serious factoring, I recommend looking at <a href="http://sourceforge.net/projects/yafu/">yafu</a>, <a href="http://sourceforge.net/projects/msieve/">msieve</a>, <a href="http://ecm.gforge.inria.fr/">gmp-ecm</a>, <a href="http://sourceforge.net/projects/ggnfs/">GGNFS</a>, and <a href="http://pari.math.u-bordeaux.fr/">Pari</a>. The latest yafu should cover most uses, with GGNFS likely only providing a benefit for numbers large enough to warrant distributed processing.</p>

<h2 id="PRIMALITY-PROVING">PRIMALITY PROVING</h2>

<p>The <code>n-1</code> proving algorithm in <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> compares well to the version included in Pari. Both are pretty fast to about 60 digits, and work reasonably well to 80 or so before starting to take many minutes per number on a fast computer. Version 0.09 and newer of MPU::GMP contain an ECPP implementation that, while not state of the art compared to closed source solutions, works quite well. It averages less than a second for proving 200-digit primes including creating a certificate. Times below 200 digits are faster than Pari 2.3.5&#39;s APR-CL proof. For larger inputs the bottleneck is a limited set of discriminants, and time becomes more variable. There is a larger set of discriminants on github that help, with 300-digit primes taking ~5 seconds on average and typically under a minute for 500-digits. For primality proving with very large numbers, I recommend <a href="http://www.ellipsa.eu/">Primo</a>.</p>

<h2 id="RANDOM-PRIME-GENERATION">RANDOM PRIME GENERATION</h2>

<p>Seconds per prime for random prime generation on a early 2015 Macbook Pro (2.7 GHz i5) with <a href="../../../lib/Math/BigInt/GMP.html">Math::BigInt::GMP</a> and <a href="../../../lib/Math/Prime/Util/GMP.html">Math::Prime::Util::GMP</a> installed.</p>

<pre><code>  bits    random   +testing   Maurer   Shw-Tylr  CPMaurer
  -----  --------  --------  --------  --------  --------
     64    0.00002 +0.000009   0.00004   0.00004    0.019
    128    0.00008 +0.00014    0.00018   0.00012    0.051
    256    0.0004  +0.0003     0.00085   0.00058    0.13
    512    0.0023  +0.0007     0.0048    0.0030     0.40
   1024    0.019   +0.0033     0.034     0.025      1.78
   2048    0.26    +0.014      0.41      0.25       8.02
   4096    2.82    +0.11       4.4       3.0      66.7
   8192   23.7     +0.65      50.8      38.7     929.4

  random    = random_nbit_prime  (results pass BPSW)
  random+   = additional time for 3 M-R and a Frobenius test
  maurer    = random_maurer_prime
  Shw-Tylr  = random_shawe_taylor_prime
  CPMaurer  = Crypt::Primes::maurer</code></pre>

<p><a href="#random_nbit_prime">&quot;random_nbit_prime&quot;</a> is reasonably fast, and for most purposes should suffice. For cryptographic purposes, one may want additional tests or a proven prime. Additional tests are quite cheap, as shown by the time for three extra M-R and a Frobenius test. At these bit sizes, the chances a composite number passes BPSW, three more M-R tests, and a Frobenius test is <i>extraordinarily</i> small.</p>

<p><a href="#random_proven_prime">&quot;random_proven_prime&quot;</a> provides a randomly selected prime with an optional certificate, without specifying the particular method. With GMP installed this always uses Maurer&#39;s algorithm as it is the best compromise between speed and diversity.</p>

<p><a href="#random_maurer_prime">&quot;random_maurer_prime&quot;</a> constructs a provable prime. A primality test is run on each intermediate, and it also constructs a complete primality certificate which is verified at the end (and can be returned). While the result is uniformly distributed, only about 10% of the primes in the range are selected for output. This is a result of the FastPrime algorithm and is usually unimportant.</p>

<p><a href="#random_shawe_taylor_prime">&quot;random_shawe_taylor_prime&quot;</a> similarly constructs a provable prime. It uses a simpler construction method. It is slightly faster than Maurer&#39;s algorithm but provides less diversity (even fewer primes in the range are selected, though for typical cryptographic sizes this is not important). The Perl implementation uses a single large random seed followed by SHA-256 as specified by FIPS 186-4. The GMP implementation uses the same FIPS 186-4 algorithm but uses its own CSPRNG which may not be SHA-256.</p>

<p><a>&quot;maurer&quot; in Crypt::Primes</a> times are included for comparison. It is reasonably fast for small sizes but gets slow as the size increases. It is 10 to 500 times slower than this module&#39;s GMP methods. It does not perform any primality checks on the intermediate results or the final result (I highly recommended running a primality test on the output). Additionally important for servers, <a>&quot;maurer&quot; in Crypt::Primes</a> uses excessive system entropy and can grind to a halt if <code>/dev/random</code> is exhausted (it can take <b>days</b> to return).</p>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Dana Jacobsen &lt;dana@acm.org&gt;</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>Eratosthenes of Cyrene provided the elegant and simple algorithm for finding primes.</p>

<p>Terje Mathisen, A.R. Quesada, and B. Van Pelt all had useful ideas which I used in my wheel sieve.</p>

<p>The SQUFOF implementation being used is a slight modification to the public domain racing version written by Ben Buhrow. Enhancements with ideas from Ben&#39;s later code as well as Jason Papadopoulos&#39;s public domain implementations are planned for a later version.</p>

<p>The LMO implementation is based on the 2003 preprint from Christian Bau, as well as the 2006 paper from Tom&aacute;s Oliveira e Silva. I also want to thank Kim Walisch for the many discussions about prime counting.</p>

<h1 id="REFERENCES">REFERENCES</h1>

<ul>

<li><p>Christian Axler, &quot;New bounds for the prime counting function &pi;(x)&quot;, September 2014. For large values, improved limits versus Dusart 2010. <a href="http://arxiv.org/abs/1409.1780">http://arxiv.org/abs/1409.1780</a></p>

</li>
<li><p>Christian Axler, &quot;&Uuml;ber die Primzahl-Z&auml;hlfunktion, die n-te Primzahl und verallgemeinerte Ramanujan-Primzahlen&quot;, January 2013. Prime count and nth-prime bounds in more detail. Thesis in German, but first part is easily read. <a href="http://docserv.uni-duesseldorf.de/servlets/DerivateServlet/Derivate-28284/pdfa-1b.pdf">http://docserv.uni-duesseldorf.de/servlets/DerivateServlet/Derivate-28284/pdfa-1b.pdf</a></p>

</li>
<li><p>Christian Bau, &quot;The Extended Meissel-Lehmer Algorithm&quot;, 2003, preprint with example C++ implementation. Very detailed implementation-specific paper which was used for the implementation here. Highly recommended for implementing a sieve-based LMO. <a href="http://cs.swan.ac.uk/~csoliver/ok-sat-library/OKplatform/ExternalSources/sources/NumberTheory/ChristianBau/">http://cs.swan.ac.uk/~csoliver/ok-sat-library/OKplatform/ExternalSources/sources/NumberTheory/ChristianBau/</a></p>

</li>
<li><p>Manuel Benito and Juan L. Varona, &quot;Recursive formulas related to the summation of the M&ouml;bius function&quot;, <i>The Open Mathematics Journal</i>, v1, pp 25-34, 2007. Among many other things, shows a simple formula for computing the Mertens functions with only n/3 M&ouml;bius values (not as fast as Del&eacute;glise and Rivat, but really simple). <a href="http://www.unirioja.es/cu/jvarona/downloads/Benito-Varona-TOMATJ-Mertens.pdf">http://www.unirioja.es/cu/jvarona/downloads/Benito-Varona-TOMATJ-Mertens.pdf</a></p>

</li>
<li><p>John Brillhart, D. H. Lehmer, and J. L. Selfridge, &quot;New Primality Criteria and Factorizations of 2^m +/- 1&quot;, Mathematics of Computation, v29, n130, Apr 1975, pp 620-647. <a href="http://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf">http://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf</a></p>

</li>
<li><p>W. J. Cody and Henry C. Thacher, Jr., &quot;Rational Chebyshev Approximations for the Exponential Integral E_1(x)&quot;, <i>Mathematics of Computation</i>, v22, pp 641-649, 1968.</p>

</li>
<li><p>W. J. Cody and Henry C. Thacher, Jr., &quot;Chebyshev approximations for the exponential integral Ei(x)&quot;, <i>Mathematics of Computation</i>, v23, pp 289-303, 1969. <a href="http://www.ams.org/journals/mcom/1969-23-106/S0025-5718-1969-0242349-2/">http://www.ams.org/journals/mcom/1969-23-106/S0025-5718-1969-0242349-2/</a></p>

</li>
<li><p>W. J. Cody, K. E. Hillstrom, and Henry C. Thacher Jr., &quot;Chebyshev Approximations for the Riemann Zeta Function&quot;, <a href="#Mathematics-of-Computation">&quot;Mathematics of Computation&quot;</a>, v25, n115, pp 537-547, July 1971.</p>

</li>
<li><p>Henri Cohen, &quot;A Course in Computational Algebraic Number Theory&quot;, Springer, 1996. Practical computational number theory from the team lead of <a href="http://pari.math.u-bordeaux.fr/">Pari</a>. Lots of explicit algorithms.</p>

</li>
<li><p>Marc Del&eacute;glise and Jo&ouml;l Rivat, &quot;Computing the summation of the M&ouml;bius function&quot;, <i>Experimental Mathematics</i>, v5, n4, pp 291-295, 1996. Enhances the M&ouml;bius computation in Lioen/van de Lune, and gives a very efficient way to compute the Mertens function. <a href="http://projecteuclid.org/euclid.em/1047565447">http://projecteuclid.org/euclid.em/1047565447</a></p>

</li>
<li><p>Pierre Dusart, &quot;Autour de la fonction qui compte le nombre de nombres premiers&quot;, PhD thesis, 1998. In French. The mathematics is readable and highly recommended reading if you&#39;re interested in prime number bounds. <a href="http://www.unilim.fr/laco/theses/1998/T1998_01.html">http://www.unilim.fr/laco/theses/1998/T1998_01.html</a></p>

</li>
<li><p>Pierre Dusart, &quot;Estimates of Some Functions Over Primes without R.H.&quot;, preprint, 2010. Updates to the best non-RH bounds for prime count and nth prime. <a href="http://arxiv.org/abs/1002.0442/">http://arxiv.org/abs/1002.0442/</a></p>

</li>
<li><p>Pierre-Alain Fouque and Mehdi Tibouchi, &quot;Close to Uniform Prime Number Generation With Fewer Random Bits&quot;, pre-print, 2011. Describes random prime distributions, their algorithm for creating random primes using few random bits, and comparisons to other methods. Definitely worth reading for the discussions of uniformity. <a href="http://eprint.iacr.org/2011/481">http://eprint.iacr.org/2011/481</a></p>

</li>
<li><p>Walter M. Lioen and Jan van de Lune, &quot;Systematic Computations on Mertens&#39; Conjecture and Dirichlet&#39;s Divisor Problem by Vectorized Sieving&quot;, in <i>From Universal Morphisms to Megabytes</i>, Centrum voor Wiskunde en Informatica, pp. 421-432, 1994. Describes a nice way to compute a range of M&ouml;bius values. <a href="http://walter.lioen.com/papers/LL94.pdf">http://walter.lioen.com/papers/LL94.pdf</a></p>

</li>
<li><p>Ueli M. Maurer, &quot;Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters&quot;, 1995. Generating random provable primes by building up the prime. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.2151">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.2151</a></p>

</li>
<li><p>Gabriel Mincu, &quot;An Asymptotic Expansion&quot;, <i>Journal of Inequalities in Pure and Applied Mathematics</i>, v4, n2, 2003. A very readable account of Cipolla&#39;s 1902 nth prime approximation. <a href="http://www.emis.de/journals/JIPAM/images/153_02_JIPAM/153_02.pdf">http://www.emis.de/journals/JIPAM/images/153_02_JIPAM/153_02.pdf</a></p>

</li>
<li><p><a href="http://oeis.org/wiki/Primorial">OEIS: Primorial</a></p>

</li>
<li><p>Vincent Pegoraro and Philipp Slusallek, &quot;On the Evaluation of the Complex-Valued Exponential Integral&quot;, <i>Journal of Graphics, GPU, and Game Tools</i>, v15, n3, pp 183-198, 2011. <a href="http://www.cs.utah.edu/~vpegorar/research/2011_JGT/paper.pdf">http://www.cs.utah.edu/~vpegorar/research/2011_JGT/paper.pdf</a></p>

</li>
<li><p>William H. Press et al., &quot;Numerical Recipes&quot;, 3rd edition.</p>

</li>
<li><p>Hans Riesel, &quot;Prime Numbers and Computer Methods for Factorization&quot;, Birkh?user, 2nd edition, 1994. Lots of information, some code, easy to follow.</p>

</li>
<li><p>David M. Smith, &quot;Multiple-Precision Exponential Integral and Related Functions&quot;, <i>ACM Transactions on Mathematical Software</i>, v37, n4, 2011. <a href="http://myweb.lmu.edu/dmsmith/toms2011.pdf">http://myweb.lmu.edu/dmsmith/toms2011.pdf</a></p>

</li>
<li><p>Douglas A. Stoll and Patrick Demichel , &quot;The impact of &zeta;(s) complex zeros on &pi;(x) for x &lt; 10^{10^{13}}&quot;, <a href="#Mathematics-of-Computation">&quot;Mathematics of Computation&quot;</a>, v80, n276, pp 2381-2394, October 2011. <a href="http://www.ams.org/journals/mcom/2011-80-276/S0025-5718-2011-02477-4/home.html">http://www.ams.org/journals/mcom/2011-80-276/S0025-5718-2011-02477-4/home.html</a></p>

</li>
</ul>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2011-2017 by Dana Jacobsen &lt;dana@acm.org&gt;</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


