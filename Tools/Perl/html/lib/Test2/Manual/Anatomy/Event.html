<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#HISTORY">HISTORY</a></li>
  <li><a href="#THE-EVENT-OBJECT">THE EVENT OBJECT</a></li>
  <li><a href="#THE-FACET-API">THE FACET API</a>
    <ul>
      <li><a href="#CUSTOM-FACETS">CUSTOM FACETS</a>
        <ul>
          <li><a href="#EXAMPLES">EXAMPLES</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#THE-OLD-API">THE OLD API</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#SOURCE">SOURCE</a></li>
  <li><a href="#MAINTAINERS">MAINTAINERS</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Test2::Manual::Anatomy::Event - The internals of events</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Events are how tools effect global state, and pass information along to the harness, or the human running the tests.</p>

<h1 id="HISTORY">HISTORY</h1>

<p>Before proceeding it is important that you know some history of events. Initially there was an event API, and an event would implement the API to produce an effect. This API proved to be lossy and inflexible. Recently the &#39;facet&#39; system was introduced, and makes up for the shortcoming and inflexibility of the old API.</p>

<p>All events must still implement the old API, but that can be largely automated if you use the facet system effectively. Likewise essential facets can often be deduced from events that only implement the old API, though their information maybe less complete.</p>

<h1 id="THE-EVENT-OBJECT">THE EVENT OBJECT</h1>

<p>All event objects must subclass <a href="../../../../lib/Test2/Event.html">Test2::Event</a>. If you inherit from this base class, and implement the old API properly, facets will be generated for you for free. On the other hand you can inherit from this, and also import <a>Test2::Util::Facets2Legacy</a> which will instead rely on your facet data, and deduce the old API from them.</p>

<p>All new events <code>MUST</code> implement both APIs one way or the other. A common way to do this is to simply implement both APIs directly in your event.</p>

<p>Here is a good template for a new event:</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">Test2::Event::Mine</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">parent</span> <span class="string">'Test2::Event'</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Test2::Util::Facets2Legacy</span> <span class="string">':ALL'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> facet_data </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    
        <span class="comment"># Adds 'about', 'amnesty', and 'trace' facets</span>
        <span class="keyword">my</span> <span class="variable">$out</span> <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="variable">common_facet_data</span><span class="operator">;</span>
    
        <span class="comment"># Add any additional facets to the $out hashref</span>
        <span class="operator">...</span>
    
        <span class="keyword">return</span> <span class="variable">$out</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="number">1</span><span class="operator">;</span>
</code></pre>

<h1 id="THE-FACET-API">THE FACET API</h1>

<p>The new API is a single method: <code>facet_data()</code>. This method must return a hashref where each key is specific to a facet type, and the value is either a facet hashref, or an array of hashrefs. Some facets <code>MUST</code> be lone hashrefs, others <code>MUST</code> be hashrefs inside an arrayref.</p>

<p>The <i>standard</i> facet types are as follows:</p>

<dl>

<dt id="assert-details-name-pass-bool-no_debug-bool-number-maybe_int">assert =&gt; {details =&gt; $name, pass =&gt; $bool, no_debug =&gt; $bool, number =&gt; $maybe_int}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Assert.html">Test2::EventFacet::Assert</a>. An event may only have one.</p>

<p>The &#39;details&#39; key is the name of the assertion.</p>

<p>The &#39;pass&#39; key denotes a passing or failing assertion.</p>

<p>The &#39;no_debug&#39; key tells any harness or formatter that diagnostics should not be added automatically to a failing assertion (used when there are custom diagnostics instead).</p>

<p>The &#39;number&#39; key is for harness use, never set it yourself.</p>

</dd>
<dt id="about-details-string-no_display-bool-package-pkg">about =&gt; {details =&gt; $string, no_display =&gt; $bool, package =&gt; $pkg}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/About.html">Test2::EventFacet::About</a>. An event may only have one.</p>

<p>&#39;details&#39; is a human readable string describing the overall event.</p>

<p>&#39;no_display&#39; means that a formatter/harness should hide the event.</p>

<p>&#39;package&#39; is the package of the event the facet describes (IE: <a href="../../../../lib/Test2/Event/Ok.html">Test2::Event::Ok</a>)</p>

</dd>
<dt id="amnesty-details-string-tag-short_string-inherited-bool">amnesty =&gt; [{details =&gt; $string, tag =&gt; $short_string, inherited =&gt; $bool}]</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Amnesty.html">Test2::EventFacet::Amnesty</a>. An event may have multiple.</p>

<p>This event is how things like &#39;todo&#39; are implemented. Amnesty prevents a failing assertion from causing a global test failure.</p>

<p>&#39;details&#39; is a human readable description of why the failure is being granted amnesty (IE The &#39;todo&#39; reason)</p>

<p>&#39;tag&#39; is a short human readable string, or category for the amnesty. This is typically &#39;TODO&#39; or &#39;SKIP&#39;.</p>

<p>&#39;inherited&#39; is true if the amnesty was applied in a parent context (true if this test is run in a subtest that is marked todo).</p>

</dd>
<dt id="control-details-string-global-bool-terminate-maybe_int-halt-bool-has_callback-bool-encoding-enc">control =&gt; {details =&gt; $string, global =&gt; $bool, terminate =&gt; $maybe_int, halt =&gt; $bool, has_callback =&gt; $bool, encoding =&gt; $enc}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Control.html">Test2::EventFacet::Control</a>. An event may have one.</p>

<p>This facet is used to apply extra behavior when the event is processed.</p>

<p>&#39;details&#39; is a human readable explanation for the behavior.</p>

<p>&#39;global&#39; true if this event should be forwarded to, and processed by, all hubs everywhere. (bail-out uses this)</p>

<p>&#39;terminate&#39; this should either be undef, or an integer. When defined this will cause the test to exit with the specific exit code.</p>

<p>&#39;halt&#39; is used to signal any harness that no further test files should be run (bail-out uses this).</p>

<p>&#39;has_callback&#39; is set to true if the event has a callback sub defined.</p>

<p>&#39;encoding&#39; used to tell the formatter what encoding to use.</p>

</dd>
<dt id="errors-details-string-tag-short_string-fail-bool">errors =&gt; [{details =&gt; $string, tag =&gt; $short_string, fail =&gt; $bool}]</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Error.html">Test2::EventFacet::Error</a>. An event may have multiple.</p>

<p>&#39;details&#39; is a human readable explanation of the error.</p>

<p>&#39;tag&#39; is a short human readable category for the error.</p>

<p>&#39;fail&#39; is true if the error should cause test failure. If this is false the error is simply informative, but not fatal.</p>

</dd>
<dt id="info-details-string-tag-short_string-debug-bool-important-bool">info =&gt; [{details =&gt; $string, tag =&gt; $short_string, debug =&gt; $bool, important =&gt; $bool}]</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Info.html">Test2::EventFacet::Info</a>. An event may have multiple.</p>

<p>This is how diag and note are implemented.</p>

<p>&#39;details&#39; human readable message.</p>

<p>&#39;tag&#39; short category for the message, such as &#39;diag&#39; or &#39;note&#39;.</p>

<p>&#39;debug&#39; is true if the message is diagnostics in nature, this is the main difference between a note and a diag.</p>

<p>&#39;important&#39; is true if the message is not diagnostics, but is important to have it shown anyway. This is primarily used to communicate with a harness.</p>

</dd>
<dt id="parent-details-string-hid-hid-children-...-buffered-1">parent =&gt; {details =&gt; $string, hid =&gt; $hid, children =&gt; [...], buffered =&gt; 1}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Parent.html">Test2::EventFacet::Parent</a>. An event may have one.</p>

<p>This is used by subtests.</p>

<p>&#39;details&#39; human readable name of the subtest.</p>

<p>&#39;hid&#39; subtest hub id.</p>

<p>&#39;children&#39; an arrayref containing facet_data instances from all child events.</p>

<p>&#39;buffered&#39; true if it was a buffered subtest.</p>

</dd>
<dt id="plan-details-string-count-int-skip-bool-none-bool">plan =&gt; {details =&gt; $string, count =&gt; $int, skip =&gt; $bool, none =&gt; $bool}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Plan.html">Test2::EventFacet::Plan</a>. An event may have one.</p>

<p>&#39;details&#39; is a human readable string describing the plan (for instance, why a test is skipped)</p>

<p>&#39;count&#39; is the number of expected assertions (0 for skip)</p>

<p>&#39;skip&#39; is true if the plan is to skip the test.</p>

<p>&#39;none&#39; used for Test::More&#39;s &#39;no_plan&#39; plan.</p>

</dd>
<dt id="trace-details-string-frame-pkg-file-line-sub-pid-int-tid-int-cid-cid-hid-hid-nested-int-buffered-bool">trace =&gt; {details =&gt; $string, frame =&gt; [$pkg, $file, $line, $sub], pid =&gt; $int, tid =&gt; $int, cid =&gt; $cid, hid =&gt; $hid, nested =&gt; $int, buffered =&gt; $bool}</dt>
<dd>

<p>Documented in <a href="../../../../lib/Test2/EventFacet/Trace.html">Test2::EventFacet::Trace</a>. An event may have one.</p>

<p>This is how debugging information is tracked. This is taken from the context object at event creation.</p>

<p>&#39;details&#39; human readable debug message (otherwise generated from frame)</p>

<p>&#39;frame&#39; first 4 fields returned by caller: <code>[$package, $file, $line, $subname]</code>.</p>

<p>&#39;pid&#39; the process id in which the event was created.</p>

<p>&#39;tid&#39; the thread is in which the event was created.</p>

<p>&#39;cid&#39; the id of the context used to create the event.</p>

<p>&#39;hid&#39; the id of the hub to which the event was sent.</p>

<p>&#39;nest&#39; subtest nesting depth of the event.</p>

<p>&#39;buffered&#39; is true if the event was generated inside a buffered subtest.</p>

</dd>
</dl>

<p>Note that ALL facet types have a &#39;details&#39; key that may have a string. This string should always be human readable, and should be an explanation for the facet. For an assertion this is the test name. For a plan this is the reason for the plan (such as skip reason). For info it is the human readable diagnostics message.</p>

<h2 id="CUSTOM-FACETS">CUSTOM FACETS</h2>

<p>You can write custom facet types as well, simply add a new key to the hash and populated it. The general rule is that any code looking at the facets should ignore any it does not understand.</p>

<p>Optionally you can also create a package to document your custom facet. The package should be proper object, and may have additional methods to help work with your facet.</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">Test2::EventFacet::MyFacet</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">parent</span> <span class="string">'Test2::EventFacet'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> facet_key </span><span class="operator">{</span> <span class="string">'myfacet'</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> is_list </span><span class="operator">{</span> <span class="number">0</span> <span class="operator">}</span>
    
    <span class="number">1</span><span class="operator">;</span>
</code></pre>

<p>Your facet package should always be under the Test2::EventFacet:: namespace if you want any tools to automatically find it. The last part of the namespace should be the non-plural name of your facet with only the first word capitalized.</p>

<dl>

<dt id="string-facet_class-facet_key">$string = $facet_class-&gt;facet_key</dt>
<dd>

<p>The key for your facet should be the same as the last section of the namespace, but all lowercase. You <i>may</i> append &#39;s&#39; to the key if your facet is a list type.</p>

</dd>
<dt id="bool-facet_class-is_list">$bool = $facet_class-&gt;is_list</dt>
<dd>

<p>True if an event should put these facets in a list:</p>

<pre><code>    <span class="operator">{</span> <span class="string">myfacet</span> <span class="operator">=&gt;</span> <span class="operator">[{}</span><span class="operator">,</span> <span class="operator">{}]</span> <span class="operator">}</span>
</code></pre>

<p>False if an event may only have one of this type of facet at a time:</p>

<pre><code>    <span class="operator">{</span> <span class="string">myfacet</span> <span class="operator">=&gt;</span> <span class="operator">{}</span> <span class="operator">}</span>
</code></pre>

</dd>
</dl>

<h3 id="EXAMPLES">EXAMPLES</h3>

<p>The assert facet is not a list type, so its implementation would look like this:</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">Test2::EventFacet::Assert</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> facet_key </span><span class="operator">{</span> <span class="string">'assert'</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> is_list </span><span class="operator">{</span> <span class="number">0</span> <span class="operator">}</span>
</code></pre>

<p>The amnesty facet is a list type, but amnesty does not need &#39;s&#39; appended to make it plural:</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">Test2::EventFacet::Amnesty</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> facet_key </span><span class="operator">{</span> <span class="string">'amnesty'</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> is_list </span><span class="operator">{</span> <span class="number">1</span> <span class="operator">}</span>
</code></pre>

<p>The error facet is a list type, and appending &#39;s&#39; makes error plural as errors. This means the package name is &#39;::Error&#39;, but the key is &#39;errors&#39;.</p>

<pre><code>    <span class="keyword">package</span> <span class="variable">Test2::EventFacet::Error</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> facet_key </span><span class="operator">{</span> <span class="string">'errors'</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> is_list </span><span class="operator">{</span> <span class="number">1</span> <span class="operator">}</span>
</code></pre>

<p><b>Note</b> Do not worry too much about getting the key/pluralization wrong. Most tools will use <a href="../../../../lib/Module/Pluggable.html">Module::Pluggable</a> to load all facet types and build a hash linking keys to packages and so on, working backwards. This means, in general, that even if you get it wrong any tool that NEEDS the package for the facet will find it.</p>

<p><b>Note2:</b> In practice most tools completely ignore the facet packages, and work with the facet data directly in its raw structure. This is by design and recommended. The facet data is intended to be serialized frequently and passed around. When facets are concerned, data is important, classes and methods are not.</p>

<h1 id="THE-OLD-API">THE OLD API</h1>

<p>The old API was simply a set of methods you were required to implement:</p>

<dl>

<dt id="bool-e-causes_fail">$bool = $e-&gt;causes_fail</dt>
<dd>

<p>Returns true if this event should result in a test failure. In general this should be false.</p>

</dd>
<dt id="bool-e-increments_count">$bool = $e-&gt;increments_count</dt>
<dd>

<p>Should be true if this event should result in a test count increment.</p>

</dd>
<dt id="e-callback-hub">$e-&gt;callback($hub)</dt>
<dd>

<p>If your event needs to have extra effects on the <a href="../../../../lib/Test2/Hub.html">Test2::Hub</a> you can override this method.</p>

<p>This is called <b>BEFORE</b> your event is passed to the formatter.</p>

</dd>
<dt id="num-e-nested">$num = $e-&gt;nested</dt>
<dd>

<p>If this event is nested inside of other events, this should be the depth of nesting. (This is mainly for subtests)</p>

</dd>
<dt id="bool-e-global">$bool = $e-&gt;global</dt>
<dd>

<p>Set this to true if your event is global, that is ALL threads and processes should see it no matter when or where it is generated. This is not a common thing to want, it is used by bail-out and skip_all to end testing.</p>

</dd>
<dt id="code-e-terminate">$code = $e-&gt;terminate</dt>
<dd>

<p>This is called <b>AFTER</b> your event has been passed to the formatter. This should normally return undef, only change this if your event should cause the test to exit immediately.</p>

<p>If you want this event to cause the test to exit you should return the exit code here. Exit code of 0 means exit success, any other integer means exit with failure.</p>

<p>This is used by <a href="../../../../lib/Test2/Event/Plan.html">Test2::Event::Plan</a> to exit 0 when the plan is &#39;skip_all&#39;. This is also used by <a>Test2::Event:Bail</a> to force the test to exit with a failure.</p>

<p>This is called after the event has been sent to the formatter in order to ensure the event is seen and understood.</p>

</dd>
<dt id="msg-e-summary">$msg = $e-&gt;summary</dt>
<dd>

<p>This is intended to be a human readable summary of the event. This should ideally only be one line long, but you can use multiple lines if necessary. This is intended for human consumption. You do not need to make it easy for machines to understand.</p>

<p>The default is to simply return the event package name.</p>

</dd>
<dt id="count-directive-reason-e-sets_plan">($count, $directive, $reason) = $e-&gt;sets_plan()</dt>
<dd>

<p>Check if this event sets the testing plan. It will return an empty list if it does not. If it does set the plan it will return a list of 1 to 3 items in order: Expected Test Count, Test Directive, Reason for directive.</p>

</dd>
<dt id="bool-e-diagnostics">$bool = $e-&gt;diagnostics</dt>
<dd>

<p>True if the event contains diagnostics info. This is useful because a non-verbose harness may choose to hide events that are not in this category. Some formatters may choose to send these to STDERR instead of STDOUT to ensure they are seen.</p>

</dd>
<dt id="bool-e-no_display">$bool = $e-&gt;no_display</dt>
<dd>

<p>False by default. This will return true on events that should not be displayed by formatters.</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../../../lib/Test2/Manual.html">Test2::Manual</a> - Primary index of the manual.</p>

<h1 id="SOURCE">SOURCE</h1>

<p>The source code repository for Test2-Manual can be found at <i>http://github.com/Test-More/Test2-Manual/</i>.</p>

<h1 id="MAINTAINERS">MAINTAINERS</h1>

<dl>

<dt id="Chad-Granum-exodist-cpan.org">Chad Granum &lt;exodist@cpan.org&gt;</dt>
<dd>

</dd>
</dl>

<h1 id="AUTHORS">AUTHORS</h1>

<dl>

<dt id="Chad-Granum-exodist-cpan.org1">Chad Granum &lt;exodist@cpan.org&gt;</dt>
<dd>

</dd>
</dl>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2017 Chad Granum &lt;exodist@cpan.org&gt;.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>See <i>http://dev.perl.org/licenses/</i></p>


</body>

</html>


