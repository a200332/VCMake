<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#CLASS-METHODS">CLASS METHODS</a>
    <ul>
      <li><a href="#new">new</a>
        <ul>
          <li><a href="#refuse_snappy">refuse_snappy</a></li>
          <li><a href="#refuse_objects">refuse_objects</a></li>
          <li><a href="#no_bless_objects">no_bless_objects</a></li>
          <li><a href="#validate_utf8">validate_utf8</a></li>
          <li><a href="#max_recursion_depth">max_recursion_depth</a></li>
          <li><a href="#max_num_hash_entries">max_num_hash_entries</a></li>
          <li><a href="#incremental">incremental</a></li>
          <li><a href="#alias_smallint">alias_smallint</a></li>
          <li><a href="#alias_varint_under">alias_varint_under</a></li>
          <li><a href="#use_undef">use_undef</a></li>
          <li><a href="#set_readonly">set_readonly</a></li>
          <li><a href="#set_readonly_scalars">set_readonly_scalars</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#INSTANCE-METHODS">INSTANCE METHODS</a>
    <ul>
      <li><a href="#decode">decode</a></li>
      <li><a href="#decode_with_header">decode_with_header</a></li>
      <li><a href="#decode_only_header">decode_only_header</a></li>
      <li><a href="#decode_with_offset">decode_with_offset</a></li>
      <li><a href="#decode_only_header_with_offset">decode_only_header_with_offset</a></li>
      <li><a href="#decode_with_header_and_offset">decode_with_header_and_offset</a></li>
      <li><a href="#bytes_consumed">bytes_consumed</a></li>
      <li><a href="#looks_like_sereal">looks_like_sereal</a></li>
    </ul>
  </li>
  <li><a href="#EXPORTABLE-FUNCTIONS">EXPORTABLE FUNCTIONS</a>
    <ul>
      <li><a href="#sereal_decode_with_object">sereal_decode_with_object</a></li>
      <li><a href="#sereal_decode_with_header_with_object">sereal_decode_with_header_with_object</a></li>
      <li><a href="#sereal_decode_only_header_with_object">sereal_decode_only_header_with_object</a></li>
      <li><a href="#sereal_decode_only_header_with_offset_with_object">sereal_decode_only_header_with_offset_with_object</a></li>
      <li><a href="#sereal_decode_with_header_and_offset_with_object">sereal_decode_with_header_and_offset_with_object</a></li>
      <li><a href="#sereal_decode_with_offset_with_object">sereal_decode_with_offset_with_object</a></li>
      <li><a href="#decode_sereal">decode_sereal</a></li>
      <li><a href="#decode_sereal_with_header_data">decode_sereal_with_header_data</a></li>
      <li><a href="#scalar_looks_like_sereal">scalar_looks_like_sereal</a></li>
    </ul>
  </li>
  <li><a href="#ROBUSTNESS">ROBUSTNESS</a></li>
  <li><a href="#PERFORMANCE">PERFORMANCE</a></li>
  <li><a href="#THREAD-SAFETY">THREAD-SAFETY</a></li>
  <li><a href="#BUGS-CONTACT-AND-SUPPORT">BUGS, CONTACT AND SUPPORT</a></li>
  <li><a href="#AUTHORS-AND-CONTRIBUTORS">AUTHORS AND CONTRIBUTORS</a></li>
  <li><a href="#ACKNOWLEDGMENT">ACKNOWLEDGMENT</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Sereal::Decoder - Fast, compact, powerful binary deserialization</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  <span class="keyword">use</span> <span class="variable">Sereal::Decoder</span>
    <span class="string">qw(decode_sereal sereal_decode_with_object scalar_looks_like_sereal)</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$decoder</span> <span class="operator">=</span> <span class="variable">Sereal::Decoder</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="operator">{</span><span class="operator">...</span><span class="variable">options</span><span class="operator">...</span><span class="operator">}</span><span class="operator">);</span>
  
  <span class="keyword">my</span> <span class="variable">$structure</span><span class="operator">;</span>
  <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode</span><span class="operator">(</span><span class="variable">$blob</span><span class="operator">,</span> <span class="variable">$structure</span><span class="operator">);</span> <span class="comment"># deserializes into $structure</span>
  
  <span class="comment"># or if you don't have references to the top level structure, this works, too:</span>
  <span class="variable">$structure</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode</span><span class="operator">(</span><span class="variable">$blob</span><span class="operator">);</span>
  
  <span class="comment"># alternatively functional interface: (See Sereal::Performance)</span>
  <span class="variable">sereal_decode_with_object</span><span class="operator">(</span><span class="variable">$decoder</span><span class="operator">,</span> <span class="variable">$blob</span><span class="operator">,</span> <span class="variable">$structure</span><span class="operator">);</span>
  <span class="variable">$structure</span> <span class="operator">=</span> <span class="variable">sereal_decode_with_object</span><span class="operator">(</span><span class="variable">$decoder</span><span class="operator">,</span> <span class="variable">$blob</span><span class="operator">);</span>
  
  <span class="comment"># much slower functional interface with no persistent objects:</span>
  <span class="variable">decode_sereal</span><span class="operator">(</span><span class="variable">$blob</span><span class="operator">,</span> <span class="operator">{</span><span class="operator">...</span> <span class="variable">options</span> <span class="operator">...</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">$structure</span><span class="operator">);</span>
  <span class="variable">$structure</span> <span class="operator">=</span> <span class="variable">decode_sereal</span><span class="operator">(</span><span class="variable">$blob</span><span class="operator">,</span> <span class="operator">{</span><span class="operator">...</span> <span class="variable">options</span> <span class="operator">...</span><span class="operator">}</span><span class="operator">);</span>
  
  <span class="comment"># Not a full validation, but just a quick check for a reasonable header:</span>
  <span class="keyword">my</span> <span class="variable">$is_likely_sereal</span> <span class="operator">=</span> <span class="variable">scalar_looks_like_sereal</span><span class="operator">(</span><span class="variable">$some_string</span><span class="operator">);</span>
  <span class="comment"># or:</span>
  <span class="variable">$is_likely_sereal</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">looks_like_sereal</span><span class="operator">(</span><span class="variable">$some_string</span><span class="operator">);</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This library implements a deserializer for an efficient, compact-output, and feature-rich binary protocol called <i>Sereal</i>. Its sister module <a href="../../lib/Sereal/Encoder.html">Sereal::Encoder</a> implements an encoder for this format. The two are released separately to allow for independent and safer upgrading.</p>

<p>The Sereal protocol versions that are compatible with this decoder implementation are currently protocol versions 1, 2, 3 and 4. As it stands, it will refuse to attempt to decode future versions of the protocol, but if necessary there is likely going to be an option to decode the parts of the input that are compatible with version 4 of the protocol. The protocol was designed to allow for this.</p>

<p>The protocol specification and many other bits of documentation can be found in the github repository. Right now, the specification is at <a href="https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod">https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod</a>, there is a discussion of the design objectives in <a href="https://github.com/Sereal/Sereal/blob/master/README.pod">https://github.com/Sereal/Sereal/blob/master/README.pod</a>, and the output of our benchmarks can be seen at <a href="https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs">https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs</a>.</p>

<h1 id="CLASS-METHODS">CLASS METHODS</h1>

<h2 id="new">new</h2>

<p>Constructor. Optionally takes a hash reference as first parameter. This hash reference may contain any number of options that influence the behaviour of the encoder.</p>

<p>Currently, the following options are recognized, none of them are on by default.</p>

<h3 id="refuse_snappy">refuse_snappy</h3>

<p>If set, the decoder will refuse Snappy-compressed input data. This can be desirable for robustness. See the section <code>ROBUSTNESS</code> below.</p>

<h3 id="refuse_objects">refuse_objects</h3>

<p>If set, the decoder will refuse deserializing any objects in the input stream and instead throw an exception. Defaults to off. See the section <code>ROBUSTNESS</code> below.</p>

<h3 id="no_bless_objects">no_bless_objects</h3>

<p>If set, the decoder will deserialize any objects in the input stream but without blessing them. Defaults to off. See the section <code>ROBUSTNESS</code> below.</p>

<h3 id="validate_utf8">validate_utf8</h3>

<p>If set, the decoder will refuse invalid UTF-8 byte sequences. This is off by default, but it&#39;s strongly encouraged to be turned on if you&#39;re dealing with any data that has been encoded by an external source (e.g. http cookies).</p>

<h3 id="max_recursion_depth">max_recursion_depth</h3>

<p><code>Sereal::Decoder</code> is recursive. If you pass it a Sereal document that is deeply nested, it will eventually exhaust the C stack. Therefore, there is a limit on the depth of recursion that is accepted. It defaults to 10000 nested calls. You may choose to override this value with the <code>max_recursion_depth</code> option. Beware that setting it too high can cause hard crashes.</p>

<p>Do note that the setting is somewhat approximate. Setting it to 10000 may break at somewhere between 9997 and 10003 nested structures depending on their types.</p>

<h3 id="max_num_hash_entries">max_num_hash_entries</h3>

<p>If set to a non-zero value (default: 0), then <code>Sereal::Decoder</code> will refuse to deserialize any hash/dictionary (or hash-based object) with more than that number of entries. This is to be able to respond quickly to any future hash-collision attacks on Perl&#39;s hash function. Chances are, you don&#39;t want or need this. For a gentle introduction to the topic from the cryptographic point of view, see <a href="http://en.wikipedia.org/wiki/Collision_attack">http://en.wikipedia.org/wiki/Collision_attack</a>.</p>

<h3 id="incremental">incremental</h3>

<p>If set to a non-zero value (default: 0), then <code>Sereal::Decoder</code> will destructively parse Sereal documents out of a variable. Every time a Sereal document is successfully parsed it is removed from the front of the string it is parsed from.</p>

<p>This means you can do this:</p>

<pre><code>    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">length</span> <span class="variable">$buffer</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$data</span><span class="operator">=</span> <span class="variable">decode_sereal</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">,</span><span class="operator">{</span><span class="string">incremental</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
    <span class="operator">}</span>
</code></pre>

<h3 id="alias_smallint">alias_smallint</h3>

<p>If set to a true value then <code>Sereal::Decoder</code> will share integers from -16 to 15 (encoded as either SRL_HDR_NEG and SRL_HDR_POS) as read-only aliases to a common SV.</p>

<p>The result of this may be significant space savings in data structures with many integers in the specified range. The cost is more memory used by the decoder and a very modest speed penalty when deserializing.</p>

<p>Note this option changes the structure of the dumped data. Use with caution.</p>

<p>See also the &quot;alias_varint_under&quot; option.</p>

<h3 id="alias_varint_under">alias_varint_under</h3>

<p>If set to a true positive integer smaller than 16 then this option is similar to setting &quot;alias_smallint&quot; and causes all integers from -16 to 15 to be shared as read-only aliases to the same SV, except that this treatment ALSO applies to SRL_HDR_VARINT. If set to a value larger than 16 then this applies to all varints varints under the value set. (In general SRL_HDR_VARINT is used only for integers larger than 15, and SRL_HDR_NEG and SRL_HDR_POS are used for -16 to -1 and 0 to 15 respectively.)</p>

<p>In simple terms if you want to share values larger than 16 then you should use this option, if you want to share only values in the -16 to 15 range then you should use the &quot;alias_smallint&quot; option instead.</p>

<p>The result of this may be significant space savings in data structures with many integers in the desire range. The cost is more memory used by the decoder and a very modest speed penalty when deserializing.</p>

<p>Note this option changes the structure of the dumped data. Use with caution.</p>

<h3 id="use_undef">use_undef</h3>

<p>If set to a true value then this any undef value to be deserialized as PL_sv_undef. This may change the structure of the data structure being dumped, do not enable this unless you know what you are doing.</p>

<h3 id="set_readonly">set_readonly</h3>

<p>If set to a true value then the output will be completely readonly (deeply).</p>

<h3 id="set_readonly_scalars">set_readonly_scalars</h3>

<p>If set to a true value then scalars in the output will be readonly (deeply). References won&#39;t be readonly.</p>

<h1 id="INSTANCE-METHODS">INSTANCE METHODS</h1>

<h2 id="decode">decode</h2>

<p>Given a byte string of Sereal data, the <code>decode</code> call deserializes that data structure. The result can be obtained in one of two ways: <code>decode</code> accepts a second parameter, which is a scalar to write the result to, AND <code>decode</code> will return the resulting data structure.</p>

<p>The two are subtly different in case of data structures that contain references to the root element. In that case, the return value will be a (non-recursive) copy of the reference. The pass-in style is more correct. In other words,</p>

<pre><code>  <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">,</span> <span class="keyword">my</span> <span class="variable">$out</span><span class="operator">);</span>
  <span class="comment"># is almost the same but safer than:</span>
  <span class="keyword">my</span> <span class="variable">$out</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">);</span>
</code></pre>

<p>This is an unfortunate side-effect of perls standard copy semantics of assignment. Possibly one day we will have an alternative to this.</p>

<h2 id="decode_with_header">decode_with_header</h2>

<p>Given a byte string of Sereal data, the <code>decode_with_header</code> call deserializes that data structure as <code>decode</code> would do, however it also decodes the optional user data structure that can be embedded into a Sereal document, inside the header (see <a>Sereal::Encoder::encode</a>).</p>

<p>It accepts an optional second parameter, which is a scalar to write the body to, and an optional third parameter, which is a scalar to write the header to.</p>

<p>Regardless of the number of parameters received, <code>decode_with_header</code> returns an ArrayRef containing the deserialized header, and the deserialized body, in this order.</p>

<p>See <code>decode</code> for the subtle difference between the one, two and three parameters versions.</p>

<p>If there is no header in a Sereal document, corresponding variable or return value will be set to undef.</p>

<h2 id="decode_only_header">decode_only_header</h2>

<p>Given a byte string of Sereal data, the <code>decode_only_header</code> deserializes only the optional user data structure that can be embedded into a Sereal document, inside the header (see <a>Sereal::Encoder::encode</a>).</p>

<p>It accepts an optional second parameter, which is a scalar to write the header to.</p>

<p>Regardless of the number of parameters received, <code>decode_only_header</code> returns the resulting data structure.</p>

<p>See <code>decode</code> for the subtle difference between the one and two parameters versions.</p>

<p>If there is no header in a Sereal document, corresponding variable or return value will be set to undef.</p>

<h2 id="decode_with_offset">decode_with_offset</h2>

<p>Same as the <code>decode</code> method, except as second parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalar (see <code>decode</code> above) is relegated to being the third parameter.</p>

<h2 id="decode_only_header_with_offset">decode_only_header_with_offset</h2>

<p>Same as the <code>decode_only_header</code> method, except as second parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalar (see <code>decode_only_header</code> above) is relegated to being the third parameter.</p>

<h2 id="decode_with_header_and_offset">decode_with_header_and_offset</h2>

<p>Same as the <code>decode_with_header</code> method, except as second parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalars (see <code>decode_with_header</code> above) are relegated to being the third and fourth parameters.</p>

<h2 id="bytes_consumed">bytes_consumed</h2>

<p>After using the various <code>decode</code> methods documented previously, <code>bytes_consumed</code> can return the number of bytes <b>from the body</b> of the input string that were actually consumed by the decoder. That is, if you append random garbage to a valid Sereal document, <code>decode</code> will happily decode the data and ignore the garbage. If that is an error in your use case, you can use <code>bytes_consumed</code> to catch it.</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$out</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">);</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">length</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">)</span> <span class="operator">!=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">bytes_consumed</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">die</span> <span class="string">"Not all input data was consumed!"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></pre>

<p>Chances are that if you do this, you&#39;re violating UNIX philosophy in &quot;be strict in what you emit but lenient in what you accept&quot;.</p>

<p>You can also use this to deserialize a list of Sereal documents that is concatenated into the same string (code not very robust...):</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">@out</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$pos</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="keyword">eval</span> <span class="operator">{</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">push</span> <span class="variable">@out</span><span class="operator">,</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode_with_offset</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">,</span> <span class="variable">$pos</span><span class="operator">);</span>
      <span class="variable">$pos</span> <span class="operator">+=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">bytes_consumed</span><span class="operator">;</span>
      <span class="keyword">last</span> <span class="keyword">if</span> <span class="variable">$pos</span> <span class="operator">&gt;=</span> <span class="keyword">length</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">)</span>
           <span class="keyword">or</span> <span class="keyword">not</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">bytes_consumed</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">};</span>
</code></pre>

<p>As mentioned, only the bytes consumed from the body are considered. So the following example is correct, as only the header is deserialized:</p>

<pre><code>  <span class="keyword">my</span> <span class="variable">$header</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">decode_only_header</span><span class="operator">(</span><span class="variable">$sereal_string</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$decoder</span><span class="operator">-&gt;</span><span class="variable">bytes_consumed</span><span class="operator">;</span>
  <span class="comment"># $count is 0</span>
</code></pre>

<h2 id="looks_like_sereal">looks_like_sereal</h2>

<p>Performs some rudimentary check to determine if the argument appears to be a valid Sereal packet or not. These tests are not comprehensive and a true result does not mean that the document is valid, merely that it appears to be valid. On the other hand a false result is always reliable.</p>

<p>The return of this function may be treated as a simple boolean but is in fact a more complex return. When the argument does not look anything like a Sereal document then the return is perl&#39;s FALSE, which has the property of being string equivalent to &quot;&quot; and numerically equivalent to 0. However when the argument appears to be a UTF-8 encoded protocol 3 Sereal document (by noticing that the \xF3 in the magic string has been replaced by \xC3\xB3) then it returns 0 (the number, which is string equivalent to &quot;0&quot;), and otherwise returns the protocol version of the document. This means you can write something like this:</p>

<pre><code>    <span class="variable">$type</span><span class="operator">=</span> <span class="variable">looks_like_sereal</span><span class="operator">(</span><span class="variable">$thing</span><span class="operator">);</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$type</span> <span class="keyword">eq</span> <span class="string">''</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">say</span> <span class="string">"Not a Sereal document"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$type</span> <span class="keyword">eq</span> <span class="string">'0'</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">say</span> <span class="string">"Possibly utf8 encoded Sereal document"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">say</span> <span class="string">"Sereal document version </span><span class="variable">$type</span><span class="string">"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></pre>

<p>For reference, Sereal&#39;s magic value is a four byte string which is either <code>=srl</code> for protocol version 1 and 2 or <code>=\xF3rl</code> for protocol version 3 and later. This function checks that the magic string corresponds with the reported version number, as well as other checks, which may be enhanced in the future.</p>

<h1 id="EXPORTABLE-FUNCTIONS">EXPORTABLE FUNCTIONS</h1>

<h2 id="sereal_decode_with_object">sereal_decode_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode</code>. Takes a decoder object reference as first parameter, followed by a byte string to deserialize. Optionally takes a third parameter, which is the output scalar to write to. See the documentation for <code>decode</code> above for details.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="sereal_decode_with_header_with_object">sereal_decode_with_header_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode_with_header</code>. Takes a decoder object reference as first parameter, followed by a byte string to deserialize. Optionally takes third and fourth parameters, which are the output scalars to write to. See the documentation for <code>decode_with_header</code> above for details.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="sereal_decode_only_header_with_object">sereal_decode_only_header_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode_only_header</code>. Takes a decoder object reference as first parameter, followed by a byte string to deserialize. Optionally takes a third parameters, which outputs scalars to write to. See the documentation for <code>decode_with_header</code> above for details.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="sereal_decode_only_header_with_offset_with_object">sereal_decode_only_header_with_offset_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode_only_header_with_offset</code>. Same as the <code>sereal_decode_only_header_with_object</code> function, except as the third parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalar (see <code>sereal_decode_only_header_with_object</code> above) is relegated to being the fourth parameter.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="sereal_decode_with_header_and_offset_with_object">sereal_decode_with_header_and_offset_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode_with_header_and_offset</code>. Same as the <code>sereal_decode_with_header_with_object</code> function, except as the third parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalars (see <code>sereal_decode_with_header_with_object</code> above) are relegated to being the fourth and fifth parameters.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="sereal_decode_with_offset_with_object">sereal_decode_with_offset_with_object</h2>

<p>The functional interface that is equivalent to using <code>decode_with_offset</code>. Same as the <code>sereal_decode_with_object</code> function, except as the third parameter, you must pass an integer offset into the input string, at which the decoding is to start. The optional &quot;pass-in&quot; style scalar (see <code>sereal_decode_with_object</code> above) is relegated to being the third parameter.</p>

<p>This functional interface is marginally faster than the OO interface since it avoids method resolution overhead and, on sufficiently modern Perl versions, can usually avoid subroutine call overhead. See <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> for a discussion on how to tune Sereal for maximum performance if you need to.</p>

<h2 id="decode_sereal">decode_sereal</h2>

<p>The functional interface that is equivalent to using <code>new</code> and <code>decode</code>. Expects a byte string to deserialize as first argument, optionally followed by a hash reference of options (see documentation for <code>new()</code>). Finally, <code>decode_sereal</code> supports a third parameter, which is the output scalar to write to. See the documentation for <code>decode</code> above for details.</p>

<p>This functional interface is significantly slower than the OO interface since it cannot reuse the decoder object.</p>

<h2 id="decode_sereal_with_header_data">decode_sereal_with_header_data</h2>

<p>The functional interface that is equivalent to using <code>new</code> and <code>decode_with_header</code>. Expects a byte string to deserialize as first argument, optionally followed by a hash reference of options (see documentation for <code>new()</code>). Finally, <code>decode_sereal</code> supports third and fourth parameters, which are the output scalars to write to. See the documentation for <code>decode_with_header</code> above for details.</p>

<p>This functional interface is significantly slower than the OO interface since it cannot reuse the decoder object.</p>

<h2 id="scalar_looks_like_sereal">scalar_looks_like_sereal</h2>

<p>The functional interface that is equivalent to using <code>looks_like_sereal</code>.</p>

<h1 id="ROBUSTNESS">ROBUSTNESS</h1>

<p>This implementation of a Sereal decoder tries to be as robust to invalid input data as reasonably possible. This means that it should never (though read on) segfault. It may, however, cause a large malloc to fail. Generally speaking, invalid data should cause a Perl-trappable exception. The one exception is that for Snappy-compressed Sereal documents, the Snappy library may cause segmentation faults (invalid reads or writes). This should only be a problem if you do not checksum your data (internal checksum support is a To-Do) or if you accept data from potentially malicious sources.</p>

<p>It requires a lot of run-time boundary checks to prevent decoder segmentation faults on invalid data. We implemented them in the lightest way possible. Adding robustness against running out of memory would cause an very significant run-time overhead. In most cases of random garbage (with valid header no less) when a malloc() fails due to invalid data, the problem was caused by a very large array or string length. This kind of very large malloc can then fail, being trappable from Perl. Only when packet causes many repeated allocations do you risk causing a hard OOM error from the kernel that cannot be trapped because Perl may require some small allocations to succeed before the now-invalid memory is released. It is at least not entirely trivial to craft a Sereal document that causes this behaviour.</p>

<p>Finally, deserializing proper objects is potentially a problem because classes can define a destructor. Thus, the data fed to the decoder can cause the (deferred) execution of any destructor in your application. That&#39;s why the <code>refuse_objects</code> option exists and what the <code>no_bless_objects</code> can be used for as well. Later on, we may or may not provide a facility to whitelist classes. Furthermore, if the encoder emitted any objects using <code>FREEZE</code> callbacks, the <code>THAW</code> class method may be invoked on the respective classes. If you can&#39;t trust the source of your Sereal documents, you may want to use the <code>refuse_objects</code> option. For more details on the <code>FREEZE/THAW</code> mechanism, please refer to <a href="../../lib/Sereal/Encoder.html">Sereal::Encoder</a>.</p>

<h1 id="PERFORMANCE">PERFORMANCE</h1>

<p>Please refer to the <a href="../../lib/Sereal/Performance.html">Sereal::Performance</a> document that has more detailed information about Sereal performance and tuning thereof.</p>

<h1 id="THREAD-SAFETY">THREAD-SAFETY</h1>

<p><code>Sereal::Decoder</code> is thread-safe on Perl&#39;s 5.8.7 and higher. This means &quot;thread-safe&quot; in the sense that if you create a new thread, all <code>Sereal::Decoder</code> objects will become a reference to undef in the new thread. This might change in a future release to become a full clone of the decoder object.</p>

<h1 id="BUGS-CONTACT-AND-SUPPORT">BUGS, CONTACT AND SUPPORT</h1>

<p>For reporting bugs, please use the github bug tracker at <a href="http://github.com/Sereal/Sereal/issues">http://github.com/Sereal/Sereal/issues</a>.</p>

<p>For support and discussion of Sereal, there are two Google Groups:</p>

<p>Announcements around Sereal (extremely low volume): <a href="https://groups.google.com/forum/?fromgroups#!forum/sereal-announce">https://groups.google.com/forum/?fromgroups#!forum/sereal-announce</a></p>

<p>Sereal development list: <a href="https://groups.google.com/forum/?fromgroups#!forum/sereal-dev">https://groups.google.com/forum/?fromgroups#!forum/sereal-dev</a></p>

<h1 id="AUTHORS-AND-CONTRIBUTORS">AUTHORS AND CONTRIBUTORS</h1>

<p>Yves Orton &lt;demerphq@gmail.com&gt;</p>

<p>Damian Gryski</p>

<p>Steffen Mueller &lt;smueller@cpan.org&gt;</p>

<p>Rafa&euml;l Garcia-Suarez</p>

<p>&AElig;var Arnfj&ouml;r&eth; Bjarmason &lt;avar@cpan.org&gt;</p>

<p>Tim Bunce</p>

<p>Daniel Dragan &lt;bulkdd@cpan.org&gt; (Windows support and bugfixes)</p>

<p>Zefram</p>

<p>Borislav Nikolov</p>

<p>Ivan Kruglov &lt;ivan.kruglov@yahoo.com&gt;</p>

<p>Eric Herman &lt;eric@freesa.org&gt;</p>

<p>Some inspiration and code was taken from Marc Lehmann&#39;s excellent JSON::XS module due to obvious overlap in problem domain.</p>

<h1 id="ACKNOWLEDGMENT">ACKNOWLEDGMENT</h1>

<p>This module was originally developed for Booking.com. With approval from Booking.com, this module was generalized and published on CPAN, for which the authors would like to express their gratitude.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2012, 2013, 2014 by Steffen Mueller Copyright (C) 2012, 2013, 2014 by Yves Orton</p>

<p>The license for the code in this distribution is the following, with the exceptions listed below:</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>Except portions taken from Marc Lehmann&#39;s code for the JSON::XS module, which is licensed under the same terms as this module. (Many thanks to Marc for inspiration, and code.)</p>

<p>Also except the code for Snappy compression library, whose license is reproduced below and which, to the best of our knowledge, is compatible with this module&#39;s license. The license for the enclosed Snappy code is:</p>

<pre><code>  Copyright 2011, Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are
  met:

    * Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the following disclaimer
  in the documentation and/or other materials provided with the
  distribution.
    * Neither the name of Google Inc. nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>


</body>

</html>


