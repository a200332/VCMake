<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#Function-syntax">Function syntax</a></li>
  <li><a href="#User-Defined-Functions">User-Defined Functions</a>
    <ul>
      <li><a href="#Loading-User-Defined-Functions">Loading User-Defined Functions</a></li>
      <li><a href="#Creating-User-Defined-Functions">Creating User-Defined Functions</a></li>
      <li><a href="#Creating-In-Memory-Tables-with-functions">Creating In-Memory Tables with functions</a></li>
    </ul>
  </li>
  <li><a href="#Built-in-Functions">Built-in Functions</a>
    <ul>
      <li><a href="#SQL-92-ODBC-Compatibility">SQL-92/ODBC Compatibility</a></li>
      <li><a href="#Aggregate-Functions">Aggregate Functions</a>
        <ul>
          <li><a href="#MIN-MAX-AVG-SUM-COUNT">MIN, MAX, AVG, SUM, COUNT</a></li>
        </ul>
      </li>
      <li><a href="#Date-and-Time-Functions">Date and Time Functions</a>
        <ul>
          <li><a href="#CURRENT_DATE-aka-CURDATE">CURRENT_DATE aka CURDATE</a></li>
          <li><a href="#CURRENT_TIME-aka-CURTIME">CURRENT_TIME aka CURTIME</a></li>
          <li><a href="#CURRENT_TIMESTAMP-aka-NOW">CURRENT_TIMESTAMP aka NOW</a></li>
          <li><a href="#UNIX_TIMESTAMP">UNIX_TIMESTAMP</a></li>
        </ul>
      </li>
      <li><a href="#String-Functions">String Functions</a>
        <ul>
          <li><a href="#ASCII-CHAR">ASCII &amp; CHAR</a></li>
          <li><a href="#BIT_LENGTH">BIT_LENGTH</a></li>
          <li><a href="#CHARACTER_LENGTH-aka-CHAR_LENGTH">CHARACTER_LENGTH aka CHAR_LENGTH</a></li>
          <li><a href="#COALESCE-aka-NVL-aka-IFNULL">COALESCE aka NVL aka IFNULL</a></li>
          <li><a href="#CONCAT">CONCAT</a></li>
          <li><a href="#CONV">CONV</a></li>
          <li><a href="#DECODE">DECODE</a></li>
          <li><a href="#INSERT">INSERT</a></li>
          <li><a href="#HEX-OCT-BIN">HEX &amp; OCT &amp; BIN</a></li>
          <li><a href="#LEFT-RIGHT">LEFT &amp; RIGHT</a></li>
          <li><a href="#LOCATE-aka-POSITION">LOCATE aka POSITION</a></li>
          <li><a href="#LOWER-UPPER-aka-LCASE-UCASE">LOWER &amp; UPPER aka LCASE &amp; UCASE</a></li>
          <li><a href="#LTRIM-RTRIM">LTRIM &amp; RTRIM</a></li>
          <li><a href="#OCTET_LENGTH">OCTET_LENGTH</a></li>
          <li><a href="#REGEX">REGEX</a></li>
          <li><a href="#REPEAT">REPEAT</a></li>
          <li><a href="#REPLACE-aka-SUBSTITUTE">REPLACE aka SUBSTITUTE</a></li>
          <li><a href="#SOUNDEX">SOUNDEX</a></li>
          <li><a href="#SPACE">SPACE</a></li>
          <li><a href="#SUBSTRING">SUBSTRING</a></li>
          <li><a href="#SUBSTR">SUBSTR</a></li>
          <li><a href="#TRANSLATE">TRANSLATE</a></li>
          <li><a href="#TRIM">TRIM</a></li>
          <li><a href="#UNHEX">UNHEX</a></li>
        </ul>
      </li>
      <li><a href="#Numeric-Functions">Numeric Functions</a>
        <ul>
          <li><a href="#ABS">ABS</a></li>
          <li><a href="#CEILING-aka-CEIL-FLOOR">CEILING (aka CEIL) &amp; FLOOR</a></li>
          <li><a href="#EXP">EXP</a></li>
          <li><a href="#LOG">LOG</a></li>
          <li><a href="#LN-LOG10">LN &amp; LOG10</a></li>
          <li><a href="#MOD">MOD</a></li>
          <li><a href="#POWER-aka-POW">POWER aka POW</a></li>
          <li><a href="#RAND">RAND</a></li>
          <li><a href="#ROUND">ROUND</a></li>
          <li><a href="#SIGN">SIGN</a></li>
          <li><a href="#SQRT">SQRT</a></li>
          <li><a href="#TRUNCATE-aka-TRUNC">TRUNCATE aka TRUNC</a></li>
        </ul>
      </li>
      <li><a href="#Trigonometric-Functions">Trigonometric Functions</a></li>
      <li><a href="#System-Functions">System Functions</a>
        <ul>
          <li><a href="#DBNAME-USERNAME-aka-USER">DBNAME &amp; USERNAME (aka USER)</a></li>
        </ul>
      </li>
      <li><a href="#Special-Utility-Functions">Special Utility Functions</a>
        <ul>
          <li><a href="#IMPORT">IMPORT</a></li>
          <li><a href="#RUN">RUN</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Submitting-built-in-functions">Submitting built-in functions</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#AUTHOR-COPYRIGHT">AUTHOR &amp; COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>SQL::Statement::Functions - built-in &amp; user-defined SQL functions</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> SELECT Func(args);
 SELECT * FROM Func(args);
 SELECT * FROM x WHERE Funcs(args);
 SELECT * FROM x WHERE y &lt; Funcs(args);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module contains the built-in functions for <a href="../../../lib/SQL/Parser.html">SQL::Parser</a> and <a href="../../../lib/SQL/Statement.html">SQL::Statement</a>. All of the functions are also available in any DBDs that subclass those modules (e.g. DBD::CSV, DBD::DBM, DBD::File, DBD::AnyData, DBD::Excel, etc.).</p>

<p>This documentation covers built-in functions and also explains how to create your own functions to supplement the built-in ones. It&#39;s easy. If you create one that is generally useful, see below for how to submit it to become a built-in function.</p>

<h1 id="Function-syntax">Function syntax</h1>

<p>When using <a href="../../../lib/SQL/Statement.html">SQL::Statement</a>/<a href="../../../lib/SQL/Parser.html">SQL::Parser</a> directly to parse SQL, functions (either built-in or user-defined) may occur anywhere in a SQL statement that values, column names, table names, or predicates may occur. When using the modules through a DBD or in any other context in which the SQL is both parsed and executed, functions can occur in the same places except that they can not occur in the column selection clause of a SELECT statement that contains a FROM clause.</p>

<pre><code> # valid for both parsing and executing

     SELECT MyFunc(args);
     SELECT * FROM MyFunc(args);
     SELECT * FROM x WHERE MyFuncs(args);
     SELECT * FROM x WHERE y &lt; MyFuncs(args);

 # valid only for parsing (won&#39;t work from a DBD)

     SELECT MyFunc(args) FROM x WHERE y;</code></pre>

<h1 id="User-Defined-Functions">User-Defined Functions</h1>

<h2 id="Loading-User-Defined-Functions">Loading User-Defined Functions</h2>

<p>In addition to the built-in functions, you can create any number of your own user-defined functions (UDFs). In order to use a UDF in a script, you first have to create a perl subroutine (see below), then you need to make the function available to your database handle with the CREATE FUNCTION or LOAD commands:</p>

<pre><code> <span class="comment"># load a single function "foo" from a subroutine</span>
 <span class="comment"># named "foo" in the current package</span>
 
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">" CREATE FUNCTION foo EXTERNAL "</span><span class="operator">);</span>
 
 <span class="comment"># load a single function "foo" from a subroutine</span>
 <span class="comment"># named "bar" in the current package</span>
 
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">" CREATE FUNCTION foo EXTERNAL NAME bar"</span><span class="operator">);</span>
 
 
 <span class="comment"># load a single function "foo" from a subroutine named "foo"</span>
 <span class="comment"># in another package</span>
 
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">' CREATE FUNCTION foo EXTERNAL NAME "Bar::Baz::foo" '</span><span class="operator">);</span>
 
 <span class="comment"># load all the functions in another package</span>
 
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">' LOAD "Bar::Baz" '</span><span class="operator">);</span>
</code></pre>

<p>Functions themselves should follow SQL identifier naming rules. Subroutines loaded with CREATE FUNCTION can have any valid perl subroutine name. Subroutines loaded with LOAD must start with SQL_FUNCTION_ and then the actual function name. For example:</p>

<pre><code> <span class="keyword">package</span> <span class="variable">Qux::Quimble</span><span class="operator">;</span>
 <span class="keyword">sub</span><span class="variable"> SQL_FUNCTION_FOO </span><span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
 <span class="keyword">sub</span><span class="variable"> SQL_FUNCTION_BAR </span><span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
 <span class="keyword">sub</span><span class="variable"> some_other_perl_subroutine_not_a_function </span><span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
 <span class="number">1</span><span class="operator">;</span>
 
 <span class="comment"># in another package</span>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"LOAD Qux::Quimble"</span><span class="operator">);</span>
 
 <span class="comment"># This loads FOO and BAR as SQL functions.</span>
</code></pre>

<h2 id="Creating-User-Defined-Functions">Creating User-Defined Functions</h2>

<p>User-defined functions (UDFs) are perl subroutines that return values appropriate to the context of the function in a SQL statement. For example the built-in CURRENT_TIME returns a string value and therefore may be used anywhere in a SQL statement that a string value can. Here&#39; the entire perl code for the function:</p>

<pre><code> <span class="comment"># CURRENT_TIME</span>
 <span class="comment">#</span>
 <span class="comment"># arguments : none</span>
 <span class="comment"># returns   : string containing current time as hh::mm::ss</span>
 <span class="comment">#</span>
 <span class="keyword">sub</span><span class="variable"> SQL_FUNCTION_CURRENT_TIME </span><span class="operator">{</span>
     <span class="keyword">sprintf</span> <span class="string">"%02s::%02s::%02s"</span><span class="operator">,(</span><span class="keyword">localtime</span><span class="operator">)</span><span class="operator">[</span><span class="number">2</span><span class="operator">,</span><span class="number">1</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span>
 <span class="operator">}</span>
</code></pre>

<p>More complex functions can make use of a number of arguments always passed to functions automatically. Functions always receive these values in @_:</p>

<pre><code> <span class="keyword">sub</span><span class="variable"> FOO </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$sth</span><span class="operator">,</span><span class="variable">@params</span><span class="operator">);</span>
 <span class="operator">}</span>
</code></pre>

<p>The first argument, $self, is whatever class the function is defined in, not generally useful unless you have an entire module to support the function.</p>

<p>The second argument, $sth is the active statement handle of the current statement. Like all active statement handles it contains the current database handle in the {Database} attribute so you can have access to the database handle in any function:</p>

<pre><code> <span class="keyword">sub</span><span class="variable"> FOO </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$sth</span><span class="operator">,</span><span class="variable">@params</span><span class="operator">);</span>
     <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Database</span><span class="operator">}</span><span class="operator">;</span>
     <span class="comment"># $dbh-&gt;do( ...), etc.</span>
 <span class="operator">}</span>
</code></pre>

<p>In actual practice you probably want to use $sth-&gt;{Database} directly rather than making a local copy, so $sth-&gt;{Database}-&gt;do(...).</p>

<p>The remaining arguments, @params, are arguments passed by users to the function, either directly or with placeholders; another silly example which just returns the results of multiplying the arguments passed to it:</p>

<pre><code> <span class="keyword">sub</span><span class="variable"> MULTIPLY </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$sth</span><span class="operator">,</span><span class="variable">@params</span><span class="operator">);</span>
     <span class="keyword">return</span> <span class="variable">$params</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">*</span> <span class="variable">$params</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
 <span class="operator">}</span>
 
 <span class="comment"># first make the function available</span>
 <span class="comment">#</span>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CREATE FUNCTION MULTIPLY"</span><span class="operator">);</span>
 
 <span class="comment"># then multiply col3 in each row times seven</span>
 <span class="comment">#</span>
 <span class="keyword">my</span> <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT col1 FROM tbl1 WHERE col2 = MULTIPLY(col3,7)"</span><span class="operator">);</span>
 <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
 <span class="comment">#</span>
 <span class="comment"># or</span>
 <span class="comment">#</span>
 <span class="keyword">my</span> <span class="variable">$sth</span><span class="operator">=</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT col1 FROM tbl1 WHERE col2 = MULTIPLY(col3,?)"</span><span class="operator">);</span>
 <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">7</span><span class="operator">);</span>
</code></pre>

<h2 id="Creating-In-Memory-Tables-with-functions">Creating In-Memory Tables with functions</h2>

<p>A function can return almost anything, as long is it is an appropriate return for the context the function will be used in. In the special case of table-returning functions, the function should return a reference to an array of array references with the first row being the column names and the remaining rows the data. For example:</p>

<p><b>1. create a function that returns an AoA</b>,</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> Japh </span><span class="operator">{</span><span class="operator">[</span>
      <span class="operator">[</span><span class="string">qw( id word   )</span><span class="operator">]</span><span class="operator">,</span>
      <span class="operator">[</span><span class="string">qw( 1 Hacker  )</span><span class="operator">]</span><span class="operator">,</span>
      <span class="operator">[</span><span class="string">qw( 2 Perl    )</span><span class="operator">]</span><span class="operator">,</span>
      <span class="operator">[</span><span class="string">qw( 3 Another )</span><span class="operator">]</span><span class="operator">,</span>
      <span class="operator">[</span><span class="string">qw( 4 Just    )</span><span class="operator">]</span><span class="operator">,</span>
  <span class="operator">]</span><span class="operator">}</span>
</code></pre>

<p><b>2. make your database handle aware of the function</b></p>

<pre><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CREATE FUNCTION 'Japh');
  </span>
</code></pre>

<p><b>3. Access the data in the AoA from SQL</b></p>

<pre><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT word FROM Japh ORDER BY id DESC"</span><span class="operator">);</span>
</code></pre>

<p>Or here&#39;s an example that does a join on two in-memory tables:</p>

<pre><code>  <span class="keyword">sub</span><span class="variable"> Prof  </span><span class="operator">{</span><span class="operator">[</span> <span class="operator">[</span><span class="string">qw(pid pname)</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(1 Sue )</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(2 Bob)</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(3 Tom )</span><span class="operator">]</span> <span class="operator">]</span><span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> Class </span><span class="operator">{</span><span class="operator">[</span> <span class="operator">[</span><span class="string">qw(pid cname)</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(1 Chem)</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(2 Bio)</span><span class="operator">]</span><span class="operator">,</span><span class="operator">[</span><span class="string">qw(2 Math)</span><span class="operator">]</span> <span class="operator">]</span><span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CREATE FUNCTION </span><span class="variable">$_</span><span class="string">) for qw(Prof Class);
  </span><span class="variable">$sth</span><span class="string"> = </span><span class="variable">$dbh</span><span class="string">-&gt;prepare("</span><span class="variable">SELECT</span> <span class="operator">*</span> <span class="variable">FROM</span> <span class="variable">Prof</span> <span class="variable">NATURAL</span> <span class="variable">JOIN</span> <span class="variable">Class</span><span class="string">");
  </span>
</code></pre>

<p>The &quot;Prof&quot; and &quot;Class&quot; functions return tables which can be used like any SQL table.</p>

<p>More complex functions might do something like scrape an RSS feed, or search a file system and put the results in AoA. For example, to search a directory with SQL:</p>

<pre><code> <span class="keyword">sub</span><span class="variable"> Dir </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span><span class="variable">$sth</span><span class="operator">,</span><span class="variable">$dir</span><span class="operator">)=</span><span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">opendir</span> <span class="variable">D</span><span class="operator">,</span> <span class="variable">$dir</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"'</span><span class="variable">$dir</span><span class="string">':$!"</span><span class="operator">;</span>
     <span class="keyword">my</span> <span class="variable">@files</span> <span class="operator">=</span> <span class="keyword">readdir</span> <span class="variable">D</span><span class="operator">;</span>
     <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="operator">[[</span><span class="string">qw(fileName fileExt)</span><span class="operator">]]</span><span class="operator">;</span>
     <span class="keyword">for</span> <span class="operator">(</span><span class="variable">@files</span><span class="operator">)</span> <span class="operator">{</span>
         <span class="keyword">my</span><span class="operator">(</span><span class="variable">$fn</span><span class="operator">,</span><span class="variable">$ext</span><span class="operator">)</span> <span class="operator">=</span> <span class="regex">/^(.*)(\.[^\.]+)$/</span><span class="operator">;</span>
         <span class="keyword">push</span> <span class="variable">@$data</span><span class="operator">,</span> <span class="operator">[</span><span class="variable">$fn</span><span class="operator">,</span><span class="variable">$ext</span><span class="operator">]</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="keyword">return</span> <span class="variable">$data</span><span class="operator">;</span>
 <span class="operator">}</span>
 <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CREATE FUNCTION Dir"</span><span class="operator">);</span>
 <span class="keyword">printf</span> <span class="string">"%s\n"</span><span class="operator">,</span> <span class="keyword">join</span><span class="string">'   '</span><span class="operator">,</span><span class="variable">@</span><span class="operator">{</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectcol_arrayref</span><span class="operator">(</span><span class="string">"
     SELECT fileName FROM Dir('./') WHERE fileExt = '.pl'
 "</span><span class="operator">)</span><span class="operator">}</span><span class="operator">;</span>
</code></pre>

<p>Obviously, that function could be expanded with File::Find and/or stat to provide more information and it could be made to accept a list of directories rather than a single directory.</p>

<p>Table-Returning functions are a way to turn *anything* that can be modeled as an AoA into a DBI data source.</p>

<h1 id="Built-in-Functions">Built-in Functions</h1>

<h2 id="SQL-92-ODBC-Compatibility">SQL-92/ODBC Compatibility</h2>

<p>All ODBC 3.0 functions are available except for the following:</p>

<pre><code> <span class="comment">### SQL-92 / ODBC Functions</span>
 
 <span class="comment"># CONVERT / CAST - Complex to implement, but a draft is in the works.</span>
 <span class="comment"># DIFFERENCE     - Function is not clearly defined in spec and has very limited applications</span>
 <span class="comment"># EXTRACT        - Contains a FROM keyword and requires rather freeform datetime/interval expression</span>
 
 <span class="comment">### ODBC 3.0 Time/Date Functions only</span>
 
 <span class="comment"># DAYOFMONTH, DAYOFWEEK, DAYOFYEAR, HOUR, MINUTE, MONTH, MONTHNAME, QUARTER, SECOND, TIMESTAMPDIFF, </span>
 <span class="comment">#    WEEK, YEAR - Requires freeform datetime/interval expressions.  In a later release, these could</span>
 <span class="comment">#                    be implemented with the help of Date::Parse.</span>
</code></pre>

<p>ODBC 3.0 functions that are implemented with differences include:</p>

<pre><code> <span class="comment"># SOUNDEX  - Returns true/false, instead of a SOUNDEX code</span>
 <span class="comment"># RAND     - Seed value is a second parameter with a new first parameter for max limit</span>
 <span class="comment"># LOG      - Returns base X (or 10) log of number, not natural log.  LN is used for natural log, and</span>
 <span class="comment">#               LOG10 is still available for standards compatibility.</span>
 <span class="comment"># POSITION - Does not use 'IN' keyword; cannot be fixed as previous versions of SQL::Statement defined</span>
 <span class="comment">#               the function as such.</span>
 <span class="comment"># REPLACE / SUBSTITUTE - Uses a regular expression string for the second parameter, replacing the last two</span>
 <span class="comment">#                           parameters of the typical ODBC function</span>
</code></pre>

<h2 id="Aggregate-Functions">Aggregate Functions</h2>

<h3 id="MIN-MAX-AVG-SUM-COUNT">MIN, MAX, AVG, SUM, COUNT</h3>

<p>Aggregate functions are handled elsewhere, see <a href="../../../lib/SQL/Parser.html">SQL::Parser</a> for documentation.</p>

<h2 id="Date-and-Time-Functions">Date and Time Functions</h2>

<p>These functions can be used without parentheses.</p>

<h3 id="CURRENT_DATE-aka-CURDATE">CURRENT_DATE aka CURDATE</h3>

<pre><code> <span class="comment"># purpose   : find current date</span>
 <span class="comment"># arguments : none</span>
 <span class="comment"># returns   : string containing current date as yyyy-mm-dd</span>
</code></pre>

<h3 id="CURRENT_TIME-aka-CURTIME">CURRENT_TIME aka CURTIME</h3>

<pre><code> <span class="comment"># purpose   : find current time</span>
 <span class="comment"># arguments : optional seconds precision</span>
 <span class="comment"># returns   : string containing current time as hh:mm:ss (or ss.sss...)</span>
</code></pre>

<h3 id="CURRENT_TIMESTAMP-aka-NOW">CURRENT_TIMESTAMP aka NOW</h3>

<pre><code> <span class="comment"># purpose   : find current date and time</span>
 <span class="comment"># arguments : optional seconds precision</span>
 <span class="comment"># returns   : string containing current timestamp as yyyy-mm-dd hh:mm:ss (or ss.sss...)</span>
</code></pre>

<h3 id="UNIX_TIMESTAMP">UNIX_TIMESTAMP</h3>

<pre><code> <span class="comment"># purpose   : find the current time in UNIX epoch format</span>
 <span class="comment"># arguments : optional seconds precision (unlike the MySQL version)</span>
 <span class="comment"># returns   : a (64-bit) number, possibly with decimals</span>
</code></pre>

<h2 id="String-Functions">String Functions</h2>

<h3 id="ASCII-CHAR">ASCII &amp; CHAR</h3>

<pre><code> <span class="comment"># purpose   : same as ord and chr, respectively (NULL for any NULL args)</span>
 <span class="comment"># arguments : string or character (or number for CHAR); CHAR can have any amount of numbers for a string</span>
</code></pre>

<h3 id="BIT_LENGTH">BIT_LENGTH</h3>

<pre><code> <span class="comment"># purpose   : length of the string in bits</span>
 <span class="comment"># arguments : string</span>
</code></pre>

<h3 id="CHARACTER_LENGTH-aka-CHAR_LENGTH">CHARACTER_LENGTH aka CHAR_LENGTH</h3>

<pre><code> <span class="comment"># purpose   : find length in characters of a string</span>
 <span class="comment"># arguments : a string</span>
 <span class="comment"># returns   : a number - the length of the string in characters</span>
</code></pre>

<h3 id="COALESCE-aka-NVL-aka-IFNULL">COALESCE aka NVL aka IFNULL</h3>

<pre><code> <span class="comment"># purpose   : return the first non-NULL value from a list</span>
 <span class="comment"># arguments : 1 or more expressions</span>
 <span class="comment"># returns   : the first expression (reading left to right)</span>
 <span class="comment">#             which is not NULL; returns NULL if all are NULL</span>
 <span class="comment">#</span>
</code></pre>

<h3 id="CONCAT">CONCAT</h3>

<pre><code> <span class="comment"># purpose   : concatenate 1 or more strings into a single string;</span>
 <span class="comment">#                      an alternative to the '||' operator</span>
 <span class="comment"># arguments : 1 or more strings</span>
 <span class="comment"># returns   : the concatenated string</span>
 <span class="comment">#</span>
 <span class="comment"># example   : SELECT CONCAT(first_string, 'this string', ' that string')</span>
 <span class="comment">#              returns "&lt;value-of-first-string&gt;this string that string"</span>
 <span class="comment"># note      : if any argument evaluates to NULL, the returned value is NULL</span>
</code></pre>

<h3 id="CONV">CONV</h3>

<pre><code> # purpose   : convert a number X from base Y to base Z (from base 2 to 64)
 # arguments : X (can by a number or string depending on the base), Y, Z (Z defaults to 10)
               Valid bases for Y and Z are: 2, 8, 10, 16 and 64
 # returns   : either a string or number, in base Z
 # notes     : Behavioral table
 #
 #      base | valuation
 #     ------+-----------
 #         2 | binary, base 2 - (0,1)
 #         8 | octal, base 8 - (0..7)
 #        10 | decimal, base 10 - (0..9)
 #        16 | hexadecimal, base 16 - (0..9,a..f)
 #        64 | 0-63 from MIME::Base64
 #</code></pre>

<h3 id="DECODE">DECODE</h3>

<pre><code> <span class="comment"># purpose   : compare the first argument against</span>
 <span class="comment">#             succeeding arguments at position 1 + 2N</span>
 <span class="comment">#             (N = 0 to (# of arguments - 2)/2), and if equal,</span>
 <span class="comment">#                              return the value of the argument at 1 + 2N + 1; if no</span>
 <span class="comment">#             arguments are equal, the last argument value is returned</span>
 <span class="comment"># arguments : 4 or more expressions, must be even # of arguments</span>
 <span class="comment"># returns   : the value of the argument at 1 + 2N + 1 if argument 1 + 2N</span>
 <span class="comment">#             is equal to argument1; else the last argument value</span>
 <span class="comment">#</span>
 <span class="comment"># example   : SELECT DECODE(some_column,</span>
 <span class="comment">#                    'first value', 'first value matched'</span>
 <span class="comment">#                    '2nd value', '2nd value matched'</span>
 <span class="comment">#                    'no value matched'</span>
 <span class="comment">#                    )</span>
</code></pre>

<h3 id="INSERT">INSERT</h3>

<pre><code> <span class="comment"># purpose   : string where L characters have been deleted from STR1, beginning at S,</span>
 <span class="comment">#             and where STR2 has been inserted into STR1, beginning at S.  NULL for any NULL args.</span>
 <span class="comment"># arguments : STR1, S, L, STR2</span>
</code></pre>

<h3 id="HEX-OCT-BIN">HEX &amp; OCT &amp; BIN</h3>

<pre><code> <span class="comment"># purpose   : convert number X from decimal to hex/octal/binary; equiv. to CONV(X, 10, 16/8/2)</span>
 <span class="comment"># arguments : X</span>
</code></pre>

<h3 id="LEFT-RIGHT">LEFT &amp; RIGHT</h3>

<pre><code> <span class="comment"># purpose   : leftmost or rightmost L characters in STR, or NULL for any NULL args</span>
 <span class="comment"># arguments : STR1, L</span>
</code></pre>

<h3 id="LOCATE-aka-POSITION">LOCATE aka POSITION</h3>

<pre><code> <span class="comment"># purpose   : starting position (one-based) of the first occurrence of STR1</span>
               <span class="variable">within</span> <span class="variable">STR2</span><span class="operator">;</span> <span class="number">0</span> <span class="keyword">if</span> <span class="variable">it</span> <span class="variable">doesn't</span> <span class="variable">occur</span> <span class="keyword">and</span> <span class="variable">NULL</span> <span class="keyword">for</span> <span class="variable">any</span> <span class="variable">NULL</span> <span class="variable">args</span>
 <span class="comment"># arguments : STR1, STR2, and an optional S (starting position to search)</span>
</code></pre>

<h3 id="LOWER-UPPER-aka-LCASE-UCASE">LOWER &amp; UPPER aka LCASE &amp; UCASE</h3>

<pre><code> <span class="comment"># purpose   : lower-case or upper-case a string</span>
 <span class="comment"># arguments : a string</span>
 <span class="comment"># returns   : the sting lower or upper cased</span>
</code></pre>

<h3 id="LTRIM-RTRIM">LTRIM &amp; RTRIM</h3>

<pre><code> <span class="comment"># purpose   : left/right counterparts for TRIM</span>
 <span class="comment"># arguments : string</span>
</code></pre>

<h3 id="OCTET_LENGTH">OCTET_LENGTH</h3>

<pre><code> <span class="comment"># purpose   : length of the string in bytes (not characters)</span>
 <span class="comment"># arguments : string</span>
</code></pre>

<h3 id="REGEX">REGEX</h3>

<pre><code> <span class="comment"># purpose   : test if a string matches a perl regular expression</span>
 <span class="comment"># arguments : a string and a regex to match the string against</span>
 <span class="comment"># returns   : boolean value of the regex match</span>
 <span class="comment">#</span>
 <span class="comment"># example   : ... WHERE REGEX(col3,'/^fun/i') ... matches rows</span>
 <span class="comment">#             in which col3 starts with "fun", ignoring case</span>
</code></pre>

<h3 id="REPEAT">REPEAT</h3>

<pre><code> <span class="comment"># purpose   : string composed of STR1 repeated C times, or NULL for any NULL args</span>
 <span class="comment"># arguments : STR1, C</span>
</code></pre>

<h3 id="REPLACE-aka-SUBSTITUTE">REPLACE aka SUBSTITUTE</h3>

<pre><code> <span class="comment"># purpose   : perform perl subsitution on input string</span>
 <span class="comment"># arguments : a string and a substitute pattern string</span>
 <span class="comment"># returns   : the result of the substitute operation</span>
 <span class="comment">#</span>
 <span class="comment"># example   : ... WHERE REPLACE(col3,'s/fun(\w+)nier/$1/ig') ... replaces</span>
 <span class="comment">#                      all instances of /fun(\w+)nier/ in col3 with the string</span>
 <span class="comment">#                      between 'fun' and 'nier'</span>
</code></pre>

<h3 id="SOUNDEX">SOUNDEX</h3>

<pre><code> <span class="comment"># purpose   : test if two strings have matching soundex codes</span>
 <span class="comment"># arguments : two strings</span>
 <span class="comment"># returns   : true if the strings share the same soundex code</span>
 <span class="comment">#</span>
 <span class="comment"># example   : ... WHERE SOUNDEX(col3,'fun') ... matches rows</span>
 <span class="comment">#             in which col3 is a soundex match for "fun"</span>
</code></pre>

<h3 id="SPACE">SPACE</h3>

<pre><code> <span class="comment"># purpose   : a string of spaces</span>
 <span class="comment"># arguments : number of spaces</span>
</code></pre>

<h3 id="SUBSTRING">SUBSTRING</h3>

<pre><code>  SUBSTRING( string FROM start_pos [FOR length] )</code></pre>

<p>Returns the substring starting at start_pos and extending for &quot;length&quot; character or until the end of the string, if no &quot;length&quot; is supplied. Examples:</p>

<pre><code>  SUBSTRING( &#39;foobar&#39; FROM 4 )       # returns &quot;bar&quot;

  SUBSTRING( &#39;foobar&#39; FROM 4 FOR 2)  # returns &quot;ba&quot;</code></pre>

<p>Note: The SUBSTRING function is implemented in <a href="../../../lib/SQL/Parser.html">SQL::Parser</a> and <a href="../../../lib/SQL/Statement.html">SQL::Statement</a> and, at the current time, can not be over-ridden.</p>

<h3 id="SUBSTR">SUBSTR</h3>

<pre><code> # purpose   : same as SUBSTRING, except with comma-delimited params, instead of
               words (NULL for any NULL args)
 # arguments : string, start_pos, [length]</code></pre>

<h3 id="TRANSLATE">TRANSLATE</h3>

<pre><code> <span class="comment"># purpose   : transliteration; replace a set of characters in a string with another</span>
               <span class="variable">set</span> <span class="variable">of</span> <span class="variable">characters</span> <span class="operator">(</span><span class="variable">a</span> <span class="variable">la</span> <span class="regex">tr///</span><span class="operator">),</span> <span class="keyword">or</span> <span class="variable">NULL</span> <span class="keyword">for</span> <span class="variable">any</span> <span class="variable">NULL</span> <span class="variable">args</span>
 <span class="comment"># arguments : string, string to replace, replacement string</span>
</code></pre>

<h3 id="TRIM">TRIM</h3>

<pre><code>  TRIM ( [ [LEADING|TRAILING|BOTH] [&#39;trim_char&#39;] FROM ] string )</code></pre>

<p>Removes all occurrences of &lt;trim_char&gt; from the front, back, or both sides of a string.</p>

<pre><code> BOTH is the default if neither LEADING nor TRAILING is specified.

 Space is the default if no trim_char is specified.

 Examples:

 TRIM( string )
   trims leading and trailing spaces from string

 TRIM( LEADING FROM str )
   trims leading spaces from string

 TRIM( &#39;x&#39; FROM str )
   trims leading and trailing x&#39;s from string</code></pre>

<p>Note: The TRIM function is implemented in <a href="../../../lib/SQL/Parser.html">SQL::Parser</a> and <a href="../../../lib/SQL/Statement.html">SQL::Statement</a> and, at the current time, can not be over-ridden.</p>

<h3 id="UNHEX">UNHEX</h3>

<pre><code> <span class="comment"># purpose   : convert each pair of hexadecimal digits to a byte (or a Unicode character)</span>
 <span class="comment"># arguments : string of hex digits, with an optional encoding name of the data string</span>
</code></pre>

<h2 id="Numeric-Functions">Numeric Functions</h2>

<h3 id="ABS">ABS</h3>

<pre><code> <span class="comment"># purpose   : find the absolute value of a given numeric expression</span>
 <span class="comment"># arguments : numeric expression</span>
</code></pre>

<h3 id="CEILING-aka-CEIL-FLOOR">CEILING (aka CEIL) &amp; FLOOR</h3>

<pre><code> <span class="comment"># purpose   : rounds up/down to the nearest integer</span>
 <span class="comment"># arguments : numeric expression</span>
</code></pre>

<h3 id="EXP">EXP</h3>

<pre><code> <span class="comment"># purpose   : raise e to the power of a number</span>
 <span class="comment"># arguments : numeric expression</span>
</code></pre>

<h3 id="LOG">LOG</h3>

<pre><code> <span class="comment"># purpose   : base B logarithm of X</span>
 <span class="comment"># arguments : B, X or just one argument of X for base 10</span>
</code></pre>

<h3 id="LN-LOG10">LN &amp; LOG10</h3>

<pre><code> <span class="comment"># purpose   : natural logarithm (base e) or base 10 of X</span>
 <span class="comment"># arguments : numeric expression</span>
</code></pre>

<h3 id="MOD">MOD</h3>

<pre><code> <span class="comment"># purpose   : modulus, or remainder, left over from dividing X / Y</span>
 <span class="comment"># arguments : X, Y</span>
</code></pre>

<h3 id="POWER-aka-POW">POWER aka POW</h3>

<pre><code> <span class="comment"># purpose   : X to the power of Y</span>
 <span class="comment"># arguments : X, Y</span>
</code></pre>

<h3 id="RAND">RAND</h3>

<pre><code> <span class="comment"># purpose   : random fractional number greater than or equal to 0 and less than the value of X</span>
 <span class="comment"># arguments : X (with optional seed value of Y)</span>
</code></pre>

<h3 id="ROUND">ROUND</h3>

<pre><code> <span class="comment"># purpose   : round X with Y number of decimal digits (precision)</span>
 <span class="comment"># arguments : X, optional Y defaults to 0</span>
</code></pre>

<h3 id="SIGN">SIGN</h3>

<pre><code> <span class="comment"># purpose   : returns -1, 0, 1, NULL for negative, 0, positive, NULL values, respectively</span>
 <span class="comment"># arguments : numeric expression</span>
</code></pre>

<h3 id="SQRT">SQRT</h3>

<pre><code> <span class="comment"># purpose   : square root of X</span>
 <span class="comment"># arguments : X</span>
</code></pre>

<h3 id="TRUNCATE-aka-TRUNC">TRUNCATE aka TRUNC</h3>

<pre><code> <span class="comment"># purpose   : similar to ROUND, but removes the decimal</span>
 <span class="comment"># arguments : X, optional Y defaults to 0</span>
</code></pre>

<h2 id="Trigonometric-Functions">Trigonometric Functions</h2>

<p>All of these functions work exactly like their counterparts in <a href="../../../lib/Math/Trig.html">Math::Trig</a>; go there for documentation.</p>

<dl>

<dt id="ACOS">ACOS</dt>
<dd>

</dd>
<dt id="ACOSEC">ACOSEC</dt>
<dd>

</dd>
<dt id="ACOSECH">ACOSECH</dt>
<dd>

</dd>
<dt id="ACOSH">ACOSH</dt>
<dd>

</dd>
<dt id="ACOT">ACOT</dt>
<dd>

</dd>
<dt id="ACOTAN">ACOTAN</dt>
<dd>

</dd>
<dt id="ACOTANH">ACOTANH</dt>
<dd>

</dd>
<dt id="ACOTH">ACOTH</dt>
<dd>

</dd>
<dt id="ACSC">ACSC</dt>
<dd>

</dd>
<dt id="ACSCH">ACSCH</dt>
<dd>

</dd>
<dt id="ASEC">ASEC</dt>
<dd>

</dd>
<dt id="ASECH">ASECH</dt>
<dd>

</dd>
<dt id="ASIN">ASIN</dt>
<dd>

</dd>
<dt id="ASINH">ASINH</dt>
<dd>

</dd>
<dt id="ATAN">ATAN</dt>
<dd>

</dd>
<dt id="ATANH">ATANH</dt>
<dd>

</dd>
<dt id="COS">COS</dt>
<dd>

</dd>
<dt id="COSEC">COSEC</dt>
<dd>

</dd>
<dt id="COSECH">COSECH</dt>
<dd>

</dd>
<dt id="COSH">COSH</dt>
<dd>

</dd>
<dt id="COT">COT</dt>
<dd>

</dd>
<dt id="COTAN">COTAN</dt>
<dd>

</dd>
<dt id="COTANH">COTANH</dt>
<dd>

</dd>
<dt id="COTH">COTH</dt>
<dd>

</dd>
<dt id="CSC">CSC</dt>
<dd>

</dd>
<dt id="CSCH">CSCH</dt>
<dd>

</dd>
<dt id="SEC">SEC</dt>
<dd>

</dd>
<dt id="SECH">SECH</dt>
<dd>

</dd>
<dt id="SIN">SIN</dt>
<dd>

</dd>
<dt id="SINH">SINH</dt>
<dd>

</dd>
<dt id="TAN">TAN</dt>
<dd>

</dd>
<dt id="TANH">TANH</dt>
<dd>

<p>Takes a single parameter. All of <a href="../../../lib/Math/Trig.html">Math::Trig</a>&#39;s aliases are included.</p>

</dd>
<dt id="ATAN2">ATAN2</dt>
<dd>

<p>The y,x version of arc tangent.</p>

</dd>
<dt id="DEG2DEG">DEG2DEG</dt>
<dd>

</dd>
<dt id="DEG2GRAD">DEG2GRAD</dt>
<dd>

</dd>
<dt id="DEG2RAD">DEG2RAD</dt>
<dd>

<p>Converts out-of-bounds values into its correct range.</p>

</dd>
<dt id="GRAD2DEG">GRAD2DEG</dt>
<dd>

</dd>
<dt id="GRAD2GRAD">GRAD2GRAD</dt>
<dd>

</dd>
<dt id="GRAD2RAD">GRAD2RAD</dt>
<dd>

</dd>
<dt id="RAD2DEG">RAD2DEG</dt>
<dd>

</dd>
<dt id="RAD2GRAD">RAD2GRAD</dt>
<dd>

</dd>
<dt id="RAD2RAD">RAD2RAD</dt>
<dd>

<p>Like their <a href="../../../lib/Math/Trig.html">Math::Trig</a>&#39;s counterparts, accepts an optional 2nd boolean parameter (like <b>TRUE</b>) to keep prevent range wrapping.</p>

</dd>
<dt id="DEGREES">DEGREES</dt>
<dd>

</dd>
<dt id="RADIANS">RADIANS</dt>
<dd>

<p><b>DEGREES</b> and <b>RADIANS</b> are included for SQL-92 compatibility, and map to <b>RAD2DEG</b> and <b>DEG2RAD</b>, respectively.</p>

</dd>
<dt id="PI">PI</dt>
<dd>

<p><b>PI</b> can be used without parentheses.</p>

</dd>
</dl>

<h2 id="System-Functions">System Functions</h2>

<h3 id="DBNAME-USERNAME-aka-USER">DBNAME &amp; USERNAME (aka USER)</h3>

<pre><code> <span class="comment"># purpose   : name of the database / username</span>
 <span class="comment"># arguments : none</span>
</code></pre>

<h2 id="Special-Utility-Functions">Special Utility Functions</h2>

<h3 id="IMPORT">IMPORT</h3>

<pre><code> <span class="variable">CREATE</span> <span class="variable">TABLE</span> <span class="variable">foo</span> <span class="variable">AS</span> <span class="variable">IMPORT</span><span class="operator">(</span><span class="regex">?)    ,{},</span><span class="variable">$external_executed_sth</span><span class="regex">
 CREATE TABLE foo AS IMPORT(?</span><span class="operator">)</span>    <span class="operator">,</span><span class="operator">{}</span><span class="operator">,</span><span class="variable">$AoA</span>
</code></pre>

<h3 id="RUN">RUN</h3>

<p>Takes the name of a file containing SQL statements and runs the statements; see <a href="../../../lib/SQL/Parser.html">SQL::Parser</a> for documentation.</p>

<h1 id="Submitting-built-in-functions">Submitting built-in functions</h1>

<p>If you make a generally useful UDF, why not submit it to me and have it (and your name) included with the built-in functions? Please follow the format shown in the module including a description of the arguments and return values for the function as well as an example. Send them to the dbi-dev@perl.org mailing list (see <a href="http://dbi.perl.org">http://dbi.perl.org</a>).</p>

<p>Thanks in advance :-).</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>Dean Arnold supplied DECODE, COALESCE, REPLACE, many thanks! Brendan Byrd added in the Numeric/Trig/System functions and filled in the SQL92/ODBC gaps for the date/string functions.</p>

<h1 id="AUTHOR-COPYRIGHT">AUTHOR &amp; COPYRIGHT</h1>

<p>Copyright (c) 2005 by Jeff Zucker: jzuckerATcpan.org Copyright (c) 2009-2017 by Jens Rehsack: rehsackATcpan.org</p>

<p>All rights reserved.</p>

<p>The module may be freely distributed under the same terms as Perl itself using either the &quot;GPL License&quot; or the &quot;Artistic License&quot; as specified in the Perl README file.</p>


</body>

</html>


