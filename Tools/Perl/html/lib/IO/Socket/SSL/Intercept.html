<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#How-Intercepting-SSL-Works">How Intercepting SSL Works</a></li>
  <li><a href="#METHODS">METHODS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>IO::Socket::SSL::Intercept -- SSL interception (man in the middle)</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    <span class="keyword">use</span> <span class="variable">IO::Socket::SSL::Intercept</span><span class="operator">;</span>
    <span class="comment"># create interceptor with proxy certificates</span>
    <span class="keyword">my</span> <span class="variable">$mitm</span> <span class="operator">=</span> <span class="variable">IO::Socket::SSL::Intercept</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span>
        <span class="string">proxy_cert_file</span> <span class="operator">=&gt;</span> <span class="string">'proxy_cert.pem'</span><span class="operator">,</span>
        <span class="string">proxy_key_file</span>  <span class="operator">=&gt;</span> <span class="string">'proxy_key.pem'</span><span class="operator">,</span>
        <span class="operator">...</span>
    <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$listen</span> <span class="operator">=</span> <span class="variable">IO::Socket::INET</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">LocalAddr</span> <span class="operator">=&gt;</span> <span class="operator">..,</span> <span class="string">Listen</span> <span class="operator">=&gt;</span> <span class="operator">..</span> <span class="operator">);</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># TCP accept new client</span>
        <span class="keyword">my</span> <span class="variable">$client</span> <span class="operator">=</span> <span class="variable">$listen</span><span class="operator">-&gt;</span><span class="variable">accept</span> <span class="keyword">or</span> <span class="keyword">next</span><span class="operator">;</span>
        <span class="comment"># SSL connect to server</span>
        <span class="keyword">my</span> <span class="variable">$server</span> <span class="operator">=</span> <span class="variable">IO::Socket::SSL</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span>
            <span class="string">PeerAddr</span> <span class="operator">=&gt;</span> <span class="operator">..,</span>
            <span class="string">SSL_verify_mode</span> <span class="operator">=&gt;</span> <span class="operator">...,</span>
            <span class="operator">...</span>
        <span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"ssl connect failed: $!,</span><span class="variable">$SSL_ERROR</span><span class="string">"</span><span class="operator">;</span>
        <span class="comment"># clone server certificate</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$cert</span><span class="operator">,</span><span class="variable">$key</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$mitm</span><span class="operator">-&gt;</span><span class="variable">clone_cert</span><span class="operator">(</span> <span class="variable">$server</span><span class="operator">-&gt;</span><span class="variable">peer_certificate</span> <span class="operator">);</span>
        <span class="comment"># and upgrade client side to SSL with cloned certificate</span>
        <span class="variable">IO::Socket::SSL</span><span class="operator">-&gt;</span><span class="variable">start_SSL</span><span class="operator">(</span><span class="variable">$client</span><span class="operator">,</span>
            <span class="string">SSL_server</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
            <span class="string">SSL_cert</span> <span class="operator">=&gt;</span> <span class="variable">$cert</span><span class="operator">,</span>
            <span class="string">SSL_key</span> <span class="operator">=&gt;</span> <span class="variable">$key</span>
        <span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"upgrade failed: </span><span class="variable">$SSL_ERROR</span><span class="string">"</span><span class="operator">;</span>
        <span class="comment"># now transfer data between $client and $server and analyze</span>
        <span class="comment"># the unencrypted data</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides functionality to clone certificates and sign them with a proxy certificate, thus making it easy to intercept SSL connections (man in the middle). It also manages a cache of the generated certificates.</p>

<h1 id="How-Intercepting-SSL-Works">How Intercepting SSL Works</h1>

<p>Intercepting SSL connections is useful for analyzing encrypted traffic for security reasons or for testing. It does not break the end-to-end security of SSL, e.g. a properly written client will notice the interception unless you explicitly configure the client to trust your interceptor. Intercepting SSL works the following way:</p>

<ul>

<li><p>Create a new CA certificate, which will be used to sign the cloned certificates. This proxy CA certificate should be trusted by the client, or (a properly written client) will throw error messages or deny the connections because it detected a man in the middle attack. Due to the way the interception works there no support for client side certificates is possible.</p>

<p>Using openssl such a proxy CA certificate and private key can be created with:</p>

<pre><code>  openssl genrsa -out proxy_key.pem 1024
  openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
  # export as PKCS12 for import into browser
  openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12</code></pre>

</li>
<li><p>Configure client to connect to use intercepting proxy or somehow redirect connections from client to the proxy (e.g. packet filter redirects, ARP or DNS spoofing etc).</p>

</li>
<li><p>Accept the TCP connection from the client, e.g. don&#39;t do any SSL handshakes with the client yet.</p>

</li>
<li><p>Establish the SSL connection to the server and verify the servers certificate as usually. Then create a new certificate based on the original servers certificate, but signed by your proxy CA. This is the step where IO::Socket::SSL::Intercept helps.</p>

</li>
<li><p>Upgrade the TCP connection to the client to SSL using the cloned certificate from the server. If the client trusts your proxy CA it will accept the upgrade to SSL.</p>

</li>
<li><p>Transfer data between client and server. While the connections to client and server are both encrypted with SSL you will read/write the unencrypted data in your proxy application.</p>

</li>
</ul>

<h1 id="METHODS">METHODS</h1>

<p>IO::Socket::SSL::Intercept helps creating the cloned certificate with the following methods:</p>

<dl>

<dt id="mitm-IO::Socket::SSL::Intercept-new-args"><b>$mitm = IO::Socket::SSL::Intercept-&gt;new(%args)</b></dt>
<dd>

<p>This creates a new interceptor object. <code>%args</code> should be</p>

<dl>

<dt id="proxy_cert-X509-proxy_cert_file-filename">proxy_cert X509 | proxy_cert_file filename</dt>
<dd>

<p>This is the proxy certificate. It can be either given by an X509 object from <a href="../../../../lib/Net/SSLeay.html">Net::SSLeay</a>s internal representation, or using a file in PEM format.</p>

</dd>
<dt id="proxy_key-EVP_PKEY-proxy_key_file-filename">proxy_key EVP_PKEY | proxy_key_file filename</dt>
<dd>

<p>This is the key for the proxy certificate. It can be either given by an EVP_PKEY object from <a href="../../../../lib/Net/SSLeay.html">Net::SSLeay</a>s internal representation, or using a file in PEM format. The key should not have a passphrase.</p>

</dd>
<dt id="pubkey-EVP_PKEY-pubkey_file-filename">pubkey EVP_PKEY | pubkey_file filename</dt>
<dd>

<p>This optional argument specifies the public key used for the cloned certificate. It can be either given by an EVP_PKEY object from <a href="../../../../lib/Net/SSLeay.html">Net::SSLeay</a>s internal representation, or using a file in PEM format. If not given it will create a new public key on each call of <code>new</code>.</p>

</dd>
<dt id="serial-INTEGER">serial INTEGER</dt>
<dd>

<p>This optional argument gives the starting point for the serial numbers of the newly created certificates. Default to 1.</p>

</dd>
<dt id="cache-HASH-SUBROUTINE">cache HASH | SUBROUTINE</dt>
<dd>

<p>This optional argument gives a way to cache created certificates, so that they don&#39;t get recreated on future accesses to the same host. If the argument ist not given an internal HASH ist used.</p>

<p>If the argument is a hash it will store for each generated certificate a hash reference with <code>cert</code> and <code>atime</code> in the hash, where <code>atime</code> is the time of last access (to expire unused entries) and <code>cert</code> is the certificate. Please note, that the certificate is in <a href="../../../../lib/Net/SSLeay.html">Net::SSLeay</a>s internal X509 format and can thus not be simply dumped and restored. The key for the hash is an <code>ident</code> either given to <code>clone_cert</code> or generated from the original certificate.</p>

<p>If the argument is a subroutine it will be called as <code>$cache-&gt;(ident)</code> to get an existing (cert,key) and with <code>$cache-&gt;(ident,cert,key)</code> to cache the newly created certificate.</p>

</dd>
</dl>

</dd>
<dt id="clone_cert-key-mitm-clone_cert-original_cert-ident"><b>($clone_cert,$key) = $mitm-&gt;clone_cert($original_cert,[ $ident ])</b></dt>
<dd>

<p>This clones the given certificate. An ident as the key into the cache can be given (like <code>host:port</code>), if not it will be created from the properties of the original certificate. It returns the cloned certificate and its key (which is the same for alle created certificates).</p>

</dd>
<dt id="string-mitm-serialize"><b>$string = $mitm-&gt;serialize</b></dt>
<dd>

<p>This creates a serialized version of the object (e.g. a string) which can then be used to persistantly store created certificates over restarts of the application. The cache will only be serialized if it is a HASH. To work together with <a href="../../../../lib/Storable.html">Storable</a> the <code>STORABLE_freeze</code> function is defined to call <code>serialize</code>.</p>

</dd>
<dt id="mitm-IO::Socket::SSL::Intercept-unserialize-string"><b>$mitm = IO::Socket::SSL::Intercept-&gt;unserialize($string)</b></dt>
<dd>

<p>This restores an Intercept object from a serialized string. To work together with <a href="../../../../lib/Storable.html">Storable</a> the <code>STORABLE_thaw</code> function is defined to call <code>unserialize</code>.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Steffen Ullrich</p>


</body>

</html>


