<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Exports">Exports</a></li>
      <li><a href="#The-Win32API::-hierarchy">The Win32API:: hierarchy</a></li>
      <li><a href="#Buffer-sizes">Buffer sizes</a></li>
      <li><a href="#Hungarian-Notation">Hungarian Notation</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Win32API::Registry - Low-level access to Win32 system API calls from WINREG.H</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  <span class="keyword">use</span> <span class="variable">Win32API::Registry</span> <span class="number">0</span><span class="operator">.</span><span class="number">21</span> <span class="string">qw( :ALL )</span><span class="operator">;</span>
  
  <span class="variable">RegOpenKeyEx</span><span class="operator">(</span> <span class="variable">HKEY_LOCAL_MACHINE</span><span class="operator">,</span> <span class="string">"SYSTEM\\Disk"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">KEY_READ</span><span class="operator">,</span> <span class="variable">$key</span> <span class="operator">)</span>
    <span class="keyword">or</span>  <span class="keyword">die</span> <span class="string">"Can't open HKEY_LOCAL_MACHINE\\SYSTEM\\Disk: "</span><span class="operator">,</span>
            <span class="variable">regLastError</span><span class="operator">(),</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="variable">RegQueryValueEx</span><span class="operator">(</span> <span class="variable">$key</span><span class="operator">,</span> <span class="string">"Information"</span><span class="operator">,</span> <span class="operator">[]</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="operator">[]</span> <span class="operator">)</span>
    <span class="keyword">or</span>  <span class="keyword">die</span> <span class="string">"Can't read HKEY_L*MACHINE\\SYSTEM\\Disk\\Information: "</span><span class="operator">,</span>
            <span class="variable">regLastError</span><span class="operator">(),</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">[</span><span class="operator">...</span><span class="operator">]</span>
  <span class="variable">RegCloseKey</span><span class="operator">(</span> <span class="variable">$key</span> <span class="operator">)</span>
    <span class="keyword">or</span>  <span class="keyword">die</span> <span class="string">"Can't close HKEY_LOCAL_MACHINE\\SYSTEM\\Disk: "</span><span class="operator">,</span>
            <span class="variable">regLastError</span><span class="operator">(),</span><span class="string">"\n"</span><span class="operator">;</span>
</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This provides fairly low-level access to the Win32 System API calls dealing with the Registry [mostly from WINREG.H]. This is mostly intended to be used by other modules such as <code>Win32::TieRegistry</code> [which provides an extremely Perl-friendly method for using the Registry].</p>

<p>For a description of the logical structure of the Registry, see the documentation for the <code>Win32::TieRegistry</code> module.</p>

<p>To pass in <code>NULL</code> as the pointer to an optional buffer, pass in an empty list reference, <code>[]</code>.</p>

<p>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</p>

<p>All calls return a true value for success and a false value for failure. After any failure, <code>$^E</code> should automatically be set to indicate the reason. However, current versions of Perl often overwrite <code>$^E</code> too quickly, so you can use <code>regLastError()</code> instead, which is only set by Win32API::Registry routines. <code>regLastError()</code> is also good if you have a really old version of Perl that does not connect <code>$^E</code> to <code>GetLastError()</code> on Win32.</p>

<p>Note that <code>$!</code> is not set by these routines except by <code>Win32API::Registry::constant()</code> when a constant is not defined.</p>

<h2 id="Exports">Exports</h2>

<p>Nothing is exported by default. The following tags can be used to have sets of symbols exported.</p>

<p>[Note that much of the following documentation refers to the behavior of the underlying API calls which may vary in current and future versions of the Win32 API without any changes to this module. Therefore you should check the Win32 API documentation directly when needed.]</p>

<dl>

<dt id="Func">:Func</dt>
<dd>

<p>The basic function names:</p>

<dl>

<dt id="AllowPriv">AllowPriv</dt>
<dd>

</dd>
<dt id="AllowPriv-sPrivName-bEnable"><code>AllowPriv( $sPrivName, $bEnable )</code></dt>
<dd>

<p>Not a Win32 API call. Enables or disables a specific privilege for the current process. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure. This routine does not provide a way to tell if a privilege is currently enabled.</p>

<p><code>$sPrivname</code> is a Win32 privilege name [see <a href="#SE_">&quot;:SE_&quot;</a>]. For example, <code>&quot;SeBackupPrivilege&quot;</code> [a.k.a. <code>SE_BACKUP_NAME</code>] controls whether you can use <code>RegSaveKey()</code> and <code>&quot;SeRestorePrivilege&quot;</code> [a.k.a. <code>SE_RESTORE_NAME</code>] controls whether you can use <code>RegLoadKey()</code>.</p>

<p>If <code>$bEnable</code> is true, then <code>AllowPriv()</code> tries to enable the privilege. Otherwise it tries to disable the privilege.</p>

</dd>
<dt id="AbortSystemShutdown">AbortSystemShutdown</dt>
<dd>

</dd>
<dt id="AbortSystemShutdown-sComputerName"><code>AbortSystemShutdown( $sComputerName )</code></dt>
<dd>

<p>Tries to abort a remote shutdown request previously made via <code>InitiateSystemShutdown()</code>. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

</dd>
<dt id="InitiateSystemShutdown">InitiateSystemShutdown</dt>
<dd>

</dd>
<dt id="InitiateSystemShutdown-sComputer-sMessage-uTimeoutSecs-bForce-bReboot"><code>InitiateSystemShutdown( $sComputer, $sMessage, $uTimeoutSecs, $bForce, $bReboot )</code></dt>
<dd>

<p>Requests that a [remote] computer be shutdown or rebooted. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$sComputer</code> is the name [or address] of the computer to be shutdown or rebooted. You can use <code>[]</code> [for <code>NULL</code>] or <code>&quot;&quot;</code> to indicate the local computer.</p>

<p><code>$sMessage</code> is the message to be displayed in a pop-up window on the desktop of the computer to be shutdown or rebooted until the timeout expires or the shutdown is aborted via <code>AbortSystemShutdown()</code>. With <code>$iTimeoutSecs == 0</code>, the message will never be visible.</p>

<p><code>$iTimeoutSecs</code> is the number of seconds to wait before starting the shutdown.</p>

<p>If <code>$bForce</code> is false, then any applications running on the remote computer get a chance to prompt the remote user whether they want to save changes. Also, for any applications that do not exit quickly enough, the operating system will prompt the user whether they wish to wait longer for the application to exit or force it to exit now. At any of these prompts the user can press <b>CANCEL</b> to abort the shutdown but if no applications have unsaved data, they will likely all exit quickly and the shutdown will progress with the remote user having no option to cancel the shutdown.</p>

<p>If <code>$bForce</code> is true, all applications are told to exit immediately and so will not prompt the user even if there is unsaved data. Any applications that take too long to exit will be forcibly killed after a short time. The only way to abort the shutdown is to call <code>AbortSystemShutdown()</code> before the timeout expires and there is no way to abort the shutdown once it has begun.</p>

<p>If <code>$bReboot</code> is true, the computer will automatically reboot once the shutdown is complete. If <code>$bReboot</code> is false, then when the shutdown is complete the computer will halt at a screen indicating that the shutdown is complete and offering a way for the user to start to boot the computer.</p>

<p>You must have the <code>&quot;SeRemoteShutdownPrivilege&quot;</code> privilege on the remote computer for this call to succeed. If shutting down the local computer, then the calling process must have the <code>&quot;SeShutdownPrivilege&quot;</code> privilege and have it enabled.</p>

</dd>
<dt id="RegCloseKey">RegCloseKey</dt>
<dd>

</dd>
<dt id="RegCloseKey-hKey"><code>RegCloseKey( $hKey )</code></dt>
<dd>

<p>Closes the handle to a Registry key returned by <code>RegOpenKeyEx()</code>, <code>RegConnectRegistry()</code>, <code>RegCreateKeyEx()</code>, or a few other routines. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

</dd>
<dt id="RegConnectRegistry">RegConnectRegistry</dt>
<dd>

</dd>
<dt id="RegConnectRegistry-sComputer-hRootKey-ohKey"><code>RegConnectRegistry( $sComputer, $hRootKey, $ohKey )</code></dt>
<dd>

<p>Connects to one of the root Registry keys of a remote computer. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$sComputer</code> is the name [or address] of a remote computer whose Registry you wish to access.</p>

<p><code>$hKey</code> must be either <code>HKEY_LOCAL_MACHINE</code> or <code>HKEY_USERS</code> and specifies which root Registry key on the remote computer you wish to have access to.</p>

<p><code>$phKey</code> will be set to the handle to be used to access the remote Registry key if the call succeeds.</p>

</dd>
<dt id="regConstant">regConstant</dt>
<dd>

</dd>
<dt id="value-regConstant-sConstantName"><code>$value= regConstant( $sConstantName )</code></dt>
<dd>

<p>Fetch the value of a constant. Returns <code>undef</code> if <code>$sConstantName</code> is not the name of a constant supported by this module. Never sets <code>$!</code> nor <code>$^E</code>.</p>

<p>This function is rarely used since you will usually get the value of a constant by having that constant imported into your package by listing the constant name in the <code>use Win32API::Registry</code> statement and then simply using the constant name in your code [perhaps followed by <code>()</code>]. This function is useful for verifying constant names not in Perl code, for example, after prompting a user to type in a constant name.</p>

</dd>
<dt id="RegCreateKey">RegCreateKey</dt>
<dd>

</dd>
<dt id="RegCreateKey-hKey-sSubKey-ohSubKey"><code>RegCreateKey( $hKey, $sSubKey, $ohSubKey )</code></dt>
<dd>

<p>This routine is meant only for compatibility with Windows version 3.1. Use <code>RegCreateKeyEx()</code> instead.</p>

</dd>
<dt id="RegCreateKeyEx">RegCreateKeyEx</dt>
<dd>

</dd>
<dt id="RegCreateKeyEx-hKey-sSubKey-uZero-sClass-uOpts-uAccess-pSecAttr-ohNewKey-ouDisp"><code>RegCreateKeyEx( $hKey, $sSubKey, $uZero, $sClass, $uOpts, $uAccess, $pSecAttr, $ohNewKey, $ouDisp )</code></dt>
<dd>

<p>Creates a new Registry subkey. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sSubKey</code> is the name of the new subkey to be created.</p>

<p><code>$iZero</code> is reserved for future use and should always be specified as <code>0</code>.</p>

<p><code>$sClass</code> is a string to be used as the class for the new subkey. We are not aware of any current use for Registry key class information so the empty string, <code>&quot;&quot;</code>, should usually be used here.</p>

<p><code>$iOpts</code> is a numeric value containing bits that control options used while creating the new subkey. <code>REG_OPTION_NON_VOLATILE</code> is the default. <code>REG_OPTION_VOLATILE</code> [which is ignored on Windows 95] means the data stored under this key is not kept in a file and will not be preserved when the system reboots. <code>REG_OPTION_BACKUP_RESTORE</code> [also ignored on Windows 95] means ignore the <code>$iAccess</code> parameter and try to open the new key with the access required to backup or restore the key.</p>

<p><code>$iAccess</code> is a numeric mask of bits specifying what type of access is desired when opening the new subkey. See <code>RegOpenKeyEx()</code>.</p>

<p><code>$pSecAttr</code> is a <code>SECURITY_ATTRIBUTES</code> structure packed into a Perl string which controls whether the returned handle can be inherited by child processes. Normally you would pass <code>[]</code> for this parameter to have <code>NULL</code> passed to the underlying API indicating that the handle cannot be inherited. If not under Windows95, then <code>$pSecAttr</code> also allows you to specify <code>SECURITY_DESCRIPTOR</code> that controls which users will have what type of access to the new key -- otherwise the new key inherits its security from its parent key.</p>

<p><code>$phKey</code> will be set to the handle to be used to access the new subkey if the call succeeds.</p>

<p><code>$piDisp</code> will be set to either <code>REG_CREATED_NEW_KEY</code> or <code>REG_OPENED_EXISTING_KEY</code> to indicate for which reason the call succeeded. Can be specified as <code>[]</code> if you don&#39;t care.</p>

<p>If <code>$phKey</code> and <code>$piDisp</code> start out as integers, then they will probably remain unchanged if the call fails.</p>

</dd>
<dt id="RegDeleteKey">RegDeleteKey</dt>
<dd>

</dd>
<dt id="RegDeleteKey-hKey-sSubKey"><code>RegDeleteKey( $hKey, $sSubKey )</code></dt>
<dd>

<p>Deletes a subkey of an open Registry key provided that the subkey contains no subkeys of its own [but the subkey may contain values]. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sSubKey</code> is the name of the subkey to be deleted.</p>

</dd>
<dt id="RegDeleteValue">RegDeleteValue</dt>
<dd>

</dd>
<dt id="RegDeleteValue-hKey-sValueName"><code>RegDeleteValue( $hKey, $sValueName )</code></dt>
<dd>

<p>Deletes a value from an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sValueKey</code> is the name of the value to be deleted.</p>

</dd>
<dt id="RegEnumKey">RegEnumKey</dt>
<dd>

</dd>
<dt id="RegEnumKey-hKey-uIndex-osName-ilNameSize"><code>RegEnumKey( $hKey, $uIndex, $osName, $ilNameSize )</code></dt>
<dd>

<p>This routine is meant only for compatibility with Windows version 3.1. Use <code>RegEnumKeyEx()</code> instead.</p>

</dd>
<dt id="RegEnumKeyEx">RegEnumKeyEx</dt>
<dd>

</dd>
<dt id="RegEnumKeyEx-hKey-uIndex-osName-iolName-pNull-osClass-iolClass-opftLastWrite"><code>RegEnumKeyEx( $hKey, $uIndex, $osName, $iolName, $pNull, $osClass, $iolClass, $opftLastWrite )</code></dt>
<dd>

<p>Lets you enumerate the names of all of the subkeys directly under an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$iIndex</code> is the sequence number of the immediate subkey that you want information on. Start with this value as <code>0</code> then repeat the call incrementing this value each time until the call fails with <code>$^E</code>/<code>regLastError()</code> numerically equal to <code>ERROR_NO_MORE_ITEMS</code>.</p>

<p><code>$sName</code> will be set to the name of the subkey. Can be <code>[]</code> if you don&#39;t care about the name.</p>

<p><code>$plName</code> initially specifies the [minimum] buffer size to be allocated for <code>$sName</code>. Will be set to the length of the subkey name if the requested subkey exists even if <code>$sName</code> isn&#39;t successfully set to the subkey name. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information.</p>

<p><code>$pNull</code> is reserved for future used and should be passed as <code>[]</code>.</p>

<p><code>$sClass</code> will be set to the class name for the subkey. Can be <code>[]</code> if you don&#39;t care about the class.</p>

<p><code>$plClass</code> initially specifies the [minimum] buffer size to be allocated for <code>$sClass</code> and will be set to the length of the subkey class name if the requested subkey exists. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information.</p>

<p><code>$pftLastWrite</code> will be set to a <code>FILETIME</code> structure packed into a Perl string and indicating when the subkey was last changed. Can be <code>[]</code>.</p>

<p>You may omit both <code>$plName</code> and <code>$plClass</code> to get the same effect as passing in <code>[]</code> for each of them.</p>

</dd>
<dt id="RegEnumValue">RegEnumValue</dt>
<dd>

</dd>
<dt id="RegEnumValue-hKey-uIndex-osValName-iolValName-pNull-ouType-opValData-iolValData"><code>RegEnumValue( $hKey, $uIndex, $osValName, $iolValName, $pNull, $ouType, $opValData, $iolValData )</code></dt>
<dd>

<p>Lets you enumerate the names of all of the values contained in an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$iIndex</code> is the sequence number of the value that you want information on. Start with this value as <code>0</code> then repeat the call incrementing this value each time until the call fails with <code>ERROR_NO_MORE_ITEMS</code>.</p>

<p><code>$sValName</code> will be set to the name of the value. Can be <code>[]</code> if you don&#39;t care about the name.</p>

<p><code>$plValName</code> initially specifies the [minimum] buffer size to be allocated for <code>$sValName</code>. Will be set to the length of the value name if the requested value exists even if <code>$sValName</code> isn&#39;t successfully set to the value name. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information.</p>

<p><code>$pNull</code> is reserved for future used and should be passed as <code>[]</code>.</p>

<p><code>$piType</code> will be set to the type of data stored in the value data. If the call succeeds, it will be set to a <code>REG_*</code> value unless passed in as <code>[]</code>.</p>

<p><code>$pValData</code> will be set to the data [packed into a Perl string] that is stored in the requested value. Can be <code>[]</code> if you don&#39;t care about the value data.</p>

<p><code>$plValData</code> initially specifies the [minimum] buffer size to be allocated for <code>$sValData</code> and will be set to the length of the value data if the requested value exists. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information.</p>

<p>You may omit both <code>$plValName</code> and <code>$plValData</code> to get the same effect as passing in <code>[]</code> for each of them.</p>

</dd>
<dt id="RegFlushKey">RegFlushKey</dt>
<dd>

</dd>
<dt id="RegFlushKey-hKey"><code>RegFlushKey( $hKey )</code></dt>
<dd>

<p>Forces the data stored under an open Registry key to be flushed to the disk file where the data is preserved between reboots. Forced flushing is not guaranteed to be efficient so this routine should almost never be called. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

</dd>
<dt id="RegGetKeySecurity">RegGetKeySecurity</dt>
<dd>

</dd>
<dt id="RegGetKeySecurity-hKey-uSecInfo-opSecDesc-iolSecDesc"><code>RegGetKeySecurity( $hKey, $uSecInfo, $opSecDesc, $iolSecDesc )</code></dt>
<dd>

<p>Retrieves one of the <code>SECURITY_DESCRIPTOR</code> structures describing part of the security for an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$iSecInfo</code> is a numeric <code>SECURITY_INFORMATION</code> value that specifies which parts of the <code>SECURITY_DESCRIPTOR</code> structure to retrieve. Should be <code>OWNER_SECURITY_INFORMATION</code>, <code>GROUP_SECURITY_INFORMATION</code>, <code>DACL_SECURITY_INFORMATION</code>, or or <code>SACL_SECURITY_INFORMATION</code> or two or more of these bits combined using <code>|</code>.</p>

<p><code>$pSecDesc</code> will be set to the requested <code>SECURITY_DESCRIPTOR</code> structure [packed into a Perl string].</p>

<p><code>$plSecDesc</code> initially specifies the [minimum] buffer size to be allocated for <code>$sSecDesc</code> and will be set to the length of the security descriptor. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information. You may omit this parameter to get the same effect as passing in <code>[]</code> for it.</p>

</dd>
<dt id="regLastError">regLastError</dt>
<dd>

</dd>
<dt id="svError-regLastError"><code><span class="variable">$svError</span><span class="operator">=</span> <span class="variable">regLastError</span><span class="operator">();</span>
</code></dt>
<dd>

</dd>
<dt id="regLastError-uError"><code><span class="variable">regLastError</span><span class="operator">(</span> <span class="variable">$uError</span> <span class="operator">);</span>
</code></dt>
<dd>

<p>Returns the last error encountered by a routine from this module. It is just like <code>$^E</code> except it isn&#39;t changed by anything except routines from this module. Ideally you could just use <code>$^E</code>, but current versions of Perl often overwrite <code>$^E</code> before you get a chance to check it and really old versions of Perl don&#39;t really support <code>$^E</code> under Win32.</p>

<p>Just like <code>$^E</code>, in a numeric context <code>regLastError()</code> returns the numeric error value while in a string context it returns a text description of the error [actually it returns a Perl scalar that contains both values so <code>$x= regLastError()</code> causes <code>$x</code> to give different values in string vs. numeric contexts]. On old versions of Perl where <code>$^E</code> isn&#39;t tied to <code>GetLastError()</code>, <code>regLastError</code> simply returns the number of the error and you&#39;ll need to use &lt;Win32::FormatMessage&gt; to get the error string.</p>

<p>The last form sets the error returned by future calls to <code>regLastError()</code> and should not be used often. <code>$uError</code> must be a numeric error code. Also returns the dual-valued version of <code>$uError</code>.</p>

</dd>
<dt id="RegLoadKey">RegLoadKey</dt>
<dd>

</dd>
<dt id="RegLoadKey-hKey-sSubKey-sFileName"><code>RegLoadKey( $hKey, $sSubKey, $sFileName )</code></dt>
<dd>

<p>Loads a hive file. That is, it creates a new subkey in the Registry and associates that subkey with a disk file that contains a Registry hive so that the new subkey can be used to access the keys and values stored in that hive. Hives are usually created via <code>RegSaveKey()</code>. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key that can have hives loaded to it. This must be <code>HKEY_LOCAL_MACHINE</code>, <code>HKEY_USERS</code>, or a remote version of one of these from a call to <code>RegConnectRegistry()</code>.</p>

<p><code>$sSubKey</code> is the name of the new subkey to created and associated with the hive file.</p>

<p><code>$sFileName</code> is the name of the hive file to be loaded. This file name is interpreted relative to the <code>%SystemRoot%/System32/config</code> directory on the computer where the <code>$hKey</code> key resides. If <code>$sFileName</code> is on a FAT file system, then its name must not have an extension.</p>

<p>You must have the <code>SE_RESTORE_NAME</code> privilege to use this routine.</p>

<p>WARNING: Loading of hive files via a network share may silently corrupt the hive and so should not be attempted [this is a problem in at least some versions of the underlying API which this module does not try to fix or avoid]. To access a hive file located on a remote computer, connect to the remote computer&#39;s Registry and load the hive via that.</p>

</dd>
<dt id="RegNotifyChangeKeyValue">RegNotifyChangeKeyValue</dt>
<dd>

</dd>
<dt id="RegNotifyChangeKeyValue-hKey-bWatchSubtree-uNotifyFilter-hEvent-bAsync"><code>RegNotifyChangeKeyValue( $hKey, $bWatchSubtree, $uNotifyFilter, $hEvent, $bAsync )</code></dt>
<dd>

<p>Arranges for your process to be notified when part of the Registry is changed. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call] for which you wish to be notified when any changes are made to it.</p>

<p>If <code>$bWatchSubtree</code> is true, then changes to any subkey or descendant of <code>$hKey</code> are also reported.</p>

<p><code>$iNotifyFilter</code> controllers what types of changes are reported. It is a numeric value containing one or more of the following bit masks:</p>

<dl>

<dt id="REG_NOTIFY_CHANGE_NAME"><code>REG_NOTIFY_CHANGE_NAME</code></dt>
<dd>

<p>Notify if a subkey is added or deleted to a monitored key.</p>

</dd>
<dt id="REG_NOTIFY_CHANGE_LAST_SET"><code>REG_NOTIFY_CHANGE_LAST_SET</code></dt>
<dd>

<p>Notify if a value in a monitored key is added, deleted, or modified.</p>

</dd>
<dt id="REG_NOTIFY_CHANGE_SECURITY"><code>REG_NOTIFY_CHANGE_SECURITY</code></dt>
<dd>

<p>Notify if a security descriptor of a monitored key is changed.</p>

</dd>
<dt id="REG_NOTIFY_CHANGE_ATTRIBUTES"><code>REG_NOTIFY_CHANGE_ATTRIBUTES</code></dt>
<dd>

<p>Notify if any attributes of a monitored key are changed [class name or security descriptors].</p>

</dd>
</dl>

<p><code>$hEvent</code> is ignored unless <code>$bAsync</code> is true. Otherwise, <code>$hEvent</code> is a handle to a Win32 <i>event</i> that will be signaled when changes are to be reported.</p>

<p>If <code>$bAsync</code> is true, then <code>RegNotifyChangeKeyValue()</code> returns immediately and uses <code>$hEvent</code> to notify your process of changes. If <code>$bAsync</code> is false, then <code>RegNotifyChangeKeyValue()</code> does not return until there is a change to be notified of.</p>

<p>This routine does not work with Registry keys on remote computers.</p>

</dd>
<dt id="RegOpenKey">RegOpenKey</dt>
<dd>

</dd>
<dt id="RegOpenKey-hKey-sSubKey-ohSubKey"><code>RegOpenKey( $hKey, $sSubKey, $ohSubKey )</code></dt>
<dd>

<p>This routine is meant only for compatibility with Windows version 3.1. Use <code>RegOpenKeyEx()</code> instead.</p>

</dd>
<dt id="RegOpenKeyEx">RegOpenKeyEx</dt>
<dd>

</dd>
<dt id="RegOpenKeyEx-hKey-sSubKey-uOptions-uAccess-ohSubKey"><code>RegOpenKeyEx( $hKey, $sSubKey, $uOptions, $uAccess, $ohSubKey )</code></dt>
<dd>

<p>Opens an existing Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sSubKey</code> is the name of an existing subkey to be opened. Can be <code>&quot;&quot;</code> or <code>[]</code> to open an additional handle to the key specified by <code>$hKey</code>.</p>

<p><code>$iOptions</code> is a numeric value containing bits that control options used while opening the subkey. There are currently no supported options so this parameter should be specified as <code>0</code>.</p>

<p><code>$iAccess</code> is a numeric mask of bits specifying what type of access is desired when opening the new subkey. Should be a combination of one or more of the following bit masks:</p>

<dl>

<dt id="KEY_ALL_ACCESS"><code>KEY_ALL_ACCESS</code></dt>
<dd>

<pre><code>    KEY_READ | KEY_WRITE | KEY_CREATE_LINK</code></pre>

</dd>
<dt id="KEY_READ"><code>KEY_READ</code></dt>
<dd>

<pre><code>    KEY_QUERY_VALUE | KEY_ENUMERATE_SUBKEYS | KEY_NOTIFY | STANDARD_RIGHTS_READ</code></pre>

</dd>
<dt id="KEY_WRITE"><code>KEY_WRITE</code></dt>
<dd>

<pre><code>    KEY_SET_VALUE | KEY_CREATE_SUB_KEY | STANDARD_RIGHTS_WRITE</code></pre>

</dd>
<dt id="KEY_QUERY_VALUE"><code>KEY_QUERY_VALUE</code></dt>
<dd>

</dd>
<dt id="KEY_SET_VALUE"><code>KEY_SET_VALUE</code></dt>
<dd>

</dd>
<dt id="KEY_ENUMERATE_SUB_KEYS"><code>KEY_ENUMERATE_SUB_KEYS</code></dt>
<dd>

</dd>
<dt id="KEY_CREATE_SUB_KEY"><code>KEY_CREATE_SUB_KEY</code></dt>
<dd>

</dd>
<dt id="KEY_NOTIFY"><code>KEY_NOTIFY</code></dt>
<dd>

<p>Allows you to use <code>RegNotifyChangeKeyValue()</code> on the opened key.</p>

</dd>
<dt id="KEY_EXECUTE"><code>KEY_EXECUTE</code></dt>
<dd>

<p>Same as <code>KEY_READ</code>.</p>

</dd>
<dt id="KEY_CREATE_LINK"><code>KEY_CREATE_LINK</code></dt>
<dd>

<p>Gives you permission to create a symbolic link like <code>HKEY_CLASSES_ROOT</code> and <code>HKEY_CURRENT_USER</code>, though the method for doing so is not documented [and probably requires use of the mostly undocumented &quot;native&quot; routines, <code>Nt*()</code> a.k.a. <code>Zw*()</code>].</p>

</dd>
</dl>

<p><code>$phKey</code> will be set to the handle to be used to access the new subkey if the call succeeds.</p>

</dd>
<dt id="RegQueryInfoKey">RegQueryInfoKey</dt>
<dd>

</dd>
<dt id="RegQueryInfoKey-hKey-osClass-iolClass-pNull-ocSubKeys-olSubKey-olSubClass-ocValues-olValName-olValData-olSecDesc-opftTime"><code>RegQueryInfoKey( $hKey, $osClass, $iolClass, $pNull, $ocSubKeys, $olSubKey, $olSubClass, $ocValues, $olValName, $olValData, $olSecDesc, $opftTime )</code></dt>
<dd>

<p>Gets miscellaneous information about an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sClass</code> will be set to the class name for the key. Can be <code>[]</code> if you don&#39;t care about the class.</p>

<p><code>$plClass</code> initially specifies the [minimum] buffer size to be allocated for <code>$sClass</code> and will be set to the length of the key&#39;s class name. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information. You may omit this parameter to get the same effect as passing in <code>[]</code> for it.</p>

<p><code>$pNull</code> is reserved for future use and should be passed as <code>[]</code>.</p>

<p><code>$pcSubKeys</code> will be set to the count of the number of subkeys directly under this key. Can be <code>[]</code>.</p>

<p><code>$plSubKey</code> will be set to the length of the longest subkey name. Can be <code>[]</code>.</p>

<p><code>$plSubClass</code> will be set to the length of the longest class name used with an immediate subkey of this key. Can be <code>[]</code>.</p>

<p><code>$pcValues</code> will be set to the count of the number of values in this key. Can be <code>[]</code>.</p>

<p><code>$plValName</code> will be set to the length of the longest value name in this key. Can be <code>[]</code>.</p>

<p><code>$plValData</code> will be set to the length of the longest value data in this key. Can be <code>[]</code>.</p>

<p><code>$plSecDesc</code> will be set to the length of this key&#39;s full security descriptor.</p>

<p><code>$pftTime</code> will be set to a <code>FILETIME</code> structure packed into a Perl string and indicating when this key was last changed. Can be <code>[]</code>.</p>

</dd>
<dt id="RegQueryMultipleValues">RegQueryMultipleValues</dt>
<dd>

</dd>
<dt id="RegQueryMultipleValues-hKey-ioarValueEnts-icValueEnts-opBuffer-iolBuffer"><code>RegQueryMultipleValues( $hKey, $ioarValueEnts, $icValueEnts, $opBuffer, $iolBuffer )</code></dt>
<dd>

<p>Allows you to use a single call to query several values from a single open Registry key to maximize efficiency. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$pValueEnts</code> should contain a list of <code>VALENT</code> structures packed into a single Perl string. Each <code>VALENT</code> structure should have the <code>ve_valuename</code> entry [the first 4 bytes] pointing to a string containing the name of a value stored in this key. The remaining fields are set if the function succeeds.</p>

<p><code>$cValueEnts</code> should contain the count of the number of <code>VALENT</code> structures contained in <code>$pValueEnts</code>.</p>

<p><code>$pBuffer</code> will be set to the data from all of the requested values concatenated into a single Perl string.</p>

<p><code>$plBuffer</code> initially specifies the [minimum] buffer size to be allocated for <code>$sBuffer</code> and will be set to the total length of the data to be written to <code>$sBuffer</code>. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information. You may omit this parameter to get the same effect as passing in <code>[]</code> for it.</p>

<p>Here is sample code to populate <code>$pValueEnts</code>:</p>

<pre><code>    <span class="comment"># @ValueNames= ...list of value name strings...;</span>
    <span class="variable">$cValueEnts</span><span class="operator">=</span> <span class="variable">@ValueNames</span><span class="operator">;</span>
    <span class="variable">$pValueEnts</span><span class="operator">=</span> <span class="keyword">pack</span><span class="operator">(</span> <span class="string">" p x4 x4 x4 "</span> <span class="operator">x</span> <span class="variable">$cValueEnts</span><span class="operator">,</span> <span class="variable">@ValueNames</span> <span class="operator">);</span>
</code></pre>

<p>Here is sample code to retrieve the data type and data length returned in <code>$pValueEnts</code>:</p>

<pre><code>    <span class="variable">@Lengths</span><span class="operator">=</span> <span class="keyword">unpack</span><span class="operator">(</span> <span class="string">" x4 L x4 x4 "</span> <span class="operator">x</span> <span class="variable">$cValueEnts</span><span class="operator">,</span> <span class="variable">$pValueEnts</span> <span class="operator">);</span>
    <span class="variable">@Types</span><span class="operator">=</span>   <span class="keyword">unpack</span><span class="operator">(</span> <span class="string">" x4 x4 x4 L "</span> <span class="operator">x</span> <span class="variable">$cValueEnts</span><span class="operator">,</span> <span class="variable">$pValueEnts</span> <span class="operator">);</span>
</code></pre>

<p>Given the above, and assuming you haven&#39;t modified <code>$sBuffer</code> since the call, you can also extract the value data strings from <code>$sBuffer</code> by using the pointers returned in <code>$pValueEnts</code>:</p>

<pre><code>    <span class="variable">@Data</span><span class="operator">=</span>    <span class="keyword">unpack</span><span class="operator">(</span>  <span class="keyword">join</span><span class="operator">(</span> <span class="string">""</span><span class="operator">,</span> <span class="keyword">map</span> <span class="operator">{</span><span class="string">" x4 x4 P</span><span class="variable">$_</span><span class="string"> x4 "</span><span class="operator">}</span> <span class="variable">@Lengths</span> <span class="operator">),</span>
                <span class="variable">$pValueEnts</span>  <span class="operator">);</span>
</code></pre>

<p>Much better is to use the lengths and extract directly from <code>$sBuffer</code> using <code>unpack()</code> [or <code>substr()</code>]:</p>

<pre><code>    <span class="variable">@Data</span><span class="operator">=</span> <span class="keyword">unpack</span><span class="operator">(</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="keyword">map</span><span class="operator">(</span><span class="string">"P</span><span class="variable">$_</span><span class="string">"</span><span class="operator">,</span><span class="variable">@Lengths</span><span class="operator">)),</span> <span class="variable">$sBuffer</span> <span class="operator">);</span>
</code></pre>

</dd>
<dt id="RegQueryValue">RegQueryValue</dt>
<dd>

</dd>
<dt id="RegQueryValue-hKey-sSubKey-osValueData-iolValueData"><code>RegQueryValue( $hKey, $sSubKey, $osValueData, $iolValueData )</code></dt>
<dd>

<p>This routine is meant only for compatibility with Windows version 3.1. Use <code>RegQueryValueEx()</code> instead. This routine can only query unnamed values [a.k.a. &quot;default values&quot;], that is, values with a name of <code>&quot;&quot;</code>.</p>

</dd>
<dt id="RegQueryValueEx">RegQueryValueEx</dt>
<dd>

</dd>
<dt id="RegQueryValueEx-hKey-sValueName-pNull-ouType-opValueData-iolValueData"><code>RegQueryValueEx( $hKey, $sValueName, $pNull, $ouType, $opValueData, $iolValueData )</code></dt>
<dd>

<p>Lets you look up value data stored in an open Registry key by specifying the value name. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sValueName</code> is the name of the value whose data you wish to retrieve.</p>

<p><code>$pNull</code> this parameter is reserved for future use and should be specified as <code>[]</code>.</p>

<p><code>$piType</code> will be set to indicate what type of data is stored in the named value. Will be set to a <code>REG_*</code> value if the function succeeds.</p>

<p><code>$pValueData</code> will be set to the value data [packed into a Perl string] that is stored in the named value. Can be <code>[]</code> if you don&#39;t care about the value data.</p>

<p><code>$plValueData</code> initially specifies the [minimum] buffer size to be allocated for <code>$sValueData</code> and will be set to the size [always in bytes] of the data to be written to <code>$sValueData</code>, even if <code>$sValueData</code> is not successfully written to. See <a href="#Buffer-sizes">&quot;Buffer sizes&quot;</a> for more information.</p>

</dd>
<dt id="RegReplaceKey">RegReplaceKey</dt>
<dd>

</dd>
<dt id="RegReplaceKey-hKey-sSubKey-sNewFile-sOldFile"><code>RegReplaceKey( $hKey, $sSubKey, $sNewFile, $sOldFile )</code></dt>
<dd>

<p>Lets you replace an entire hive when the system is next booted. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key that has hive(s) loaded in it. This must be <code>HKEY_LOCAL_MACHINE</code>, <code>HKEY_USERS</code>, or a remote version of one of these from a call to <code>RegConnectRegistry()</code>.</p>

<p><code>$sSubKey</code> is the name of the subkey of <code>$hKey</code> whose hive you wish to have replaced on the next reboot.</p>

<p><code>$sNewFile</code> is the name of a file that will replace the existing hive file when the system reboots.</p>

<p><code>$sOldFile</code> is the file name to save the current hive file to when the system reboots.</p>

<p><code>$sNewFile</code> and <code>$sOldFile</code> are interpreted relative to the <code>%SystemRoot%/System32/config</code> directory on the computer where the <code>$hKey</code> key resides [I think]. If either file is [would be] on a FAT file system, then its name must not have an extension.</p>

<p>You must have the <code>SE_RESTORE_NAME</code> privilege to use this routine.</p>

</dd>
<dt id="RegRestoreKey">RegRestoreKey</dt>
<dd>

</dd>
<dt id="RegRestoreKey-hKey-sFileName-uFlags"><code>RegRestoreKey( $hKey, $sFileName, $uFlags )</code></dt>
<dd>

<p>Reads in a hive file and copies its contents over an existing Registry tree. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sFileName</code> is the name of the hive file to be read. For each value and subkey in this file, a value or subkey will be added or replaced in <code>$hKey</code>.</p>

<p><code>$uFlags</code> is usually <code>0</code>. It can also be <code>REG_WHOLE_HIVE_VOLATILE</code> which, rather than copying the hive over the existing key, replaces the existing key with a temporary, memory-only Registry key and then copies the hive contents into it. This option only works if <code>$hKey</code> is <code>HKEY_LOCAL_MACHINE</code>, <code>HKEY_USERS</code>, or a remote version of one of these from a call to <code>RegConnectRegistry()</code>.</p>

<p><code>RegRestoreKey</code> does <i>not</i> delete values nor keys from the existing Registry tree when there is no corresponding value/key in the hive file.</p>

</dd>
<dt id="RegSaveKey">RegSaveKey</dt>
<dd>

</dd>
<dt id="RegSaveKey-hKey-sFileName-pSecAttr"><code>RegSaveKey( $hKey, $sFileName, $pSecAttr )</code></dt>
<dd>

<p>Dumps any open Registry key and all of its subkeys and values into a new hive file. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sFileName</code> is the name of the file that the Registry tree should be saved to. It is interpreted relative to the <code>%SystemRoot%/System32/config</code> directory on the computer where the <code>$hKey</code> key resides. If <code>$sFileName</code> is on a FAT file system, then it must not have an extension.</p>

<p><code>$pSecAttr</code> contains a <code>SECURITY_ATTRIBUTES</code> structure that specifies the permissions to be set on the new file that is created. This can be <code>[]</code>.</p>

<p>You must have the <code>SE_RESTORE_NAME</code> privilege to use this routine.</p>

</dd>
<dt id="RegSetKeySecurity">RegSetKeySecurity</dt>
<dd>

</dd>
<dt id="RegSetKeySecurity-hKey-uSecInfo-pSecDesc"><code>RegSetKeySecurity( $hKey, $uSecInfo, $pSecDesc )</code></dt>
<dd>

<p>Sets [part of] the <code>SECURITY_DESCRIPTOR</code> structure describing part of the security for an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$uSecInfo</code> is a numeric <code>SECURITY_INFORMATION</code> value that specifies which <code>SECURITY_DESCRIPTOR</code> structure to set. Should be <code>OWNER_SECURITY_INFORMATION</code>, <code>GROUP_SECURITY_INFORMATION</code>, <code>DACL_SECURITY_INFORMATION</code>, or <code>SACL_SECURITY_INFORMATION</code> or two or more of these bits combined using <code>|</code>.</p>

<p><code>$pSecDesc</code> contains the new <code>SECURITY_DESCRIPTOR</code> structure packed into a Perl string.</p>

</dd>
<dt id="RegSetValue">RegSetValue</dt>
<dd>

</dd>
<dt id="RegSetValue-hKey-sSubKey-uType-sValueData-lValueData"><code>RegSetValue( $hKey, $sSubKey, $uType, $sValueData, $lValueData )</code></dt>
<dd>

<p>This routine is meant only for compatibility with Windows version 3.1. Use <code>RegSetValueEx()</code> instead. This routine can only set unnamed values [a.k.a. &quot;default values&quot;].</p>

</dd>
<dt id="RegSetValueEx">RegSetValueEx</dt>
<dd>

</dd>
<dt id="RegSetValueEx-hKey-sName-uZero-uType-pData-lData"><code>RegSetValueEx( $hKey, $sName, $uZero, $uType, $pData, $lData )</code></dt>
<dd>

<p>Adds or replaces a value in an open Registry key. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key [either <code>HKEY_*</code> or from a previous call].</p>

<p><code>$sName</code> is the name of the value to be set.</p>

<p><code>$uZero</code> is reserved for future use and should be specified as <code>0</code>.</p>

<p><code>$uType</code> is the type of data stored in <code>$pData</code>. It should be a <code>REG_*</code> value.</p>

<p><code>$pData</code> is the value data packed into a Perl string.</p>

<p><code>$lData</code> is the length of the value data that is stored in <code>$pData</code>. You will usually omit this parameter or pass in <code>0</code> to have <code>length($pData)</code> used. In both of these cases, if <code>$iType</code> is <code>REG_SZ</code> or <code>REG_EXPAND_SZ</code>, <code>RegSetValueEx()</code> will append a trailing <code>&#39;\0&#39;</code> to the end of <code>$pData</code> [unless there is already one].</p>

</dd>
<dt id="RegUnLoadKey">RegUnLoadKey</dt>
<dd>

</dd>
<dt id="RegUnLoadKey-hKey-sSubKey"><code>RegUnLoadKey( $hKey, $sSubKey )</code></dt>
<dd>

<p>Unloads a previously loaded hive file. That is, closes the hive file then deletes the subkey that was providing access to it. Returns a true value if successful and a false value [and sets <code>$^E</code>/<code>regLastError()</code>] on failure.</p>

<p><code>$hKey</code> is the handle to a Registry key that has hives loaded in it. This must be <code>HKEY_LOCAL_MACHINE</code>, <code>HKEY_USERS</code>, or a remote version of one of these from a call to <code>RegConnectRegistry()</code>.</p>

<p><code>$sSubKey</code> is the name of the subkey whose hive you wish to have unloaded.</p>

</dd>
<dt id="FuncA">:FuncA</dt>
<dd>

<p>The ASCII-specific function names.</p>

<p>Each of these is identical to the version listed above without the trailing &quot;A&quot;:</p>

<pre><code>        AbortSystemShutdownA    InitiateSystemShutdownA
        RegConnectRegistryA     RegCreateKeyA           RegCreateKeyExA
        RegDeleteKeyA           RegDeleteValueA         RegEnumKeyA
        RegEnumKeyExA           RegEnumValueA           RegLoadKeyA
        RegOpenKeyA             RegOpenKeyExA           RegQueryInfoKeyA
        RegQueryMultipleValuesA RegQueryValueA          RegQueryValueExA
        RegReplaceKeyA          RegRestoreKeyA          RegSaveKeyA
        RegSetValueA            RegSetValueExA          RegUnLoadKeyA</code></pre>

</dd>
<dt id="FuncW">:FuncW</dt>
<dd>

<p>The UNICODE-specific function names. These are the same as the versions listed above without the trailing &quot;W&quot; except that string parameters are UNICODE strings rather than ASCII strings, as indicated.</p>

</dd>
<dt id="AbortSystemShutdownW">AbortSystemShutdownW</dt>
<dd>

</dd>
<dt id="AbortSystemShutdownW-swComputerName"><code>AbortSystemShutdownW( $swComputerName )</code></dt>
<dd>

<p><code>$swComputerName</code> is UNICODE.</p>

</dd>
<dt id="InitiateSystemShutdownW">InitiateSystemShutdownW</dt>
<dd>

</dd>
<dt id="InitiateSystemShutdownW-swComputer-swMessage-uTimeoutSecs-bForce-bReboot"><code>InitiateSystemShutdownW( $swComputer, $swMessage, $uTimeoutSecs, $bForce, $bReboot )</code></dt>
<dd>

<p><code>$swComputer</code> and <code>$swMessage</code> are UNICODE.</p>

</dd>
<dt id="RegConnectRegistryW">RegConnectRegistryW</dt>
<dd>

</dd>
<dt id="RegConnectRegistryW-swComputer-hRootKey-ohKey"><code>RegConnectRegistryW( $swComputer, $hRootKey, $ohKey )</code></dt>
<dd>

<p><code>$swComputer</code> is UNICODE.</p>

</dd>
<dt id="RegCreateKeyW">RegCreateKeyW</dt>
<dd>

</dd>
<dt id="RegCreateKeyW-hKey-swSubKey-ohSubKey"><code>RegCreateKeyW( $hKey, $swSubKey, $ohSubKey )</code></dt>
<dd>

<p><code>$swSubKey</code> is UNICODE.</p>

</dd>
<dt id="RegCreateKeyExW">RegCreateKeyExW</dt>
<dd>

</dd>
<dt id="RegCreateKeyExW-hKey-swSubKey-uZero-swClass-uOpts-uAccess-pSecAttr-ohNewKey-ouDisp"><code>RegCreateKeyExW( $hKey, $swSubKey, $uZero, $swClass, $uOpts, $uAccess, $pSecAttr, $ohNewKey, $ouDisp )</code></dt>
<dd>

<p><code>$swSubKey</code> and <code>$swClass</code> are UNICODE.</p>

</dd>
<dt id="RegDeleteKeyW">RegDeleteKeyW</dt>
<dd>

</dd>
<dt id="RegDeleteKeyW-hKey-swSubKey"><code>RegDeleteKeyW( $hKey, $swSubKey )</code></dt>
<dd>

<p><code>$swSubKey</code> is UNICODE.</p>

</dd>
<dt id="RegDeleteValueW">RegDeleteValueW</dt>
<dd>

</dd>
<dt id="RegDeleteValueW-hKey-swValueName"><code>RegDeleteValueW( $hKey, $swValueName )</code></dt>
<dd>

<p><code>$swValueName</code> is UNICODE.</p>

</dd>
<dt id="RegEnumKeyW">RegEnumKeyW</dt>
<dd>

</dd>
<dt id="RegEnumKeyW-hKey-uIndex-oswName-ilwNameSize"><code>RegEnumKeyW( $hKey, $uIndex, $oswName, $ilwNameSize )</code></dt>
<dd>

<p><code>$oswName</code> is UNICODE and <code>$ilwNameSize</code> is measured as number of <code>WCHAR</code>s.</p>

</dd>
<dt id="RegEnumKeyExW">RegEnumKeyExW</dt>
<dd>

</dd>
<dt id="RegEnumKeyExW-hKey-uIndex-oswName-iolwName-pNull-oswClass-iolwClass-opftLastWrite"><code>RegEnumKeyExW( $hKey, $uIndex, $oswName, $iolwName, $pNull, $oswClass, $iolwClass, $opftLastWrite )</code></dt>
<dd>

<p><code>$swName</code> and <code>$swClass</code> are UNICODE and <code>$iolwName</code> and <code>$iolwClass</code> are measured as number of <code>WCHAR</code>s.</p>

</dd>
<dt id="RegEnumValueW">RegEnumValueW</dt>
<dd>

</dd>
<dt id="RegEnumValueW-hKey-uIndex-oswName-iolwName-pNull-ouType-opData-iolData"><code>RegEnumValueW( $hKey, $uIndex, $oswName, $iolwName, $pNull, $ouType, $opData, $iolData )</code></dt>
<dd>

<p><code>$oswName</code> is UNICODE and <code>$iolwName</code> is measured as number of <code>WCHAR</code>s.</p>

<p><code>$opData</code> is UNICODE if <code>$piType</code> is <code>REG_SZ</code>, <code>REG_EXPAND_SZ</code>, or <code>REG_MULTI_SZ</code>. Note that <code>$iolData</code> is measured as number of bytes even in these cases.</p>

</dd>
<dt id="RegLoadKeyW">RegLoadKeyW</dt>
<dd>

</dd>
<dt id="RegLoadKeyW-hKey-swSubKey-swFileName"><code>RegLoadKeyW( $hKey, $swSubKey, $swFileName )</code></dt>
<dd>

<p><code>$swSubKey</code> and <code>$swFileName</code> are UNICODE.</p>

</dd>
<dt id="RegOpenKeyW">RegOpenKeyW</dt>
<dd>

</dd>
<dt id="RegOpenKeyW-hKey-swSubKey-ohSubKey"><code>RegOpenKeyW( $hKey, $swSubKey, $ohSubKey )</code></dt>
<dd>

<p><code>$swSubKey</code> is UNICODE.</p>

</dd>
<dt id="RegOpenKeyExW">RegOpenKeyExW</dt>
<dd>

</dd>
<dt id="RegOpenKeyExW-hKey-swSubKey-uOptions-uAccess-ohSubKey"><code>RegOpenKeyExW( $hKey, $swSubKey, $uOptions, $uAccess, $ohSubKey )</code></dt>
<dd>

<p><code>$swSubKey</code> is UNICODE.</p>

</dd>
<dt id="RegQueryInfoKeyW">RegQueryInfoKeyW</dt>
<dd>

</dd>
<dt id="RegQueryInfoKeyW-hKey-oswClass-iolwClass-pNull-ocSubKeys-olwSubKey-olwSubClass-ocValues-olwValName-olValData-olSecDesc-opftTime"><code>RegQueryInfoKeyW( $hKey, $oswClass, $iolwClass, $pNull, $ocSubKeys, $olwSubKey, $olwSubClass, $ocValues, $olwValName, $olValData, $olSecDesc, $opftTime )</code></dt>
<dd>

<p><code>$swClass</code> is UNICODE. <code>$iolwClass</code>, <code>$olwSubKey</code>, <code>$olwSubClass</code>, and <code>$olwValName</code> are measured as number of <code>WCHAR</code>s. Note that <code>$olValData</code> is measured as number of bytes.</p>

</dd>
<dt id="RegQueryMultipleValuesW">RegQueryMultipleValuesW</dt>
<dd>

</dd>
<dt id="RegQueryMultipleValuesW-hKey-ioarValueEnts-icValueEnts-opBuffer-iolBuffer"><code>RegQueryMultipleValuesW( $hKey, $ioarValueEnts, $icValueEnts, $opBuffer, $iolBuffer )</code></dt>
<dd>

<p>The <code>ve_valuename</code> fields of the <code>VALENT</code> [actually <code>VALENTW</code>] structures in <code>$ioarValueEnts</code> are UNICODE. Values of type <code>REG_SZ</code>, <code>REG_EXPAND_SZ</code>, and <code>REG_MULTI_SZ</code> are written to <code>$opBuffer</code> in UNICODE. Note that <code>$iolBuffer</code> and the <code>ve_valuelen</code> fields of the <code>VALENT</code> [<code>VALENTW</code>] structures are measured as number of bytes.</p>

</dd>
<dt id="RegQueryValueW">RegQueryValueW</dt>
<dd>

</dd>
<dt id="RegQueryValueW-hKey-swSubKey-oswValueData-iolValueData"><code>RegQueryValueW( $hKey, $swSubKey, $oswValueData, $iolValueData )</code></dt>
<dd>

<p><code>$swSubKey</code> and <code>$oswValueData</code> are UNICODE. Note that <code>$iolValueData</code> is measured as number of bytes.</p>

</dd>
<dt id="RegQueryValueExW">RegQueryValueExW</dt>
<dd>

</dd>
<dt id="RegQueryValueExW-hKey-swName-pNull-ouType-opData-iolData"><code>RegQueryValueExW( $hKey, $swName, $pNull, $ouType, $opData, $iolData )</code></dt>
<dd>

<p><code>$swName</code> is UNICODE.</p>

<p><code>$opData</code> is UNICODE if <code>$ouType</code> is <code>REG_SZ</code>, <code>REG_EXPAND_SZ</code>, or <code>REG_MULTI_SZ</code>. Note that <code>$iolData</code> is measured as number of bytes even in these cases.</p>

</dd>
<dt id="RegReplaceKeyW">RegReplaceKeyW</dt>
<dd>

</dd>
<dt id="RegReplaceKeyW-hKey-swSubKey-swNewFile-swOldFile"><code>RegReplaceKeyW( $hKey, $swSubKey, $swNewFile, $swOldFile )</code></dt>
<dd>

<p><code>$swSubKey</code>, <code>$swNewFile</code>, and <code>$swOldFile</code> are UNICODE.</p>

</dd>
<dt id="RegRestoreKeyW">RegRestoreKeyW</dt>
<dd>

</dd>
<dt id="RegRestoreKeyW-hKey-swFileName-uFlags"><code>RegRestoreKeyW( $hKey, $swFileName, $uFlags )</code></dt>
<dd>

<p><code>$swFileName</code> is UNICODE.</p>

</dd>
<dt id="RegSaveKeyW">RegSaveKeyW</dt>
<dd>

</dd>
<dt id="RegSaveKeyW-hKey-swFileName-pSecAttr"><code>RegSaveKeyW( $hKey, $swFileName, $pSecAttr )</code></dt>
<dd>

<p><code>$swFileName</code> is UNICODE.</p>

</dd>
<dt id="RegSetValueW">RegSetValueW</dt>
<dd>

</dd>
<dt id="RegSetValueW-hKey-swSubKey-uType-swValueData-lValueData"><code>RegSetValueW( $hKey, $swSubKey, $uType, $swValueData, $lValueData )</code></dt>
<dd>

<p><code>$swSubKey</code> and <code>$swValueData</code> are UNICODE. Note that <code>$lValueData</code> is measured as number of bytes even though <code>$swValueData</code> is always UNICODE.</p>

</dd>
<dt id="RegSetValueExW">RegSetValueExW</dt>
<dd>

</dd>
<dt id="RegSetValueExW-hKey-swName-uZero-uType-pData-lData"><code>RegSetValueExW( $hKey, $swName, $uZero, $uType, $pData, $lData )</code></dt>
<dd>

<p><code>$swName</code> is UNICODE.</p>

<p><code>$pData</code> is UNICODE if <code>$uType</code> is <code>REG_SZ</code>, <code>REG_EXPAND_SZ</code>, or <code>REG_MULTI_SZ</code>. Note that <code>$lData</code> is measured as number of bytes even in these cases.</p>

</dd>
<dt id="RegUnLoadKeyW">RegUnLoadKeyW</dt>
<dd>

</dd>
<dt id="RegUnLoadKeyW-hKey-swSubKey"><code>RegUnLoadKeyW( $hKey, $swSubKey )</code></dt>
<dd>

<p><code>$swSubKey</code> is UNICODE.</p>

</dd>
<dt id="HKEY_">:HKEY_</dt>
<dd>

<p>All <code>HKEY_*</code> constants:</p>

<pre><code>        HKEY_CLASSES_ROOT       HKEY_CURRENT_CONFIG     HKEY_CURRENT_USER
        HKEY_DYN_DATA           HKEY_LOCAL_MACHINE      HKEY_PERFORMANCE_DATA
        HKEY_USERS</code></pre>

</dd>
<dt id="KEY_">:KEY_</dt>
<dd>

<p>All <code>KEY_*</code> constants:</p>

<pre><code>        KEY_QUERY_VALUE         KEY_SET_VALUE           KEY_CREATE_SUB_KEY
        KEY_ENUMERATE_SUB_KEYS  KEY_NOTIFY              KEY_CREATE_LINK
        KEY_READ                KEY_WRITE               KEY_EXECUTE
        KEY_ALL_ACCESS</code></pre>

</dd>
<dt id="REG_">:REG_</dt>
<dd>

<p>All <code>REG_*</code> constants:</p>

<pre><code>        REG_CREATED_NEW_KEY             REG_OPENED_EXISTING_KEY

        REG_LEGAL_CHANGE_FILTER         REG_NOTIFY_CHANGE_ATTRIBUTES
        REG_NOTIFY_CHANGE_NAME          REG_NOTIFY_CHANGE_LAST_SET
        REG_NOTIFY_CHANGE_SECURITY      REG_LEGAL_OPTION

        REG_OPTION_BACKUP_RESTORE       REG_OPTION_CREATE_LINK
        REG_OPTION_NON_VOLATILE         REG_OPTION_OPEN_LINK
        REG_OPTION_RESERVED             REG_OPTION_VOLATILE

        REG_WHOLE_HIVE_VOLATILE         REG_REFRESH_HIVE
        REG_NO_LAZY_FLUSH

        REG_NONE                        REG_SZ
        REG_EXPAND_SZ                   REG_BINARY
        REG_DWORD                       REG_DWORD_LITTLE_ENDIAN
        REG_DWORD_BIG_ENDIAN            REG_LINK
        REG_MULTI_SZ                    REG_RESOURCE_LIST
        REG_FULL_RESOURCE_DESCRIPTOR    REG_RESOURCE_REQUIREMENTS_LIST</code></pre>

</dd>
<dt id="ALL">:ALL</dt>
<dd>

<p>All of the above.</p>

</dd>
<dt id="SE_">:SE_</dt>
<dd>

<p>The strings for the following privilege names:</p>

<pre><code>        SE_ASSIGNPRIMARYTOKEN_NAME      SE_AUDIT_NAME
        SE_BACKUP_NAME                  SE_CHANGE_NOTIFY_NAME
        SE_CREATE_PAGEFILE_NAME         SE_CREATE_PERMANENT_NAME
        SE_CREATE_TOKEN_NAME            SE_DEBUG_NAME
        SE_INCREASE_QUOTA_NAME          SE_INC_BASE_PRIORITY_NAME
        SE_LOAD_DRIVER_NAME             SE_LOCK_MEMORY_NAME
        SE_MACHINE_ACCOUNT_NAME         SE_PROF_SINGLE_PROCESS_NAME
        SE_REMOTE_SHUTDOWN_NAME         SE_RESTORE_NAME
        SE_SECURITY_NAME                SE_SHUTDOWN_NAME
        SE_SYSTEMTIME_NAME              SE_SYSTEM_ENVIRONMENT_NAME
        SE_SYSTEM_PROFILE_NAME          SE_TAKE_OWNERSHIP_NAME
        SE_TCB_NAME                     SE_UNSOLICITED_INPUT_NAME</code></pre>

<p>It can be difficult to successfully build this module in a way that makes these constants available. So some builds of this module may not make them available. For such builds, trying to export any of these constants will cause a fatal error. For this reason, none of these symbols are currently included in the <code>&quot;:ALL&quot;</code> grouping.</p>

</dd>
</dl>

</dd>
</dl>

<h2 id="The-Win32API::-hierarchy">The Win32API:: hierarchy</h2>

<p>This and the other Win32API:: modules are meant to expose the nearly raw API calls so they can be used from Perl code in any way they might be used from C code. This provides the following advantages:</p>

<dl>

<dt id="Many-modules-can-be-written-by-people-that-dont-have-a-C-compiler">Many modules can be written by people that don&#39;t have a C compiler.</dt>
<dd>

</dd>
<dt id="Encourages-more-module-code-to-be-written-in-Perl-not-C">Encourages more module code to be written in Perl [not C].</dt>
<dd>

<p>Perl code is often much easier to inspect, debug, customize, and enhance than XS code.</p>

</dd>
<dt id="Allows-those-already-familiar-with-the-Win32-API-to-get-off-to-a-quick-start">Allows those already familiar with the Win32 API to get off to a quick start.</dt>
<dd>

</dd>
<dt id="Provides-an-interactive-tool-for-exploring-even-obscure-details-of-the-Win32-API">Provides an interactive tool for exploring even obscure details of the Win32 API.</dt>
<dd>

<p>It can be very useful to interactively explore ad-hoc calls into parts of the Win32 API using:</p>

<pre><code>    perl -de 0</code></pre>

</dd>
<dt id="Ensures-that-native-Win32-data-structures-can-be-used">Ensures that native Win32 data structures can be used.</dt>
<dd>

<p>This allows maximum efficiency. It also allows data from one module [for example, time or security information from the <code>Win32API::Registry</code> or <code>Win32API::File</code> modules] to be used with other modules [for example, <code>Win32API::Time</code> and <code>Win32API::SecDesc</code>].</p>

</dd>
<dt id="Provides-a-single-version-of-the-XS-interface-to-each-API-call-where-improvements-can-be-collected">Provides a single version of the XS interface to each API call where improvements can be collected.</dt>
<dd>

</dd>
</dl>

<h2 id="Buffer-sizes">Buffer sizes</h2>

<p>For each parameter that specifies a buffer size, a value of <code>0</code> can be passed. For parameter that are pointers to buffer sizes, you can also pass in <code>NULL</code> by specifying an empty list reference, <code>[]</code>. Both of these cases will ensure that the variable has <i>some</i> buffer space allocated to it and pass in that buffer&#39;s allocated size. Many of the calls indicate, via <code>ERROR_MORE_DATA</code>, that the buffer size was not sufficient and the <i>Registry.xs</i> code will automatically enlarge the buffer to the required size and repeat the call.</p>

<p>Numeric buffer sizes are used as minimum initial sizes for the buffers. The larger of this size and the size of space already allocated to the scalar will be passed to the underlying routine. If that size was insufficient, and the underlying call provides an easy method for determining the needed buffer size, then the buffer will be enlarged and the call repeated as above.</p>

<p>The underlying calls define buffer size parameter as unsigned, so negative buffer sizes are treated as very large positive buffer sizes which usually cause <code>malloc()</code> to fail.</p>

<p>To force the <i>Registry.xs</i> code to pass in a specific value for a buffer size, precede the size with an equals sign via <code>&quot;=&quot;.</code>. Buffer sizes that are passed in as strings starting with an equals sign will have the equal sign stripped and the remainder of the string interpreted as a number [via C&#39;s <code>strtoul()</code> using only base 10] which will be passed to the underlying routine [even if the allocated buffer is actually larger]. The <i>Registry.xs</i> code will enlarge the buffer to the specified size, if needed, but will not enlarge the buffer based on the underlying routine requesting more space.</p>

<p>Some Reg*() calls may not currently set the buffer size when they return <code>ERROR_MORE_DATA</code>. But some that are not documented as doing so, currently do so anyway. So the code assumes that any routine <i>might</i> do this and resizes any buffers and repeats the call. We hope that eventually all routines will provide this feature.</p>

<p>When you use <code>[]</code> for a buffer size, you can still find the length of the data returned by using <code>length($buffer)</code>. Note that this length will be in bytes while a few of the buffer sizes would have been in units of wide characters.</p>

<p>Note that the RegQueryValueEx*() and RegEnumValue*() calls will trim the trailing <code>&#39;\0&#39;</code> [if present] from the returned data values of type <code>REG_SZ</code> or <code>REG_EXPAND_SZ</code> but only if the value data length parameter is omitted [or specified as <code>[]</code>].</p>

<p>The RegSetValueEx*() calls will add a trailing <code>&#39;\0&#39;</code> [if missing] to the supplied data values of type <code>REG_SZ</code> and <code>REG_EXPAND_SZ</code> but only if the value data length parameter is omitted [or specified as <code>0</code>].</p>

<h2 id="Hungarian-Notation">Hungarian Notation</h2>

<p>The following abbreviations are used at the start of each parameter name to hint at aspects of how the parameter is used. The prefix is always in lower case and followed by a capital letter that starts the descriptive part of the parameter name. Several of the following abbreviations can be combined into a single prefix.</p>

<p>Probably not all of these prefix notations are used by this module. This document section may be included in any <code>Win32API</code> module and so covers some notations not used by this specific module.</p>

<dl>

<dt id="s">s</dt>
<dd>

<p>A string. In C, a <code>&#39;\0&#39;</code>-terminated <code>char *</code>. In Perl, just a string except that it will be truncated at the first <code>&quot;\0&quot;</code>, if it contains one.</p>

</dd>
<dt id="sw">sw</dt>
<dd>

<p>A wide [UNICODE] string. In C, a <code>L&#39;\0&#39;</code>-terminated <code>WCHAR *</code>. In Perl, a string that contains UNICODE data. You can convert a string to UNICODE in Perl via:</p>

<pre><code>    <span class="variable">$string</span><span class="operator">=</span> <span class="string">"This is an example string"</span><span class="operator">;</span>
    <span class="variable">$unicode</span><span class="operator">=</span> <span class="keyword">pack</span><span class="operator">(</span> <span class="string">"S*"</span><span class="operator">,</span> <span class="keyword">unpack</span><span class="operator">(</span><span class="string">"C*"</span><span class="operator">,</span><span class="variable">$string</span><span class="operator">),</span> <span class="number">0</span> <span class="operator">);</span>
</code></pre>

<p>Note how <code>, 0</code> above causes an explicit <code>L&#39;\0&#39;</code> to be added since Perl&#39;s implicit <code>&#39;\0&#39;</code> that it puts after each of its strings is not wide enough to terminate a UNICODE string. So UNICODE strings are different than regular strings in that the Perl version of a regular string will not include the trailing <code>&#39;\0&#39;</code> while the Perl version of a UNICODE string must include the trailing <code>L&#39;\0&#39;</code>.</p>

<p>If a UNICODE string contains no non-ASCII characters, then you can convert it back into a normal string via:</p>

<pre><code>    <span class="variable">$string</span><span class="operator">=</span> <span class="keyword">pack</span><span class="operator">(</span> <span class="string">"C*"</span><span class="operator">,</span> <span class="keyword">unpack</span><span class="operator">(</span><span class="string">"S*"</span><span class="operator">,</span><span class="variable">$unicode</span><span class="operator">)</span> <span class="operator">);</span>
    <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">s/\0$//</span><span class="operator">;</span>
</code></pre>

</dd>
<dt id="p">p</dt>
<dd>

<p>A pointer to some buffer [usually containing some <code>struct</code>]. In C, a <code>void *</code> or some other pointer type. In Perl, a string that is usually manipulated using <code>pack</code> and <code>unpack</code>. The &quot;p&quot; is usually followed by more prefix character(s) to indicate what type of data is stored in the buffer.</p>

</dd>
<dt id="a">a</dt>
<dd>

<p>A packed array. In C, an array [usually of <code>struct</code>s]. In Perl, a string containing the packed data. The &quot;a&quot; is usually followed by more prefix character(s) to indicate the data type of the elements.</p>

<p>These packed arrays are also called &quot;vectors&quot; in places to avoid confusion with Perl arrays.</p>

</dd>
<dt id="n">n</dt>
<dd>

<p>A generic number. In C, any of the integer or floating point data types. In Perl, a number; either an integer, unsigned, or double [IV, UV, or NV, respectively]. Usually an integer.</p>

</dd>
<dt id="iv">iv</dt>
<dd>

<p>A signed integral value. In C, any of the signed integer data types. In Perl, an integer [IV].</p>

</dd>
<dt id="u">u</dt>
<dd>

<p>An unsigned integral value. In C, any of the unsigned integer data types. In Perl, an unsigned integer [UV].</p>

</dd>
<dt id="d">d</dt>
<dd>

<p>A floating-point number. In C, a <code>float</code> or <code>double</code> or, perhaps, a <code>long double</code>. In Perl, a double-precision floating-point number [NV].</p>

</dd>
<dt id="b">b</dt>
<dd>

<p>A Boolean value. In C, any integer data type, though usually via a type alias of <code>bool</code> or <code>BOOL</code>, containing either a 0 [false] or non-zero [true] value. In Perl, a scalar containing a Boolean value [<code>0</code>, <code>&quot;&quot;</code>, or <code>undef</code> for &quot;false&quot; and anything else for &quot;true&quot;].</p>

</dd>
<dt id="c">c</dt>
<dd>

<p>A count of items. In C, any integer data type. In Perl, an unsigned integer [UV]. Usually used in conjunction with a &quot;vector&quot; parameter [see <a href="#a">&quot;a&quot;</a> above] to indicate the number of elements.</p>

</dd>
<dt id="l">l</dt>
<dd>

<p>A length [in bytes]. In C, any integer data type. In Perl, an unsigned integer [UV]. Usually used in conjunction with a &quot;string&quot; or &quot;pointer&quot; parameter [see <a href="#s">&quot;s&quot;</a> and <a href="#p">&quot;p&quot;</a> above] to indicate the buffer size or the size of the value stored in the buffer.</p>

<p>For strings, there is no general rule as to whether the trailing <code>&#39;\0&#39;</code> is included in such sizes. For this reason, the <code>Win32API</code> modules follow the Perl rule of always allocating one extra byte and reporting buffer sizes as being one smaller than allocated in case the <code>&#39;\0&#39;</code> is not included in the size.</p>

</dd>
<dt id="lw">lw</dt>
<dd>

<p>A length measured as number of UNICODE characters. In C, a count of <code>WCHAR</code>s. In Perl, an unsigned integer [UV] counting &quot;shorts&quot; [see &quot;s&quot; and &quot;S&quot; in <code>pack</code> and <code>unpack</code>].</p>

<p>For UNICODE strings, the trailing <code>L&#39;\0&#39;</code> may or may not be included in a length so, again, we always allocate extra room for one and don&#39;t report that extra space.</p>

</dd>
<dt id="h">h</dt>
<dd>

<p>A handle. In C, a <code>HANDLE</code> or more-specific handle data type. In Perl, an unsigned integer [UV]. In C, these handles are often actually some type of pointer, but Perl just treats them as opaque numbers, as it should. This prefix is also used for other pointers that are treated as integers in Perl code.</p>

</dd>
<dt id="r">r</dt>
<dd>

<p>A record. In C, almost always a <code>struct</code> or perhaps <code>union</code>. Note that C <code>struct</code>s are rarely passed by value so the &quot;r&quot; is almost always preceded by a &quot;p&quot; or &quot;a&quot; [see <a href="#p">&quot;p&quot;</a> and <a href="#a">&quot;a&quot;</a> above]. For the very rare unadorned &quot;r&quot;, Perl stores the record in the same way as a &quot;pr&quot;, that is, in a string. For the very rare case where Perl explicitly stores a pointer to the <code>struct</code> rather than storing the <code>struct</code> directly in a Perl string, the prefix &quot;pp&quot; or &quot;ppr&quot; or even &quot;par&quot; is used.</p>

</dd>
<dt id="sv">sv</dt>
<dd>

</dd>
<dt id="rv">rv</dt>
<dd>

</dd>
<dt id="hv">hv</dt>
<dd>

</dd>
<dt id="av">av</dt>
<dd>

</dd>
<dt id="cv">cv</dt>
<dd>

<p>A Perl data type. Respectively, a scalar value [SV], a reference [RV] [usually to a scalar], a hash [HV], a Perl array [AV], or a Perl code reference [PVCV]. For the &quot;hv&quot;, &quot;av&quot;, and &quot;cv&quot; prefixes, a leading &quot;rv&quot; is usually assumed. For a parameter to an XS subroutine, a prefix of &quot;sv&quot; means the parameter is a scalar and so may be a string or a number [or <code>undef</code>] or even both at the same time. So &quot;sv&quot; doesn&#39;t imply a leading &quot;rv&quot;.</p>

</dd>
<dt id="Input-or-Output">Input or Output</dt>
<dd>

<p>Whether a parameter is for input data, output data, or both is usually not reflected by the data type prefix. In cases where this is not obvious nor reflected in the parameter name proper, we may use the following in front of the data type prefix.</p>

<dl>

<dt id="i">i</dt>
<dd>

<p>An input parameter given to the API [usually omitted].</p>

</dd>
<dt id="o">o</dt>
<dd>

<p>An output-only parameter taken from the API. You should not get a warning if such a parameter is <code>undef</code> when you pass it into the function. You should get an error if such a parameter is read-only. You can [usually] pass in <code>[]</code> for such a parameter to have the parameter silently ignored.</p>

<p>The output may be written directly into the Perl variable passed to the subroutine, the same way the buffer parameter to Perl&#39;s <code>sysread()</code>. This method is often avoided in Perl because the call then lacks any visual cue that some parameters are being overwritten. But this method closely matches the C API which is what we are trying to do.</p>

</dd>
<dt id="io">io</dt>
<dd>

<p>Input given to the API then overwritten with output taken from the API. You should get a warning [if <b>-w</b> is in effect] if such a parameter is <code>undef</code> when you pass it into the function [unless it is a buffer or buffer length parameter]. If the value is read-only, then [for most parameters] the output is silently not written. This is because it is often convenient to pass in read-only constants for many such parameters. You can also usually pass in <code>[]</code> for such parameters.</p>

</dd>
</dl>

</dd>
<dt id="pp">pp</dt>
<dd>

</dd>
<dt id="ppr">ppr</dt>
<dd>

</dd>
<dt id="par">par</dt>
<dd>

</dd>
<dt id="pap">pap</dt>
<dd>

<p>These are just unusual combinations of prefix characters described above.</p>

<p>For each, a pointer is stored in a [4-byte] Perl string. You can usually use <code>unpack &quot;P&quot;</code> to access the real data from Perl.</p>

<p>For &quot;ppr&quot; [and often for &quot;pp&quot;], the pointer points directly at a C <code>struct</code>. For &quot;par&quot;, the pointer points to the first element of a C [packed] array of <code>struct</code>s. For &quot;pap&quot;, the pointer points to a C [packed] array of pointers to other things.</p>

</dd>
<dt id="ap">ap</dt>
<dd>

<p>Here we have a list of pointers packed into a single Perl string.</p>

</dd>
</dl>

<h1 id="BUGS">BUGS</h1>

<p>The old ActiveState ports of Perl for Win32 [but not, ActivePerl, the ActiveState distributions of standard Perl 5.004 and beyond] do not support the tools for building extensions and so do not support this extension.</p>

<p>No routines are provided for using the data returned in the <code>FILETIME</code> buffers. Those are in the <code>Win32API::Time</code> module.</p>

<p>No routines are provided for dealing with UNICODE data effectively. See <a href="#FuncW">&quot;:FuncW&quot;</a> above for some simple-minded UNICODE methods.</p>

<p>Parts of the module test will fail if used on a version of Perl that does not yet set <code>$^E</code> based on <code>GetLastError()</code>.</p>

<p>On NT 4.0 [at least], the RegEnum*() calls do not set the required buffer sizes when returning <code>ERROR_MORE_DATA</code> so this module will not grow the buffers in such cases. <code>Win32::TieRegistry</code> overcomes this by using values from <code>RegQueryInfoKey()</code> for buffer sizes in RegEnum* calls.</p>

<p>On NT 4.0 [at least], <code>RegQueryInfoKey()</code> on <code>HKEY_PERFORMANCE_DATA</code> never succeeds. Also, <code>RegQueryValueEx()</code> on <code>HKEY_PERFORMANCE_DATA</code> never returns the required buffer size. To access <code>HKEY_PERFORMANCE_DATA</code> you will need to keep growing the data buffer until the call succeeds.</p>

<p>Because <code>goto &amp;subroutine</code> seems to be buggy under Win32 Perl, it is not used in the stubs in <i>Registry.pm</i>.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Tye McQueen, tye@metronet.com, http://www.metronet.com/~tye/.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>perl</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<dl>

<dt id="Win32::TieRegistry"><a href="../../lib/Win32/TieRegistry.html">Win32::TieRegistry</a></dt>
<dd>

</dd>
<dt id="Win32::Registry"><a href="../../lib/Win32/Registry.html">Win32::Registry</a></dt>
<dd>

</dd>
</dl>


</body>

</html>


