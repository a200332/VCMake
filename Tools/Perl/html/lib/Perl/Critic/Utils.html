<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#INTERFACE-SUPPORT">INTERFACE SUPPORT</a></li>
  <li><a href="#IMPORTABLE-SUBS">IMPORTABLE SUBS</a></li>
  <li><a href="#IMPORTABLE-VARIABLES">IMPORTABLE VARIABLES</a></li>
  <li><a href="#IMPORT-TAGS">IMPORT TAGS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Perl::Critic::Utils - General utility subroutines and constants for Perl::Critic and derivative distributions.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides several static subs and variables that are useful for developing <a href="../../../lib/Perl/Critic/Policy.html">Perl::Critic::Policy</a> subclasses. Unless you are writing Policy modules, you probably don&#39;t care about this package.</p>

<h1 id="INTERFACE-SUPPORT">INTERFACE SUPPORT</h1>

<p>This is considered to be a public module. Any changes to its interface will go through a deprecation cycle.</p>

<h1 id="IMPORTABLE-SUBS">IMPORTABLE SUBS</h1>

<dl>

<dt id="find_keywords-doc-keyword"><code>find_keywords( $doc, $keyword )</code></dt>
<dd>

<p><b>DEPRECATED:</b> Since version 0.11, every Policy is evaluated at each element of the document. So you shouldn&#39;t need to go looking for a particular keyword. If you <i>do</i> want to use this, please import it via the <code>:deprecated</code> tag, rather than directly, to mark the module as needing updating.</p>

<p>Given a <a href="../../../lib/PPI/Document.html">PPI::Document</a> as <code>$doc</code>, returns a reference to an array containing all the <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a> elements that match <code>$keyword</code>. This can be used to find any built-in function, method call, bareword, or reserved keyword. It will not match variables, subroutine names, literal strings, numbers, or symbols. If the document doesn&#39;t contain any matches, returns undef.</p>

</dd>
<dt id="is_assignment_operator-element"><code>is_assignment_operator( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Operator.html">PPI::Token::Operator</a> or a string, returns true if that token represents one of the assignment operators (e.g. <code>= &amp;&amp;= ||= //= += -=</code> etc.).</p>

</dd>
<dt id="is_perl_global-element"><code>is_perl_global( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Symbol.html">PPI::Token::Symbol</a> or a string, returns true if that token represents one of the global variables provided by the <a href="../../../lib/English.html">English</a> module, or one of the builtin global variables like <code>%SIG</code>, <code>%ENV</code>, or <code>@ARGV</code>. The sigil on the symbol is ignored, so things like <code>$ARGV</code> or <code>$ENV</code> will still return true.</p>

</dd>
<dt id="is_perl_builtin-element"><code>is_perl_builtin( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8.</p>

</dd>
<dt id="is_perl_bareword-element"><code>is_perl_bareword( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a bareword (e.g. &quot;if&quot;, &quot;else&quot;, &quot;sub&quot;, &quot;package&quot;) defined in Perl 5.8.8.</p>

</dd>
<dt id="is_perl_filehandle-element"><code>is_perl_filehandle( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, or string, returns true if that token represents one of the global filehandles (e.g. <code>STDIN</code>, <code>STDERR</code>, <code>STDOUT</code>, <code>ARGV</code>) that are defined in Perl 5.8.8. Note that this function will return false if given a filehandle that is represented as a typeglob (e.g. <code>*STDIN</code>)</p>

</dd>
<dt id="is_perl_builtin_with_list_context-element"><code>is_perl_builtin_with_list_context( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that provide a list context to the following tokens.</p>

</dd>
<dt id="is_perl_builtin_with_multiple_arguments-element"><code>is_perl_builtin_with_multiple_arguments( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that <b>can</b> take multiple arguments.</p>

</dd>
<dt id="is_perl_builtin_with_no_arguments-element"><code>is_perl_builtin_with_no_arguments( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that <b>cannot</b> take any arguments.</p>

</dd>
<dt id="is_perl_builtin_with_one_argument-element"><code>is_perl_builtin_with_one_argument( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes <b>one and only one</b> argument.</p>

</dd>
<dt id="is_perl_builtin_with_optional_argument-element"><code>is_perl_builtin_with_optional_argument( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes <b>no more than one</b> argument.</p>

<p>The sets of values for which <code>is_perl_builtin_with_multiple_arguments()</code>, <code>is_perl_builtin_with_no_arguments()</code>, <code>is_perl_builtin_with_one_argument()</code>, and <code>is_perl_builtin_with_optional_argument()</code> return true are disjoint and their union is precisely the set of values that <code>is_perl_builtin()</code> will return true for.</p>

</dd>
<dt id="is_perl_builtin_with_zero_and_or_one_arguments-element"><code>is_perl_builtin_with_zero_and_or_one_arguments( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, <a href="../../../lib/PPI/Statement/Sub.html">PPI::Statement::Sub</a>, or string, returns true if that token represents a call to any of the builtin functions defined in Perl 5.8.8 that takes no and/or one argument.</p>

<p>Returns true if any of <code>is_perl_builtin_with_no_arguments()</code>, <code>is_perl_builtin_with_one_argument()</code>, and <code>is_perl_builtin_with_optional_argument()</code> returns true.</p>

</dd>
<dt id="is_qualified_name-name"><code>is_qualified_name( $name )</code></dt>
<dd>

<p>Given a string, <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, or <a href="../../../lib/PPI/Token/Symbol.html">PPI::Token::Symbol</a>, answers whether it has a module component, i.e. contains &quot;::&quot;.</p>

</dd>
<dt id="precedence_of-element"><code>precedence_of( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Operator.html">PPI::Token::Operator</a> or a string, returns the precedence of the operator, where 1 is the highest precedence. Returns undef if the precedence can&#39;t be determined (which is usually because it is not an operator).</p>

</dd>
<dt id="is_hash_key-element"><code>is_hash_key( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Element.html">PPI::Element</a>, returns true if the element is a literal hash key. PPI doesn&#39;t distinguish between regular barewords (like keywords or subroutine calls) and barewords in hash subscripts (which are considered literal). So this subroutine is useful if your Policy is searching for <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a> elements and you want to filter out the hash subscript variety. In both of the following examples, &quot;foo&quot; is considered a hash key:</p>

<pre><code>    <span class="variable">$hash1</span><span class="operator">{</span><span class="string">foo</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="variable">%hash2</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">foo</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">);</span>
</code></pre>

<p>But if the bareword is followed by an argument list, then perl treats it as a function call. So in these examples, &quot;foo&quot; is <b>not</b> considered a hash key:</p>

<pre><code>    <span class="variable">$hash1</span><span class="operator">{</span> <span class="variable">foo</span><span class="operator">()</span> <span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">&amp;</span><span class="variable">hash2</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">foo</span><span class="operator">()</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">);</span>
</code></pre>

</dd>
<dt id="is_included_module_name-element"><code>is_included_module_name( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element is the name of a module that is being included via <code>use</code>, <code>require</code>, or <code>no</code>.</p>

</dd>
<dt id="is_integer-value"><code>is_integer( $value )</code></dt>
<dd>

<p>Answers whether the parameter, as a string, looks like an integral value.</p>

</dd>
<dt id="is_class_name-element"><code>is_class_name( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element that immediately follows this element is the dereference operator &quot;-&gt;&quot;. When a bareword has a &quot;-&gt;&quot; on the <b>right</b> side, it usually means that it is the name of the class (from which a method is being called).</p>

</dd>
<dt id="is_label_pointer-element"><code>is_label_pointer( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element is the label in a <code>next</code>, <code>last</code>, <code>redo</code>, or <code>goto</code> statement. Note this is not the same thing as the label declaration.</p>

</dd>
<dt id="is_method_call-element"><code>is_method_call( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element that immediately precedes this element is the dereference operator &quot;-&gt;&quot;. When a bareword has a &quot;-&gt;&quot; on the <b>left</b> side, it usually means that it is the name of a method (that is being called from a class).</p>

</dd>
<dt id="is_package_declaration-element"><code>is_package_declaration( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element is the name of a package that is being declared.</p>

</dd>
<dt id="is_subroutine_name-element"><code>is_subroutine_name( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>, returns true if the element is the name of a subroutine declaration. This is useful for distinguishing barewords and from function calls from subroutine declarations.</p>

</dd>
<dt id="is_function_call-element"><code>is_function_call( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a> returns true if the element appears to be call to a static function. Specifically, this function returns true if <code>is_hash_key</code>, <code>is_method_call</code>, <code>is_subroutine_name</code>, <code>is_included_module_name</code>, <code>is_package_declaration</code>, <code>is_perl_bareword</code>, <code>is_perl_filehandle</code>, <code>is_label_pointer</code> and <code>is_subroutine_name</code> all return false for the given element.</p>

</dd>
<dt id="first_arg-element"><code>first_arg( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Element.html">PPI::Element</a> that is presumed to be a function call (which is usually a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>), return the first argument. This is similar of <code>parse_arg_list()</code> and follows the same logic. Note that for the code:</p>

<pre><code>    int($x + 0.5)</code></pre>

<p>this function will return just the <code>$x</code>, not the whole expression. This is different from the behavior of <code>parse_arg_list()</code>. Another caveat is:</p>

<pre><code>    int(($x + $y) + 0.5)</code></pre>

<p>which returns <code>($x + $y)</code> as a <a href="../../../lib/PPI/Structure/List.html">PPI::Structure::List</a> instance.</p>

</dd>
<dt id="parse_arg_list-element"><code>parse_arg_list( $element )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Element.html">PPI::Element</a> that is presumed to be a function call (which is usually a <a href="../../../lib/PPI/Token/Word.html">PPI::Token::Word</a>), splits the argument expressions into arrays of tokens. Returns a list containing references to each of those arrays. This is useful because parentheses are optional when calling a function, and PPI parses them very differently. So this method is a poor-man&#39;s parse tree of PPI nodes. It&#39;s not bullet-proof because it doesn&#39;t respect precedence. In general, I don&#39;t like the way this function works, so don&#39;t count on it to be stable (or even present).</p>

</dd>
<dt id="split_nodes_on_comma-nodes"><code>split_nodes_on_comma( @nodes )</code></dt>
<dd>

<p>This has the same return type as <code>parse_arg_list()</code> but expects to be passed the nodes that represent the interior of a list, like:</p>

<pre><code>    &#39;foo&#39;, 1, 2, &#39;bar&#39;</code></pre>

</dd>
<dt id="is_script-document"><code>is_script( $document )</code></dt>
<dd>

<p><b>This subroutine is deprecated and will be removed in a future release.</b> You should use the <a href="../../../lib/Perl/Critic/Document.html#is_program">&quot;is_program()&quot; in Perl::Critic::Document</a> method instead.</p>

</dd>
<dt id="is_in_void_context-token"><code>is_in_void_context( $token )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Token.html">PPI::Token</a>, answer whether it appears to be in a void context.</p>

</dd>
<dt id="policy_long_name-policy_name"><code>policy_long_name( $policy_name )</code></dt>
<dd>

<p>Given a policy class name in long or short form, return the long form.</p>

</dd>
<dt id="policy_short_name-policy_name"><code>policy_short_name( $policy_name )</code></dt>
<dd>

<p>Given a policy class name in long or short form, return the short form.</p>

</dd>
<dt id="all_perl_files-directories"><code>all_perl_files( @directories )</code></dt>
<dd>

<p>Given a list of directories, recursively searches through all the directories (depth first) and returns a list of paths for all the files that are Perl code files. Any administrative files for CVS or Subversion are skipped, as are things that look like temporary or backup files.</p>

<p>A Perl code file is:</p>

<ul>

<li><p>Any file that ends in <i>.PL</i>, <i>.pl</i>, <i>.pm</i>, or <i>.t</i></p>

</li>
<li><p>Any file that has a first line with a shebang containing &#39;perl&#39;</p>

</li>
</ul>

</dd>
<dt id="severity_to_number-severity"><code>severity_to_number( $severity )</code></dt>
<dd>

<p>If <code>$severity</code> is given as an integer, this function returns <code>$severity</code> but normalized to lie between <code>$SEVERITY_LOWEST</code> and <code>$SEVERITY_HIGHEST</code>. If <code>$severity</code> is given as a string, this function returns the corresponding severity number. If the string doesn&#39;t have a corresponding number, this function will throw an exception.</p>

</dd>
<dt id="is_valid_numeric_verbosity-severity"><code>is_valid_numeric_verbosity( $severity )</code></dt>
<dd>

<p>Answers whether the argument has a translation to a Violation format.</p>

</dd>
<dt id="verbosity_to_format-verbosity_level"><code>verbosity_to_format( $verbosity_level )</code></dt>
<dd>

<p>Given a verbosity level between 1 and 10, returns the corresponding predefined format string. These formats are suitable for passing to the <code>set_format</code> method in <a href="../../../lib/Perl/Critic/Violation.html">Perl::Critic::Violation</a>. See the <a href="../../../bin/perlcritic.html">perlcritic</a> documentation for a listing of the predefined formats.</p>

</dd>
<dt id="hashify-list"><code>hashify( @list )</code></dt>
<dd>

<p>Given <code>@list</code>, return a hash where <code>@list</code> is in the keys and each value is 1. Duplicate values in <code>@list</code> are silently squished.</p>

</dd>
<dt id="interpolate-literal"><code>interpolate( $literal )</code></dt>
<dd>

<p>Given a <code>$literal</code> string that may contain control characters (e.g.. &#39;\t&#39; &#39;\n&#39;), this function does a double interpolation on the string and returns it as if it had been declared in double quotes. For example:</p>

<pre><code>    &#39;foo \t bar \n&#39; ...becomes... &quot;foo \t bar \n&quot;</code></pre>

</dd>
<dt id="shebang_line-document"><code>shebang_line( $document )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Document.html">PPI::Document</a>, test if it starts with <code><span class="comment">#!</span>
</code>. If so, return that line. Otherwise return undef.</p>

</dd>
<dt id="words_from_string-str"><code>words_from_string( $str )</code></dt>
<dd>

<p>Given config string <i>$str</i>, return all the words from the string. This is safer than splitting on whitespace.</p>

</dd>
<dt id="is_unchecked_call-element-autodie_modules"><code>is_unchecked_call( $element, $autodie_modules )</code></dt>
<dd>

<p>Given a <a href="../../../lib/PPI/Element.html">PPI::Element</a>, test to see if it contains a function call whose return value is not checked. The second argument is an array reference of module names which export <code>autodie</code>. The <code>autodie</code> module is always included in this list by default.</p>

</dd>
</dl>

<h1 id="IMPORTABLE-VARIABLES">IMPORTABLE VARIABLES</h1>

<dl>

<dt id="COMMA"><code>$COMMA</code></dt>
<dd>

</dd>
<dt id="FATCOMMA"><code>$FATCOMMA</code></dt>
<dd>

</dd>
<dt id="COLON"><code>$COLON</code></dt>
<dd>

</dd>
<dt id="SCOLON"><code>$SCOLON</code></dt>
<dd>

</dd>
<dt id="QUOTE"><code>$QUOTE</code></dt>
<dd>

</dd>
<dt id="DQUOTE"><code>$DQUOTE</code></dt>
<dd>

</dd>
<dt id="BACKTICK"><code>$BACKTICK</code></dt>
<dd>

</dd>
<dt id="PERIOD"><code>$PERIOD</code></dt>
<dd>

</dd>
<dt id="PIPE"><code>$PIPE</code></dt>
<dd>

</dd>
<dt id="EMPTY"><code>$EMPTY</code></dt>
<dd>

</dd>
<dt id="EQUAL"><code>$EQUAL</code></dt>
<dd>

</dd>
<dt id="SPACE"><code>$SPACE</code></dt>
<dd>

</dd>
<dt id="SLASH"><code>$SLASH</code></dt>
<dd>

</dd>
<dt id="BSLASH"><code>$BSLASH</code></dt>
<dd>

</dd>
<dt id="LEFT_PAREN"><code>$LEFT_PAREN</code></dt>
<dd>

</dd>
<dt id="RIGHT_PAREN"><code>$RIGHT_PAREN</code></dt>
<dd>

<p>These character constants give clear names to commonly-used strings that can be hard to read when surrounded by quotes and other punctuation. Can be imported in one go via the <code>:characters</code> tag.</p>

</dd>
<dt id="SEVERITY_HIGHEST"><code>$SEVERITY_HIGHEST</code></dt>
<dd>

</dd>
<dt id="SEVERITY_HIGH"><code>$SEVERITY_HIGH</code></dt>
<dd>

</dd>
<dt id="SEVERITY_MEDIUM"><code>$SEVERITY_MEDIUM</code></dt>
<dd>

</dd>
<dt id="SEVERITY_LOW"><code>$SEVERITY_LOW</code></dt>
<dd>

</dd>
<dt id="SEVERITY_LOWEST"><code>$SEVERITY_LOWEST</code></dt>
<dd>

<p>These numeric constants define the relative severity of violating each <a href="../../../lib/Perl/Critic/Policy.html">Perl::Critic::Policy</a>. The <code>get_severity</code> and <code>default_severity</code> methods of every Policy subclass must return one of these values. Can be imported via the <code>:severities</code> tag.</p>

</dd>
<dt id="DEFAULT_VERBOSITY"><code>$DEFAULT_VERBOSITY</code></dt>
<dd>

<p>The default numeric verbosity.</p>

</dd>
<dt id="DEFAULT_VERBOSITY_WITH_FILE_NAME"><code>$DEFAULT_VERBOSITY_WITH_FILE_NAME</code></dt>
<dd>

<p>The numeric verbosity that corresponds to the format indicated by <code>$DEFAULT_VERBOSITY</code>, but with the file name prefixed to it.</p>

</dd>
<dt id="TRUE"><code>$TRUE</code></dt>
<dd>

</dd>
<dt id="FALSE"><code>$FALSE</code></dt>
<dd>

<p>These are simple booleans. 1 and 0 respectively. Be mindful of using these with string equality. <code>$FALSE ne $EMPTY</code>. Can be imported via the <code>:booleans</code> tag.</p>

</dd>
</dl>

<h1 id="IMPORT-TAGS">IMPORT TAGS</h1>

<p>The following groups of functions and constants are available as parameters to a <code>use Perl::Critic::Util</code> statement.</p>

<dl>

<dt id="all"><code>:all</code></dt>
<dd>

<p>The lot.</p>

</dd>
<dt id="booleans"><code>:booleans</code></dt>
<dd>

<p>Includes: <code>$TRUE</code>, <code>$FALSE</code></p>

</dd>
<dt id="severities"><code>:severities</code></dt>
<dd>

<p>Includes: <code>$SEVERITY_HIGHEST</code>, <code>$SEVERITY_HIGH</code>, <code>$SEVERITY_MEDIUM</code>, <code>$SEVERITY_LOW</code>, <code>$SEVERITY_LOWEST</code>, <code>@SEVERITY_NAMES</code></p>

</dd>
<dt id="characters"><code>:characters</code></dt>
<dd>

<p>Includes: <code>$COLON</code>, <code>$COMMA</code>, <code>$DQUOTE</code>, <code>$EMPTY</code>, <code>$FATCOMMA</code>, <code>$PERIOD</code>, <code>$PIPE</code>, <code>$QUOTE</code>, <code>$BACKTICK</code>, <code>$SCOLON</code>, <code>$SPACE</code>, <code>$SLASH</code>, <code>$BSLASH</code> <code>$LEFT_PAREN</code> <code>$RIGHT_PAREN</code></p>

</dd>
<dt id="classification"><code>:classification</code></dt>
<dd>

<p>Includes: <code>is_assignment_operator</code>, <code>is_class_name</code>, <code>is_function_call</code>, <code>is_hash_key</code>, <code>is_included_module_name</code>, <code>is_integer</code>, <code>is_label_pointer</code>, <code>is_method_call</code>, <code>is_package_declaration</code>, <code>is_perl_bareword</code>, <code>is_perl_builtin</code>, <code>is_perl_filehandle</code>, <code>is_perl_global</code>, <code>is_perl_builtin_with_list_context</code> <code>is_perl_builtin_with_multiple_arguments</code> <code>is_perl_builtin_with_no_arguments</code> <code>is_perl_builtin_with_one_argument</code> <code>is_perl_builtin_with_optional_argument</code> <code>is_perl_builtin_with_zero_and_or_one_arguments</code> <code>is_qualified_name</code>, <code>is_script</code>, <code>is_subroutine_name</code>, <code>is_unchecked_call</code> <code>is_valid_numeric_verbosity</code></p>

<p>See also <a href="../../../lib/Perl/Critic/Utils/PPI.html">Perl::Critic::Utils::PPI</a>.</p>

</dd>
<dt id="data_conversion"><code>:data_conversion</code></dt>
<dd>

<p>Generic manipulation, not having anything specific to do with Perl::Critic.</p>

<p>Includes: <code>hashify</code>, <code>words_from_string</code>, <code>interpolate</code></p>

</dd>
<dt id="ppi"><code>:ppi</code></dt>
<dd>

<p>Things for dealing with <a href="../../../lib/PPI.html">PPI</a>, other than classification.</p>

<p>Includes: <code>first_arg</code>, <code>parse_arg_list</code></p>

<p>See also <a href="../../../lib/Perl/Critic/Utils/PPI.html">Perl::Critic::Utils::PPI</a>.</p>

</dd>
<dt id="internal_lookup"><code>:internal_lookup</code></dt>
<dd>

<p>Translations between internal representations.</p>

<p>Includes: <code>severity_to_number</code>, <code>verbosity_to_format</code></p>

</dd>
<dt id="language"><code>:language</code></dt>
<dd>

<p>Information about Perl not programmatically available elsewhere.</p>

<p>Includes: <code>precedence_of</code></p>

</dd>
<dt id="deprecated"><code>:deprecated</code></dt>
<dd>

<p>Not surprisingly, things that are deprecated. It is preferred to use this tag to get to these functions, rather than the function names themselves, so as to mark any module using them as needing cleanup.</p>

<p>Includes: <code>find_keywords</code></p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../../lib/Perl/Critic/Utils/Constants.html">Perl::Critic::Utils::Constants</a>, <a href="../../../lib/Perl/Critic/Utils/McCabe.html">Perl::Critic::Utils::McCabe</a>, <a href="../../../lib/Perl/Critic/Utils/PPI.html">Perl::Critic::Utils::PPI</a>,</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Jeffrey Ryan Thalhammer &lt;jeff@imaginative-software.com&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2005-2011 Imaginative Software Systems. All rights reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. The full text of this license can be found in the LICENSE file included with this module.</p>


</body>

</html>


